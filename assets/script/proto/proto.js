/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
//(window || global).PB = 
var protobuf = require("protobufjs/minimal.js");
var pRoot = (function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.PB_CSArenaReq = (function() {
    
        /**
         * Properties of a PB_CSArenaReq.
         * @exports IPB_CSArenaReq
         * @interface IPB_CSArenaReq
         * @property {number|null} [type] PB_CSArenaReq type
         * @property {Array.<number>|null} [param1] PB_CSArenaReq param1
         * @property {Array.<number>|null} [param2] PB_CSArenaReq param2
         */
    
        /**
         * Constructs a new PB_CSArenaReq.
         * @exports PB_CSArenaReq
         * @classdesc Represents a PB_CSArenaReq.
         * @implements IPB_CSArenaReq
         * @constructor
         * @param {IPB_CSArenaReq=} [properties] Properties to set
         */
        function PB_CSArenaReq(properties) {
            this.param1 = [];
            this.param2 = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSArenaReq type.
         * @member {number} type
         * @memberof PB_CSArenaReq
         * @instance
         */
        PB_CSArenaReq.prototype.type = 0;
    
        /**
         * PB_CSArenaReq param1.
         * @member {Array.<number>} param1
         * @memberof PB_CSArenaReq
         * @instance
         */
        PB_CSArenaReq.prototype.param1 = $util.emptyArray;
    
        /**
         * PB_CSArenaReq param2.
         * @member {Array.<number>} param2
         * @memberof PB_CSArenaReq
         * @instance
         */
        PB_CSArenaReq.prototype.param2 = $util.emptyArray;
    
        /**
         * Creates a new PB_CSArenaReq instance using the specified properties.
         * @function create
         * @memberof PB_CSArenaReq
         * @static
         * @param {IPB_CSArenaReq=} [properties] Properties to set
         * @returns {PB_CSArenaReq} PB_CSArenaReq instance
         */
        PB_CSArenaReq.create = function create(properties) {
            return new PB_CSArenaReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSArenaReq message. Does not implicitly {@link PB_CSArenaReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSArenaReq
         * @static
         * @param {IPB_CSArenaReq} message PB_CSArenaReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSArenaReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.param1 != null && message.param1.length)
                for (var i = 0; i < message.param1.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.param1[i]);
            if (message.param2 != null && message.param2.length)
                for (var i = 0; i < message.param2.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.param2[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSArenaReq message, length delimited. Does not implicitly {@link PB_CSArenaReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSArenaReq
         * @static
         * @param {IPB_CSArenaReq} message PB_CSArenaReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSArenaReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSArenaReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSArenaReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSArenaReq} PB_CSArenaReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSArenaReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSArenaReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.param1 && message.param1.length))
                        message.param1 = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param1.push(reader.int32());
                    } else
                        message.param1.push(reader.int32());
                    break;
                case 3:
                    if (!(message.param2 && message.param2.length))
                        message.param2 = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param2.push(reader.int32());
                    } else
                        message.param2.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSArenaReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSArenaReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSArenaReq} PB_CSArenaReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSArenaReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSArenaReq message.
         * @function verify
         * @memberof PB_CSArenaReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSArenaReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.param1 != null && message.hasOwnProperty("param1")) {
                if (!Array.isArray(message.param1))
                    return "param1: array expected";
                for (var i = 0; i < message.param1.length; ++i)
                    if (!$util.isInteger(message.param1[i]))
                        return "param1: integer[] expected";
            }
            if (message.param2 != null && message.hasOwnProperty("param2")) {
                if (!Array.isArray(message.param2))
                    return "param2: array expected";
                for (var i = 0; i < message.param2.length; ++i)
                    if (!$util.isInteger(message.param2[i]))
                        return "param2: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSArenaReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSArenaReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSArenaReq} PB_CSArenaReq
         */
        PB_CSArenaReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSArenaReq)
                return object;
            var message = new $root.PB_CSArenaReq();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.param1) {
                if (!Array.isArray(object.param1))
                    throw TypeError(".PB_CSArenaReq.param1: array expected");
                message.param1 = [];
                for (var i = 0; i < object.param1.length; ++i)
                    message.param1[i] = object.param1[i] | 0;
            }
            if (object.param2) {
                if (!Array.isArray(object.param2))
                    throw TypeError(".PB_CSArenaReq.param2: array expected");
                message.param2 = [];
                for (var i = 0; i < object.param2.length; ++i)
                    message.param2[i] = object.param2[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSArenaReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSArenaReq
         * @static
         * @param {PB_CSArenaReq} message PB_CSArenaReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSArenaReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.param1 = [];
                object.param2 = [];
            }
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.param1 && message.param1.length) {
                object.param1 = [];
                for (var j = 0; j < message.param1.length; ++j)
                    object.param1[j] = message.param1[j];
            }
            if (message.param2 && message.param2.length) {
                object.param2 = [];
                for (var j = 0; j < message.param2.length; ++j)
                    object.param2[j] = message.param2[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSArenaReq to JSON.
         * @function toJSON
         * @memberof PB_CSArenaReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSArenaReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSArenaReq;
    })();
    
    $root.PB_SCArenaInfo = (function() {
    
        /**
         * Properties of a PB_SCArenaInfo.
         * @exports IPB_SCArenaInfo
         * @interface IPB_SCArenaInfo
         * @property {Array.<number>|null} [heroId] PB_SCArenaInfo heroId
         * @property {Array.<number>|null} [heroLevel] PB_SCArenaInfo heroLevel
         * @property {Array.<number>|null} [buffList] PB_SCArenaInfo buffList
         * @property {number|null} [rank] PB_SCArenaInfo rank
         * @property {number|null} [rankOrder] PB_SCArenaInfo rankOrder
         * @property {number|null} [score] PB_SCArenaInfo score
         * @property {number|null} [skinSeq] PB_SCArenaInfo skinSeq
         * @property {number|null} [fightItemNum] PB_SCArenaInfo fightItemNum
         * @property {number|null} [heroDamage] PB_SCArenaInfo heroDamage
         * @property {Array.<boolean>|null} [rankRewardFetch] PB_SCArenaInfo rankRewardFetch
         */
    
        /**
         * Constructs a new PB_SCArenaInfo.
         * @exports PB_SCArenaInfo
         * @classdesc Represents a PB_SCArenaInfo.
         * @implements IPB_SCArenaInfo
         * @constructor
         * @param {IPB_SCArenaInfo=} [properties] Properties to set
         */
        function PB_SCArenaInfo(properties) {
            this.heroId = [];
            this.heroLevel = [];
            this.buffList = [];
            this.rankRewardFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaInfo heroId.
         * @member {Array.<number>} heroId
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.heroId = $util.emptyArray;
    
        /**
         * PB_SCArenaInfo heroLevel.
         * @member {Array.<number>} heroLevel
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.heroLevel = $util.emptyArray;
    
        /**
         * PB_SCArenaInfo buffList.
         * @member {Array.<number>} buffList
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.buffList = $util.emptyArray;
    
        /**
         * PB_SCArenaInfo rank.
         * @member {number} rank
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.rank = 0;
    
        /**
         * PB_SCArenaInfo rankOrder.
         * @member {number} rankOrder
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.rankOrder = 0;
    
        /**
         * PB_SCArenaInfo score.
         * @member {number} score
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.score = 0;
    
        /**
         * PB_SCArenaInfo skinSeq.
         * @member {number} skinSeq
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.skinSeq = 0;
    
        /**
         * PB_SCArenaInfo fightItemNum.
         * @member {number} fightItemNum
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.fightItemNum = 0;
    
        /**
         * PB_SCArenaInfo heroDamage.
         * @member {number} heroDamage
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.heroDamage = 0;
    
        /**
         * PB_SCArenaInfo rankRewardFetch.
         * @member {Array.<boolean>} rankRewardFetch
         * @memberof PB_SCArenaInfo
         * @instance
         */
        PB_SCArenaInfo.prototype.rankRewardFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCArenaInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaInfo
         * @static
         * @param {IPB_SCArenaInfo=} [properties] Properties to set
         * @returns {PB_SCArenaInfo} PB_SCArenaInfo instance
         */
        PB_SCArenaInfo.create = function create(properties) {
            return new PB_SCArenaInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaInfo message. Does not implicitly {@link PB_SCArenaInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaInfo
         * @static
         * @param {IPB_SCArenaInfo} message PB_SCArenaInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && message.heroId.length)
                for (var i = 0; i < message.heroId.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.heroId[i]);
            if (message.heroLevel != null && message.heroLevel.length)
                for (var i = 0; i < message.heroLevel.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroLevel[i]);
            if (message.buffList != null && message.buffList.length)
                for (var i = 0; i < message.buffList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.buffList[i]);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rank);
            if (message.rankOrder != null && Object.hasOwnProperty.call(message, "rankOrder"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rankOrder);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.score);
            if (message.skinSeq != null && Object.hasOwnProperty.call(message, "skinSeq"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.skinSeq);
            if (message.fightItemNum != null && Object.hasOwnProperty.call(message, "fightItemNum"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.fightItemNum);
            if (message.heroDamage != null && Object.hasOwnProperty.call(message, "heroDamage"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.heroDamage);
            if (message.rankRewardFetch != null && message.rankRewardFetch.length)
                for (var i = 0; i < message.rankRewardFetch.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.rankRewardFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaInfo message, length delimited. Does not implicitly {@link PB_SCArenaInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaInfo
         * @static
         * @param {IPB_SCArenaInfo} message PB_SCArenaInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaInfo} PB_SCArenaInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.heroId && message.heroId.length))
                        message.heroId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.heroId.push(reader.int32());
                    } else
                        message.heroId.push(reader.int32());
                    break;
                case 2:
                    if (!(message.heroLevel && message.heroLevel.length))
                        message.heroLevel = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.heroLevel.push(reader.int32());
                    } else
                        message.heroLevel.push(reader.int32());
                    break;
                case 3:
                    if (!(message.buffList && message.buffList.length))
                        message.buffList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.buffList.push(reader.int32());
                    } else
                        message.buffList.push(reader.int32());
                    break;
                case 4:
                    message.rank = reader.int32();
                    break;
                case 5:
                    message.rankOrder = reader.int32();
                    break;
                case 6:
                    message.score = reader.int32();
                    break;
                case 7:
                    message.skinSeq = reader.int32();
                    break;
                case 8:
                    message.fightItemNum = reader.int32();
                    break;
                case 9:
                    message.heroDamage = reader.int32();
                    break;
                case 10:
                    if (!(message.rankRewardFetch && message.rankRewardFetch.length))
                        message.rankRewardFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rankRewardFetch.push(reader.bool());
                    } else
                        message.rankRewardFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaInfo} PB_SCArenaInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaInfo message.
         * @function verify
         * @memberof PB_SCArenaInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId")) {
                if (!Array.isArray(message.heroId))
                    return "heroId: array expected";
                for (var i = 0; i < message.heroId.length; ++i)
                    if (!$util.isInteger(message.heroId[i]))
                        return "heroId: integer[] expected";
            }
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel")) {
                if (!Array.isArray(message.heroLevel))
                    return "heroLevel: array expected";
                for (var i = 0; i < message.heroLevel.length; ++i)
                    if (!$util.isInteger(message.heroLevel[i]))
                        return "heroLevel: integer[] expected";
            }
            if (message.buffList != null && message.hasOwnProperty("buffList")) {
                if (!Array.isArray(message.buffList))
                    return "buffList: array expected";
                for (var i = 0; i < message.buffList.length; ++i)
                    if (!$util.isInteger(message.buffList[i]))
                        return "buffList: integer[] expected";
            }
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.rankOrder != null && message.hasOwnProperty("rankOrder"))
                if (!$util.isInteger(message.rankOrder))
                    return "rankOrder: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.skinSeq != null && message.hasOwnProperty("skinSeq"))
                if (!$util.isInteger(message.skinSeq))
                    return "skinSeq: integer expected";
            if (message.fightItemNum != null && message.hasOwnProperty("fightItemNum"))
                if (!$util.isInteger(message.fightItemNum))
                    return "fightItemNum: integer expected";
            if (message.heroDamage != null && message.hasOwnProperty("heroDamage"))
                if (!$util.isInteger(message.heroDamage))
                    return "heroDamage: integer expected";
            if (message.rankRewardFetch != null && message.hasOwnProperty("rankRewardFetch")) {
                if (!Array.isArray(message.rankRewardFetch))
                    return "rankRewardFetch: array expected";
                for (var i = 0; i < message.rankRewardFetch.length; ++i)
                    if (typeof message.rankRewardFetch[i] !== "boolean")
                        return "rankRewardFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCArenaInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaInfo} PB_SCArenaInfo
         */
        PB_SCArenaInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaInfo)
                return object;
            var message = new $root.PB_SCArenaInfo();
            if (object.heroId) {
                if (!Array.isArray(object.heroId))
                    throw TypeError(".PB_SCArenaInfo.heroId: array expected");
                message.heroId = [];
                for (var i = 0; i < object.heroId.length; ++i)
                    message.heroId[i] = object.heroId[i] | 0;
            }
            if (object.heroLevel) {
                if (!Array.isArray(object.heroLevel))
                    throw TypeError(".PB_SCArenaInfo.heroLevel: array expected");
                message.heroLevel = [];
                for (var i = 0; i < object.heroLevel.length; ++i)
                    message.heroLevel[i] = object.heroLevel[i] | 0;
            }
            if (object.buffList) {
                if (!Array.isArray(object.buffList))
                    throw TypeError(".PB_SCArenaInfo.buffList: array expected");
                message.buffList = [];
                for (var i = 0; i < object.buffList.length; ++i)
                    message.buffList[i] = object.buffList[i] | 0;
            }
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.rankOrder != null)
                message.rankOrder = object.rankOrder | 0;
            if (object.score != null)
                message.score = object.score | 0;
            if (object.skinSeq != null)
                message.skinSeq = object.skinSeq | 0;
            if (object.fightItemNum != null)
                message.fightItemNum = object.fightItemNum | 0;
            if (object.heroDamage != null)
                message.heroDamage = object.heroDamage | 0;
            if (object.rankRewardFetch) {
                if (!Array.isArray(object.rankRewardFetch))
                    throw TypeError(".PB_SCArenaInfo.rankRewardFetch: array expected");
                message.rankRewardFetch = [];
                for (var i = 0; i < object.rankRewardFetch.length; ++i)
                    message.rankRewardFetch[i] = Boolean(object.rankRewardFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaInfo
         * @static
         * @param {PB_SCArenaInfo} message PB_SCArenaInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.heroId = [];
                object.heroLevel = [];
                object.buffList = [];
                object.rankRewardFetch = [];
            }
            if (options.defaults) {
                object.rank = 0;
                object.rankOrder = 0;
                object.score = 0;
                object.skinSeq = 0;
                object.fightItemNum = 0;
                object.heroDamage = 0;
            }
            if (message.heroId && message.heroId.length) {
                object.heroId = [];
                for (var j = 0; j < message.heroId.length; ++j)
                    object.heroId[j] = message.heroId[j];
            }
            if (message.heroLevel && message.heroLevel.length) {
                object.heroLevel = [];
                for (var j = 0; j < message.heroLevel.length; ++j)
                    object.heroLevel[j] = message.heroLevel[j];
            }
            if (message.buffList && message.buffList.length) {
                object.buffList = [];
                for (var j = 0; j < message.buffList.length; ++j)
                    object.buffList[j] = message.buffList[j];
            }
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.rankOrder != null && message.hasOwnProperty("rankOrder"))
                object.rankOrder = message.rankOrder;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.skinSeq != null && message.hasOwnProperty("skinSeq"))
                object.skinSeq = message.skinSeq;
            if (message.fightItemNum != null && message.hasOwnProperty("fightItemNum"))
                object.fightItemNum = message.fightItemNum;
            if (message.heroDamage != null && message.hasOwnProperty("heroDamage"))
                object.heroDamage = message.heroDamage;
            if (message.rankRewardFetch && message.rankRewardFetch.length) {
                object.rankRewardFetch = [];
                for (var j = 0; j < message.rankRewardFetch.length; ++j)
                    object.rankRewardFetch[j] = message.rankRewardFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCArenaInfo to JSON.
         * @function toJSON
         * @memberof PB_SCArenaInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaInfo;
    })();
    
    $root.PB_SCArenaHeroInfo = (function() {
    
        /**
         * Properties of a PB_SCArenaHeroInfo.
         * @exports IPB_SCArenaHeroInfo
         * @interface IPB_SCArenaHeroInfo
         * @property {number|null} [heroId] PB_SCArenaHeroInfo heroId
         * @property {number|null} [heroLevel] PB_SCArenaHeroInfo heroLevel
         * @property {Array.<number>|null} [geneId] PB_SCArenaHeroInfo geneId
         */
    
        /**
         * Constructs a new PB_SCArenaHeroInfo.
         * @exports PB_SCArenaHeroInfo
         * @classdesc Represents a PB_SCArenaHeroInfo.
         * @implements IPB_SCArenaHeroInfo
         * @constructor
         * @param {IPB_SCArenaHeroInfo=} [properties] Properties to set
         */
        function PB_SCArenaHeroInfo(properties) {
            this.geneId = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaHeroInfo heroId.
         * @member {number} heroId
         * @memberof PB_SCArenaHeroInfo
         * @instance
         */
        PB_SCArenaHeroInfo.prototype.heroId = 0;
    
        /**
         * PB_SCArenaHeroInfo heroLevel.
         * @member {number} heroLevel
         * @memberof PB_SCArenaHeroInfo
         * @instance
         */
        PB_SCArenaHeroInfo.prototype.heroLevel = 0;
    
        /**
         * PB_SCArenaHeroInfo geneId.
         * @member {Array.<number>} geneId
         * @memberof PB_SCArenaHeroInfo
         * @instance
         */
        PB_SCArenaHeroInfo.prototype.geneId = $util.emptyArray;
    
        /**
         * Creates a new PB_SCArenaHeroInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaHeroInfo
         * @static
         * @param {IPB_SCArenaHeroInfo=} [properties] Properties to set
         * @returns {PB_SCArenaHeroInfo} PB_SCArenaHeroInfo instance
         */
        PB_SCArenaHeroInfo.create = function create(properties) {
            return new PB_SCArenaHeroInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaHeroInfo message. Does not implicitly {@link PB_SCArenaHeroInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaHeroInfo
         * @static
         * @param {IPB_SCArenaHeroInfo} message PB_SCArenaHeroInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaHeroInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.heroId);
            if (message.heroLevel != null && Object.hasOwnProperty.call(message, "heroLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroLevel);
            if (message.geneId != null && message.geneId.length)
                for (var i = 0; i < message.geneId.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.geneId[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaHeroInfo message, length delimited. Does not implicitly {@link PB_SCArenaHeroInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaHeroInfo
         * @static
         * @param {IPB_SCArenaHeroInfo} message PB_SCArenaHeroInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaHeroInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaHeroInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaHeroInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaHeroInfo} PB_SCArenaHeroInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaHeroInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaHeroInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroId = reader.int32();
                    break;
                case 2:
                    message.heroLevel = reader.int32();
                    break;
                case 3:
                    if (!(message.geneId && message.geneId.length))
                        message.geneId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.geneId.push(reader.int32());
                    } else
                        message.geneId.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaHeroInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaHeroInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaHeroInfo} PB_SCArenaHeroInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaHeroInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaHeroInfo message.
         * @function verify
         * @memberof PB_SCArenaHeroInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaHeroInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                if (!$util.isInteger(message.heroLevel))
                    return "heroLevel: integer expected";
            if (message.geneId != null && message.hasOwnProperty("geneId")) {
                if (!Array.isArray(message.geneId))
                    return "geneId: array expected";
                for (var i = 0; i < message.geneId.length; ++i)
                    if (!$util.isInteger(message.geneId[i]))
                        return "geneId: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCArenaHeroInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaHeroInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaHeroInfo} PB_SCArenaHeroInfo
         */
        PB_SCArenaHeroInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaHeroInfo)
                return object;
            var message = new $root.PB_SCArenaHeroInfo();
            if (object.heroId != null)
                message.heroId = object.heroId | 0;
            if (object.heroLevel != null)
                message.heroLevel = object.heroLevel | 0;
            if (object.geneId) {
                if (!Array.isArray(object.geneId))
                    throw TypeError(".PB_SCArenaHeroInfo.geneId: array expected");
                message.geneId = [];
                for (var i = 0; i < object.geneId.length; ++i)
                    message.geneId[i] = object.geneId[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaHeroInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaHeroInfo
         * @static
         * @param {PB_SCArenaHeroInfo} message PB_SCArenaHeroInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaHeroInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.geneId = [];
            if (options.defaults) {
                object.heroId = 0;
                object.heroLevel = 0;
            }
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                object.heroLevel = message.heroLevel;
            if (message.geneId && message.geneId.length) {
                object.geneId = [];
                for (var j = 0; j < message.geneId.length; ++j)
                    object.geneId[j] = message.geneId[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCArenaHeroInfo to JSON.
         * @function toJSON
         * @memberof PB_SCArenaHeroInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaHeroInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaHeroInfo;
    })();
    
    $root.PB_SCArenaTalentLevelInfo = (function() {
    
        /**
         * Properties of a PB_SCArenaTalentLevelInfo.
         * @exports IPB_SCArenaTalentLevelInfo
         * @interface IPB_SCArenaTalentLevelInfo
         * @property {number|null} [talentId] PB_SCArenaTalentLevelInfo talentId
         * @property {number|null} [talentLevel] PB_SCArenaTalentLevelInfo talentLevel
         */
    
        /**
         * Constructs a new PB_SCArenaTalentLevelInfo.
         * @exports PB_SCArenaTalentLevelInfo
         * @classdesc Represents a PB_SCArenaTalentLevelInfo.
         * @implements IPB_SCArenaTalentLevelInfo
         * @constructor
         * @param {IPB_SCArenaTalentLevelInfo=} [properties] Properties to set
         */
        function PB_SCArenaTalentLevelInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaTalentLevelInfo talentId.
         * @member {number} talentId
         * @memberof PB_SCArenaTalentLevelInfo
         * @instance
         */
        PB_SCArenaTalentLevelInfo.prototype.talentId = 0;
    
        /**
         * PB_SCArenaTalentLevelInfo talentLevel.
         * @member {number} talentLevel
         * @memberof PB_SCArenaTalentLevelInfo
         * @instance
         */
        PB_SCArenaTalentLevelInfo.prototype.talentLevel = 0;
    
        /**
         * Creates a new PB_SCArenaTalentLevelInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaTalentLevelInfo
         * @static
         * @param {IPB_SCArenaTalentLevelInfo=} [properties] Properties to set
         * @returns {PB_SCArenaTalentLevelInfo} PB_SCArenaTalentLevelInfo instance
         */
        PB_SCArenaTalentLevelInfo.create = function create(properties) {
            return new PB_SCArenaTalentLevelInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaTalentLevelInfo message. Does not implicitly {@link PB_SCArenaTalentLevelInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaTalentLevelInfo
         * @static
         * @param {IPB_SCArenaTalentLevelInfo} message PB_SCArenaTalentLevelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaTalentLevelInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.talentId != null && Object.hasOwnProperty.call(message, "talentId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.talentId);
            if (message.talentLevel != null && Object.hasOwnProperty.call(message, "talentLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.talentLevel);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaTalentLevelInfo message, length delimited. Does not implicitly {@link PB_SCArenaTalentLevelInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaTalentLevelInfo
         * @static
         * @param {IPB_SCArenaTalentLevelInfo} message PB_SCArenaTalentLevelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaTalentLevelInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaTalentLevelInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaTalentLevelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaTalentLevelInfo} PB_SCArenaTalentLevelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaTalentLevelInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaTalentLevelInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.talentId = reader.int32();
                    break;
                case 2:
                    message.talentLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaTalentLevelInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaTalentLevelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaTalentLevelInfo} PB_SCArenaTalentLevelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaTalentLevelInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaTalentLevelInfo message.
         * @function verify
         * @memberof PB_SCArenaTalentLevelInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaTalentLevelInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.talentId != null && message.hasOwnProperty("talentId"))
                if (!$util.isInteger(message.talentId))
                    return "talentId: integer expected";
            if (message.talentLevel != null && message.hasOwnProperty("talentLevel"))
                if (!$util.isInteger(message.talentLevel))
                    return "talentLevel: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCArenaTalentLevelInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaTalentLevelInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaTalentLevelInfo} PB_SCArenaTalentLevelInfo
         */
        PB_SCArenaTalentLevelInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaTalentLevelInfo)
                return object;
            var message = new $root.PB_SCArenaTalentLevelInfo();
            if (object.talentId != null)
                message.talentId = object.talentId | 0;
            if (object.talentLevel != null)
                message.talentLevel = object.talentLevel | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaTalentLevelInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaTalentLevelInfo
         * @static
         * @param {PB_SCArenaTalentLevelInfo} message PB_SCArenaTalentLevelInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaTalentLevelInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.talentId = 0;
                object.talentLevel = 0;
            }
            if (message.talentId != null && message.hasOwnProperty("talentId"))
                object.talentId = message.talentId;
            if (message.talentLevel != null && message.hasOwnProperty("talentLevel"))
                object.talentLevel = message.talentLevel;
            return object;
        };
    
        /**
         * Converts this PB_SCArenaTalentLevelInfo to JSON.
         * @function toJSON
         * @memberof PB_SCArenaTalentLevelInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaTalentLevelInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaTalentLevelInfo;
    })();
    
    $root.PB_SCArenaTargetInfo = (function() {
    
        /**
         * Properties of a PB_SCArenaTargetInfo.
         * @exports IPB_SCArenaTargetInfo
         * @interface IPB_SCArenaTargetInfo
         * @property {number|null} [heroDamage] PB_SCArenaTargetInfo heroDamage
         * @property {number|null} [skinSeq] PB_SCArenaTargetInfo skinSeq
         * @property {Array.<number>|null} [buffList] PB_SCArenaTargetInfo buffList
         * @property {number|null} [rank] PB_SCArenaTargetInfo rank
         * @property {number|null} [rankOrder] PB_SCArenaTargetInfo rankOrder
         * @property {IPB_RoleInfo|null} [roleInfo] PB_SCArenaTargetInfo roleInfo
         * @property {Array.<IPB_SCArenaHeroInfo>|null} [heroList] PB_SCArenaTargetInfo heroList
         * @property {Array.<IPB_SCArenaTalentLevelInfo>|null} [talentList] PB_SCArenaTargetInfo talentList
         */
    
        /**
         * Constructs a new PB_SCArenaTargetInfo.
         * @exports PB_SCArenaTargetInfo
         * @classdesc Represents a PB_SCArenaTargetInfo.
         * @implements IPB_SCArenaTargetInfo
         * @constructor
         * @param {IPB_SCArenaTargetInfo=} [properties] Properties to set
         */
        function PB_SCArenaTargetInfo(properties) {
            this.buffList = [];
            this.heroList = [];
            this.talentList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaTargetInfo heroDamage.
         * @member {number} heroDamage
         * @memberof PB_SCArenaTargetInfo
         * @instance
         */
        PB_SCArenaTargetInfo.prototype.heroDamage = 0;
    
        /**
         * PB_SCArenaTargetInfo skinSeq.
         * @member {number} skinSeq
         * @memberof PB_SCArenaTargetInfo
         * @instance
         */
        PB_SCArenaTargetInfo.prototype.skinSeq = 0;
    
        /**
         * PB_SCArenaTargetInfo buffList.
         * @member {Array.<number>} buffList
         * @memberof PB_SCArenaTargetInfo
         * @instance
         */
        PB_SCArenaTargetInfo.prototype.buffList = $util.emptyArray;
    
        /**
         * PB_SCArenaTargetInfo rank.
         * @member {number} rank
         * @memberof PB_SCArenaTargetInfo
         * @instance
         */
        PB_SCArenaTargetInfo.prototype.rank = 0;
    
        /**
         * PB_SCArenaTargetInfo rankOrder.
         * @member {number} rankOrder
         * @memberof PB_SCArenaTargetInfo
         * @instance
         */
        PB_SCArenaTargetInfo.prototype.rankOrder = 0;
    
        /**
         * PB_SCArenaTargetInfo roleInfo.
         * @member {IPB_RoleInfo|null|undefined} roleInfo
         * @memberof PB_SCArenaTargetInfo
         * @instance
         */
        PB_SCArenaTargetInfo.prototype.roleInfo = null;
    
        /**
         * PB_SCArenaTargetInfo heroList.
         * @member {Array.<IPB_SCArenaHeroInfo>} heroList
         * @memberof PB_SCArenaTargetInfo
         * @instance
         */
        PB_SCArenaTargetInfo.prototype.heroList = $util.emptyArray;
    
        /**
         * PB_SCArenaTargetInfo talentList.
         * @member {Array.<IPB_SCArenaTalentLevelInfo>} talentList
         * @memberof PB_SCArenaTargetInfo
         * @instance
         */
        PB_SCArenaTargetInfo.prototype.talentList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCArenaTargetInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaTargetInfo
         * @static
         * @param {IPB_SCArenaTargetInfo=} [properties] Properties to set
         * @returns {PB_SCArenaTargetInfo} PB_SCArenaTargetInfo instance
         */
        PB_SCArenaTargetInfo.create = function create(properties) {
            return new PB_SCArenaTargetInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaTargetInfo message. Does not implicitly {@link PB_SCArenaTargetInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaTargetInfo
         * @static
         * @param {IPB_SCArenaTargetInfo} message PB_SCArenaTargetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaTargetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroDamage != null && Object.hasOwnProperty.call(message, "heroDamage"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.heroDamage);
            if (message.skinSeq != null && Object.hasOwnProperty.call(message, "skinSeq"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.skinSeq);
            if (message.buffList != null && message.buffList.length)
                for (var i = 0; i < message.buffList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.buffList[i]);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rank);
            if (message.rankOrder != null && Object.hasOwnProperty.call(message, "rankOrder"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rankOrder);
            if (message.roleInfo != null && Object.hasOwnProperty.call(message, "roleInfo"))
                $root.PB_RoleInfo.encode(message.roleInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.heroList != null && message.heroList.length)
                for (var i = 0; i < message.heroList.length; ++i)
                    $root.PB_SCArenaHeroInfo.encode(message.heroList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.talentList != null && message.talentList.length)
                for (var i = 0; i < message.talentList.length; ++i)
                    $root.PB_SCArenaTalentLevelInfo.encode(message.talentList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaTargetInfo message, length delimited. Does not implicitly {@link PB_SCArenaTargetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaTargetInfo
         * @static
         * @param {IPB_SCArenaTargetInfo} message PB_SCArenaTargetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaTargetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaTargetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaTargetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaTargetInfo} PB_SCArenaTargetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaTargetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaTargetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroDamage = reader.int32();
                    break;
                case 2:
                    message.skinSeq = reader.int32();
                    break;
                case 3:
                    if (!(message.buffList && message.buffList.length))
                        message.buffList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.buffList.push(reader.int32());
                    } else
                        message.buffList.push(reader.int32());
                    break;
                case 4:
                    message.rank = reader.int32();
                    break;
                case 5:
                    message.rankOrder = reader.int32();
                    break;
                case 6:
                    message.roleInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.heroList && message.heroList.length))
                        message.heroList = [];
                    message.heroList.push($root.PB_SCArenaHeroInfo.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.talentList && message.talentList.length))
                        message.talentList = [];
                    message.talentList.push($root.PB_SCArenaTalentLevelInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaTargetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaTargetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaTargetInfo} PB_SCArenaTargetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaTargetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaTargetInfo message.
         * @function verify
         * @memberof PB_SCArenaTargetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaTargetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroDamage != null && message.hasOwnProperty("heroDamage"))
                if (!$util.isInteger(message.heroDamage))
                    return "heroDamage: integer expected";
            if (message.skinSeq != null && message.hasOwnProperty("skinSeq"))
                if (!$util.isInteger(message.skinSeq))
                    return "skinSeq: integer expected";
            if (message.buffList != null && message.hasOwnProperty("buffList")) {
                if (!Array.isArray(message.buffList))
                    return "buffList: array expected";
                for (var i = 0; i < message.buffList.length; ++i)
                    if (!$util.isInteger(message.buffList[i]))
                        return "buffList: integer[] expected";
            }
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.rankOrder != null && message.hasOwnProperty("rankOrder"))
                if (!$util.isInteger(message.rankOrder))
                    return "rankOrder: integer expected";
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleInfo);
                if (error)
                    return "roleInfo." + error;
            }
            if (message.heroList != null && message.hasOwnProperty("heroList")) {
                if (!Array.isArray(message.heroList))
                    return "heroList: array expected";
                for (var i = 0; i < message.heroList.length; ++i) {
                    var error = $root.PB_SCArenaHeroInfo.verify(message.heroList[i]);
                    if (error)
                        return "heroList." + error;
                }
            }
            if (message.talentList != null && message.hasOwnProperty("talentList")) {
                if (!Array.isArray(message.talentList))
                    return "talentList: array expected";
                for (var i = 0; i < message.talentList.length; ++i) {
                    var error = $root.PB_SCArenaTalentLevelInfo.verify(message.talentList[i]);
                    if (error)
                        return "talentList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCArenaTargetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaTargetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaTargetInfo} PB_SCArenaTargetInfo
         */
        PB_SCArenaTargetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaTargetInfo)
                return object;
            var message = new $root.PB_SCArenaTargetInfo();
            if (object.heroDamage != null)
                message.heroDamage = object.heroDamage | 0;
            if (object.skinSeq != null)
                message.skinSeq = object.skinSeq | 0;
            if (object.buffList) {
                if (!Array.isArray(object.buffList))
                    throw TypeError(".PB_SCArenaTargetInfo.buffList: array expected");
                message.buffList = [];
                for (var i = 0; i < object.buffList.length; ++i)
                    message.buffList[i] = object.buffList[i] | 0;
            }
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.rankOrder != null)
                message.rankOrder = object.rankOrder | 0;
            if (object.roleInfo != null) {
                if (typeof object.roleInfo !== "object")
                    throw TypeError(".PB_SCArenaTargetInfo.roleInfo: object expected");
                message.roleInfo = $root.PB_RoleInfo.fromObject(object.roleInfo);
            }
            if (object.heroList) {
                if (!Array.isArray(object.heroList))
                    throw TypeError(".PB_SCArenaTargetInfo.heroList: array expected");
                message.heroList = [];
                for (var i = 0; i < object.heroList.length; ++i) {
                    if (typeof object.heroList[i] !== "object")
                        throw TypeError(".PB_SCArenaTargetInfo.heroList: object expected");
                    message.heroList[i] = $root.PB_SCArenaHeroInfo.fromObject(object.heroList[i]);
                }
            }
            if (object.talentList) {
                if (!Array.isArray(object.talentList))
                    throw TypeError(".PB_SCArenaTargetInfo.talentList: array expected");
                message.talentList = [];
                for (var i = 0; i < object.talentList.length; ++i) {
                    if (typeof object.talentList[i] !== "object")
                        throw TypeError(".PB_SCArenaTargetInfo.talentList: object expected");
                    message.talentList[i] = $root.PB_SCArenaTalentLevelInfo.fromObject(object.talentList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaTargetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaTargetInfo
         * @static
         * @param {PB_SCArenaTargetInfo} message PB_SCArenaTargetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaTargetInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.buffList = [];
                object.heroList = [];
                object.talentList = [];
            }
            if (options.defaults) {
                object.heroDamage = 0;
                object.skinSeq = 0;
                object.rank = 0;
                object.rankOrder = 0;
                object.roleInfo = null;
            }
            if (message.heroDamage != null && message.hasOwnProperty("heroDamage"))
                object.heroDamage = message.heroDamage;
            if (message.skinSeq != null && message.hasOwnProperty("skinSeq"))
                object.skinSeq = message.skinSeq;
            if (message.buffList && message.buffList.length) {
                object.buffList = [];
                for (var j = 0; j < message.buffList.length; ++j)
                    object.buffList[j] = message.buffList[j];
            }
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.rankOrder != null && message.hasOwnProperty("rankOrder"))
                object.rankOrder = message.rankOrder;
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo"))
                object.roleInfo = $root.PB_RoleInfo.toObject(message.roleInfo, options);
            if (message.heroList && message.heroList.length) {
                object.heroList = [];
                for (var j = 0; j < message.heroList.length; ++j)
                    object.heroList[j] = $root.PB_SCArenaHeroInfo.toObject(message.heroList[j], options);
            }
            if (message.talentList && message.talentList.length) {
                object.talentList = [];
                for (var j = 0; j < message.talentList.length; ++j)
                    object.talentList[j] = $root.PB_SCArenaTalentLevelInfo.toObject(message.talentList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCArenaTargetInfo to JSON.
         * @function toJSON
         * @memberof PB_SCArenaTargetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaTargetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaTargetInfo;
    })();
    
    $root.PB_SCArenaShopInfo = (function() {
    
        /**
         * Properties of a PB_SCArenaShopInfo.
         * @exports IPB_SCArenaShopInfo
         * @interface IPB_SCArenaShopInfo
         * @property {Array.<number>|null} [buyCount] PB_SCArenaShopInfo buyCount
         */
    
        /**
         * Constructs a new PB_SCArenaShopInfo.
         * @exports PB_SCArenaShopInfo
         * @classdesc Represents a PB_SCArenaShopInfo.
         * @implements IPB_SCArenaShopInfo
         * @constructor
         * @param {IPB_SCArenaShopInfo=} [properties] Properties to set
         */
        function PB_SCArenaShopInfo(properties) {
            this.buyCount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaShopInfo buyCount.
         * @member {Array.<number>} buyCount
         * @memberof PB_SCArenaShopInfo
         * @instance
         */
        PB_SCArenaShopInfo.prototype.buyCount = $util.emptyArray;
    
        /**
         * Creates a new PB_SCArenaShopInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaShopInfo
         * @static
         * @param {IPB_SCArenaShopInfo=} [properties] Properties to set
         * @returns {PB_SCArenaShopInfo} PB_SCArenaShopInfo instance
         */
        PB_SCArenaShopInfo.create = function create(properties) {
            return new PB_SCArenaShopInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaShopInfo message. Does not implicitly {@link PB_SCArenaShopInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaShopInfo
         * @static
         * @param {IPB_SCArenaShopInfo} message PB_SCArenaShopInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaShopInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.buyCount != null && message.buyCount.length)
                for (var i = 0; i < message.buyCount.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buyCount[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaShopInfo message, length delimited. Does not implicitly {@link PB_SCArenaShopInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaShopInfo
         * @static
         * @param {IPB_SCArenaShopInfo} message PB_SCArenaShopInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaShopInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaShopInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaShopInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaShopInfo} PB_SCArenaShopInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaShopInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaShopInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.buyCount && message.buyCount.length))
                        message.buyCount = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.buyCount.push(reader.int32());
                    } else
                        message.buyCount.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaShopInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaShopInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaShopInfo} PB_SCArenaShopInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaShopInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaShopInfo message.
         * @function verify
         * @memberof PB_SCArenaShopInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaShopInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.buyCount != null && message.hasOwnProperty("buyCount")) {
                if (!Array.isArray(message.buyCount))
                    return "buyCount: array expected";
                for (var i = 0; i < message.buyCount.length; ++i)
                    if (!$util.isInteger(message.buyCount[i]))
                        return "buyCount: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCArenaShopInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaShopInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaShopInfo} PB_SCArenaShopInfo
         */
        PB_SCArenaShopInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaShopInfo)
                return object;
            var message = new $root.PB_SCArenaShopInfo();
            if (object.buyCount) {
                if (!Array.isArray(object.buyCount))
                    throw TypeError(".PB_SCArenaShopInfo.buyCount: array expected");
                message.buyCount = [];
                for (var i = 0; i < object.buyCount.length; ++i)
                    message.buyCount[i] = object.buyCount[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaShopInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaShopInfo
         * @static
         * @param {PB_SCArenaShopInfo} message PB_SCArenaShopInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaShopInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.buyCount = [];
            if (message.buyCount && message.buyCount.length) {
                object.buyCount = [];
                for (var j = 0; j < message.buyCount.length; ++j)
                    object.buyCount[j] = message.buyCount[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCArenaShopInfo to JSON.
         * @function toJSON
         * @memberof PB_SCArenaShopInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaShopInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaShopInfo;
    })();
    
    $root.PB_SCArenaReportNode = (function() {
    
        /**
         * Properties of a PB_SCArenaReportNode.
         * @exports IPB_SCArenaReportNode
         * @interface IPB_SCArenaReportNode
         * @property {IPB_RoleInfo|null} [roleInfo] PB_SCArenaReportNode roleInfo
         * @property {boolean|null} [isAttack] PB_SCArenaReportNode isAttack
         * @property {boolean|null} [isWin] PB_SCArenaReportNode isWin
         * @property {number|Long|null} [time] PB_SCArenaReportNode time
         * @property {number|null} [rank] PB_SCArenaReportNode rank
         * @property {number|null} [rankOrder] PB_SCArenaReportNode rankOrder
         */
    
        /**
         * Constructs a new PB_SCArenaReportNode.
         * @exports PB_SCArenaReportNode
         * @classdesc Represents a PB_SCArenaReportNode.
         * @implements IPB_SCArenaReportNode
         * @constructor
         * @param {IPB_SCArenaReportNode=} [properties] Properties to set
         */
        function PB_SCArenaReportNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaReportNode roleInfo.
         * @member {IPB_RoleInfo|null|undefined} roleInfo
         * @memberof PB_SCArenaReportNode
         * @instance
         */
        PB_SCArenaReportNode.prototype.roleInfo = null;
    
        /**
         * PB_SCArenaReportNode isAttack.
         * @member {boolean} isAttack
         * @memberof PB_SCArenaReportNode
         * @instance
         */
        PB_SCArenaReportNode.prototype.isAttack = false;
    
        /**
         * PB_SCArenaReportNode isWin.
         * @member {boolean} isWin
         * @memberof PB_SCArenaReportNode
         * @instance
         */
        PB_SCArenaReportNode.prototype.isWin = false;
    
        /**
         * PB_SCArenaReportNode time.
         * @member {number|Long} time
         * @memberof PB_SCArenaReportNode
         * @instance
         */
        PB_SCArenaReportNode.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCArenaReportNode rank.
         * @member {number} rank
         * @memberof PB_SCArenaReportNode
         * @instance
         */
        PB_SCArenaReportNode.prototype.rank = 0;
    
        /**
         * PB_SCArenaReportNode rankOrder.
         * @member {number} rankOrder
         * @memberof PB_SCArenaReportNode
         * @instance
         */
        PB_SCArenaReportNode.prototype.rankOrder = 0;
    
        /**
         * Creates a new PB_SCArenaReportNode instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaReportNode
         * @static
         * @param {IPB_SCArenaReportNode=} [properties] Properties to set
         * @returns {PB_SCArenaReportNode} PB_SCArenaReportNode instance
         */
        PB_SCArenaReportNode.create = function create(properties) {
            return new PB_SCArenaReportNode(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaReportNode message. Does not implicitly {@link PB_SCArenaReportNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaReportNode
         * @static
         * @param {IPB_SCArenaReportNode} message PB_SCArenaReportNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaReportNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleInfo != null && Object.hasOwnProperty.call(message, "roleInfo"))
                $root.PB_RoleInfo.encode(message.roleInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.isAttack != null && Object.hasOwnProperty.call(message, "isAttack"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isAttack);
            if (message.isWin != null && Object.hasOwnProperty.call(message, "isWin"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isWin);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.time);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rank);
            if (message.rankOrder != null && Object.hasOwnProperty.call(message, "rankOrder"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.rankOrder);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaReportNode message, length delimited. Does not implicitly {@link PB_SCArenaReportNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaReportNode
         * @static
         * @param {IPB_SCArenaReportNode} message PB_SCArenaReportNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaReportNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaReportNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaReportNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaReportNode} PB_SCArenaReportNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaReportNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaReportNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.isAttack = reader.bool();
                    break;
                case 3:
                    message.isWin = reader.bool();
                    break;
                case 4:
                    message.time = reader.int64();
                    break;
                case 5:
                    message.rank = reader.int32();
                    break;
                case 6:
                    message.rankOrder = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaReportNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaReportNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaReportNode} PB_SCArenaReportNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaReportNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaReportNode message.
         * @function verify
         * @memberof PB_SCArenaReportNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaReportNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleInfo);
                if (error)
                    return "roleInfo." + error;
            }
            if (message.isAttack != null && message.hasOwnProperty("isAttack"))
                if (typeof message.isAttack !== "boolean")
                    return "isAttack: boolean expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.rankOrder != null && message.hasOwnProperty("rankOrder"))
                if (!$util.isInteger(message.rankOrder))
                    return "rankOrder: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCArenaReportNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaReportNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaReportNode} PB_SCArenaReportNode
         */
        PB_SCArenaReportNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaReportNode)
                return object;
            var message = new $root.PB_SCArenaReportNode();
            if (object.roleInfo != null) {
                if (typeof object.roleInfo !== "object")
                    throw TypeError(".PB_SCArenaReportNode.roleInfo: object expected");
                message.roleInfo = $root.PB_RoleInfo.fromObject(object.roleInfo);
            }
            if (object.isAttack != null)
                message.isAttack = Boolean(object.isAttack);
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.rankOrder != null)
                message.rankOrder = object.rankOrder | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaReportNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaReportNode
         * @static
         * @param {PB_SCArenaReportNode} message PB_SCArenaReportNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaReportNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roleInfo = null;
                object.isAttack = false;
                object.isWin = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.rank = 0;
                object.rankOrder = 0;
            }
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo"))
                object.roleInfo = $root.PB_RoleInfo.toObject(message.roleInfo, options);
            if (message.isAttack != null && message.hasOwnProperty("isAttack"))
                object.isAttack = message.isAttack;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.rankOrder != null && message.hasOwnProperty("rankOrder"))
                object.rankOrder = message.rankOrder;
            return object;
        };
    
        /**
         * Converts this PB_SCArenaReportNode to JSON.
         * @function toJSON
         * @memberof PB_SCArenaReportNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaReportNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaReportNode;
    })();
    
    $root.PB_SCArenaReportInfo = (function() {
    
        /**
         * Properties of a PB_SCArenaReportInfo.
         * @exports IPB_SCArenaReportInfo
         * @interface IPB_SCArenaReportInfo
         * @property {Array.<IPB_SCArenaReportNode>|null} [reportInfo] PB_SCArenaReportInfo reportInfo
         */
    
        /**
         * Constructs a new PB_SCArenaReportInfo.
         * @exports PB_SCArenaReportInfo
         * @classdesc Represents a PB_SCArenaReportInfo.
         * @implements IPB_SCArenaReportInfo
         * @constructor
         * @param {IPB_SCArenaReportInfo=} [properties] Properties to set
         */
        function PB_SCArenaReportInfo(properties) {
            this.reportInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaReportInfo reportInfo.
         * @member {Array.<IPB_SCArenaReportNode>} reportInfo
         * @memberof PB_SCArenaReportInfo
         * @instance
         */
        PB_SCArenaReportInfo.prototype.reportInfo = $util.emptyArray;
    
        /**
         * Creates a new PB_SCArenaReportInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaReportInfo
         * @static
         * @param {IPB_SCArenaReportInfo=} [properties] Properties to set
         * @returns {PB_SCArenaReportInfo} PB_SCArenaReportInfo instance
         */
        PB_SCArenaReportInfo.create = function create(properties) {
            return new PB_SCArenaReportInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaReportInfo message. Does not implicitly {@link PB_SCArenaReportInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaReportInfo
         * @static
         * @param {IPB_SCArenaReportInfo} message PB_SCArenaReportInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaReportInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reportInfo != null && message.reportInfo.length)
                for (var i = 0; i < message.reportInfo.length; ++i)
                    $root.PB_SCArenaReportNode.encode(message.reportInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaReportInfo message, length delimited. Does not implicitly {@link PB_SCArenaReportInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaReportInfo
         * @static
         * @param {IPB_SCArenaReportInfo} message PB_SCArenaReportInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaReportInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaReportInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaReportInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaReportInfo} PB_SCArenaReportInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaReportInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaReportInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.reportInfo && message.reportInfo.length))
                        message.reportInfo = [];
                    message.reportInfo.push($root.PB_SCArenaReportNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaReportInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaReportInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaReportInfo} PB_SCArenaReportInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaReportInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaReportInfo message.
         * @function verify
         * @memberof PB_SCArenaReportInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaReportInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reportInfo != null && message.hasOwnProperty("reportInfo")) {
                if (!Array.isArray(message.reportInfo))
                    return "reportInfo: array expected";
                for (var i = 0; i < message.reportInfo.length; ++i) {
                    var error = $root.PB_SCArenaReportNode.verify(message.reportInfo[i]);
                    if (error)
                        return "reportInfo." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCArenaReportInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaReportInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaReportInfo} PB_SCArenaReportInfo
         */
        PB_SCArenaReportInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaReportInfo)
                return object;
            var message = new $root.PB_SCArenaReportInfo();
            if (object.reportInfo) {
                if (!Array.isArray(object.reportInfo))
                    throw TypeError(".PB_SCArenaReportInfo.reportInfo: array expected");
                message.reportInfo = [];
                for (var i = 0; i < object.reportInfo.length; ++i) {
                    if (typeof object.reportInfo[i] !== "object")
                        throw TypeError(".PB_SCArenaReportInfo.reportInfo: object expected");
                    message.reportInfo[i] = $root.PB_SCArenaReportNode.fromObject(object.reportInfo[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaReportInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaReportInfo
         * @static
         * @param {PB_SCArenaReportInfo} message PB_SCArenaReportInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaReportInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reportInfo = [];
            if (message.reportInfo && message.reportInfo.length) {
                object.reportInfo = [];
                for (var j = 0; j < message.reportInfo.length; ++j)
                    object.reportInfo[j] = $root.PB_SCArenaReportNode.toObject(message.reportInfo[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCArenaReportInfo to JSON.
         * @function toJSON
         * @memberof PB_SCArenaReportInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaReportInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaReportInfo;
    })();
    
    $root.PB_SCArenaMapData = (function() {
    
        /**
         * Properties of a PB_SCArenaMapData.
         * @exports IPB_SCArenaMapData
         * @interface IPB_SCArenaMapData
         * @property {number|null} [seq] PB_SCArenaMapData seq
         * @property {number|Long|null} [endTime] PB_SCArenaMapData endTime
         */
    
        /**
         * Constructs a new PB_SCArenaMapData.
         * @exports PB_SCArenaMapData
         * @classdesc Represents a PB_SCArenaMapData.
         * @implements IPB_SCArenaMapData
         * @constructor
         * @param {IPB_SCArenaMapData=} [properties] Properties to set
         */
        function PB_SCArenaMapData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaMapData seq.
         * @member {number} seq
         * @memberof PB_SCArenaMapData
         * @instance
         */
        PB_SCArenaMapData.prototype.seq = 0;
    
        /**
         * PB_SCArenaMapData endTime.
         * @member {number|Long} endTime
         * @memberof PB_SCArenaMapData
         * @instance
         */
        PB_SCArenaMapData.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCArenaMapData instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaMapData
         * @static
         * @param {IPB_SCArenaMapData=} [properties] Properties to set
         * @returns {PB_SCArenaMapData} PB_SCArenaMapData instance
         */
        PB_SCArenaMapData.create = function create(properties) {
            return new PB_SCArenaMapData(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaMapData message. Does not implicitly {@link PB_SCArenaMapData.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaMapData
         * @static
         * @param {IPB_SCArenaMapData} message PB_SCArenaMapData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaMapData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaMapData message, length delimited. Does not implicitly {@link PB_SCArenaMapData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaMapData
         * @static
         * @param {IPB_SCArenaMapData} message PB_SCArenaMapData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaMapData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaMapData message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaMapData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaMapData} PB_SCArenaMapData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaMapData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaMapData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    message.endTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaMapData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaMapData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaMapData} PB_SCArenaMapData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaMapData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaMapData message.
         * @function verify
         * @memberof PB_SCArenaMapData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaMapData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCArenaMapData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaMapData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaMapData} PB_SCArenaMapData
         */
        PB_SCArenaMapData.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaMapData)
                return object;
            var message = new $root.PB_SCArenaMapData();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaMapData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaMapData
         * @static
         * @param {PB_SCArenaMapData} message PB_SCArenaMapData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaMapData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.seq = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTime = options.longs === String ? "0" : 0;
            }
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (typeof message.endTime === "number")
                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                else
                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
            return object;
        };
    
        /**
         * Converts this PB_SCArenaMapData to JSON.
         * @function toJSON
         * @memberof PB_SCArenaMapData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaMapData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaMapData;
    })();
    
    $root.PB_SCArenaMapInfo = (function() {
    
        /**
         * Properties of a PB_SCArenaMapInfo.
         * @exports IPB_SCArenaMapInfo
         * @interface IPB_SCArenaMapInfo
         * @property {Array.<IPB_SCArenaMapData>|null} [mapList] PB_SCArenaMapInfo mapList
         */
    
        /**
         * Constructs a new PB_SCArenaMapInfo.
         * @exports PB_SCArenaMapInfo
         * @classdesc Represents a PB_SCArenaMapInfo.
         * @implements IPB_SCArenaMapInfo
         * @constructor
         * @param {IPB_SCArenaMapInfo=} [properties] Properties to set
         */
        function PB_SCArenaMapInfo(properties) {
            this.mapList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaMapInfo mapList.
         * @member {Array.<IPB_SCArenaMapData>} mapList
         * @memberof PB_SCArenaMapInfo
         * @instance
         */
        PB_SCArenaMapInfo.prototype.mapList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCArenaMapInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaMapInfo
         * @static
         * @param {IPB_SCArenaMapInfo=} [properties] Properties to set
         * @returns {PB_SCArenaMapInfo} PB_SCArenaMapInfo instance
         */
        PB_SCArenaMapInfo.create = function create(properties) {
            return new PB_SCArenaMapInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaMapInfo message. Does not implicitly {@link PB_SCArenaMapInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaMapInfo
         * @static
         * @param {IPB_SCArenaMapInfo} message PB_SCArenaMapInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaMapInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mapList != null && message.mapList.length)
                for (var i = 0; i < message.mapList.length; ++i)
                    $root.PB_SCArenaMapData.encode(message.mapList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaMapInfo message, length delimited. Does not implicitly {@link PB_SCArenaMapInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaMapInfo
         * @static
         * @param {IPB_SCArenaMapInfo} message PB_SCArenaMapInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaMapInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaMapInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaMapInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaMapInfo} PB_SCArenaMapInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaMapInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaMapInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.mapList && message.mapList.length))
                        message.mapList = [];
                    message.mapList.push($root.PB_SCArenaMapData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaMapInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaMapInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaMapInfo} PB_SCArenaMapInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaMapInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaMapInfo message.
         * @function verify
         * @memberof PB_SCArenaMapInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaMapInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mapList != null && message.hasOwnProperty("mapList")) {
                if (!Array.isArray(message.mapList))
                    return "mapList: array expected";
                for (var i = 0; i < message.mapList.length; ++i) {
                    var error = $root.PB_SCArenaMapData.verify(message.mapList[i]);
                    if (error)
                        return "mapList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCArenaMapInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaMapInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaMapInfo} PB_SCArenaMapInfo
         */
        PB_SCArenaMapInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaMapInfo)
                return object;
            var message = new $root.PB_SCArenaMapInfo();
            if (object.mapList) {
                if (!Array.isArray(object.mapList))
                    throw TypeError(".PB_SCArenaMapInfo.mapList: array expected");
                message.mapList = [];
                for (var i = 0; i < object.mapList.length; ++i) {
                    if (typeof object.mapList[i] !== "object")
                        throw TypeError(".PB_SCArenaMapInfo.mapList: object expected");
                    message.mapList[i] = $root.PB_SCArenaMapData.fromObject(object.mapList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaMapInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaMapInfo
         * @static
         * @param {PB_SCArenaMapInfo} message PB_SCArenaMapInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaMapInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mapList = [];
            if (message.mapList && message.mapList.length) {
                object.mapList = [];
                for (var j = 0; j < message.mapList.length; ++j)
                    object.mapList[j] = $root.PB_SCArenaMapData.toObject(message.mapList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCArenaMapInfo to JSON.
         * @function toJSON
         * @memberof PB_SCArenaMapInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaMapInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaMapInfo;
    })();
    
    $root.PB_SCArenaBuyInfo = (function() {
    
        /**
         * Properties of a PB_SCArenaBuyInfo.
         * @exports IPB_SCArenaBuyInfo
         * @interface IPB_SCArenaBuyInfo
         * @property {number|null} [buyItemCount] PB_SCArenaBuyInfo buyItemCount
         */
    
        /**
         * Constructs a new PB_SCArenaBuyInfo.
         * @exports PB_SCArenaBuyInfo
         * @classdesc Represents a PB_SCArenaBuyInfo.
         * @implements IPB_SCArenaBuyInfo
         * @constructor
         * @param {IPB_SCArenaBuyInfo=} [properties] Properties to set
         */
        function PB_SCArenaBuyInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaBuyInfo buyItemCount.
         * @member {number} buyItemCount
         * @memberof PB_SCArenaBuyInfo
         * @instance
         */
        PB_SCArenaBuyInfo.prototype.buyItemCount = 0;
    
        /**
         * Creates a new PB_SCArenaBuyInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaBuyInfo
         * @static
         * @param {IPB_SCArenaBuyInfo=} [properties] Properties to set
         * @returns {PB_SCArenaBuyInfo} PB_SCArenaBuyInfo instance
         */
        PB_SCArenaBuyInfo.create = function create(properties) {
            return new PB_SCArenaBuyInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaBuyInfo message. Does not implicitly {@link PB_SCArenaBuyInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaBuyInfo
         * @static
         * @param {IPB_SCArenaBuyInfo} message PB_SCArenaBuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaBuyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.buyItemCount != null && Object.hasOwnProperty.call(message, "buyItemCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buyItemCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaBuyInfo message, length delimited. Does not implicitly {@link PB_SCArenaBuyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaBuyInfo
         * @static
         * @param {IPB_SCArenaBuyInfo} message PB_SCArenaBuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaBuyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaBuyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaBuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaBuyInfo} PB_SCArenaBuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaBuyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaBuyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.buyItemCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaBuyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaBuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaBuyInfo} PB_SCArenaBuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaBuyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaBuyInfo message.
         * @function verify
         * @memberof PB_SCArenaBuyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaBuyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.buyItemCount != null && message.hasOwnProperty("buyItemCount"))
                if (!$util.isInteger(message.buyItemCount))
                    return "buyItemCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCArenaBuyInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaBuyInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaBuyInfo} PB_SCArenaBuyInfo
         */
        PB_SCArenaBuyInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaBuyInfo)
                return object;
            var message = new $root.PB_SCArenaBuyInfo();
            if (object.buyItemCount != null)
                message.buyItemCount = object.buyItemCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaBuyInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaBuyInfo
         * @static
         * @param {PB_SCArenaBuyInfo} message PB_SCArenaBuyInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaBuyInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.buyItemCount = 0;
            if (message.buyItemCount != null && message.hasOwnProperty("buyItemCount"))
                object.buyItemCount = message.buyItemCount;
            return object;
        };
    
        /**
         * Converts this PB_SCArenaBuyInfo to JSON.
         * @function toJSON
         * @memberof PB_SCArenaBuyInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaBuyInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaBuyInfo;
    })();
    
    $root.PB_Appearance = (function() {
    
        /**
         * Properties of a PB_Appearance.
         * @exports IPB_Appearance
         * @interface IPB_Appearance
         * @property {number|null} [surfaceWeapon] PB_Appearance surfaceWeapon
         * @property {number|null} [surfaceShield] PB_Appearance surfaceShield
         * @property {number|null} [surfaceBody] PB_Appearance surfaceBody
         * @property {number|null} [surfaceMount] PB_Appearance surfaceMount
         * @property {number|null} [surfaceHead] PB_Appearance surfaceHead
         * @property {number|null} [surfaceAngel] PB_Appearance surfaceAngel
         */
    
        /**
         * Constructs a new PB_Appearance.
         * @exports PB_Appearance
         * @classdesc Represents a PB_Appearance.
         * @implements IPB_Appearance
         * @constructor
         * @param {IPB_Appearance=} [properties] Properties to set
         */
        function PB_Appearance(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_Appearance surfaceWeapon.
         * @member {number} surfaceWeapon
         * @memberof PB_Appearance
         * @instance
         */
        PB_Appearance.prototype.surfaceWeapon = 0;
    
        /**
         * PB_Appearance surfaceShield.
         * @member {number} surfaceShield
         * @memberof PB_Appearance
         * @instance
         */
        PB_Appearance.prototype.surfaceShield = 0;
    
        /**
         * PB_Appearance surfaceBody.
         * @member {number} surfaceBody
         * @memberof PB_Appearance
         * @instance
         */
        PB_Appearance.prototype.surfaceBody = 0;
    
        /**
         * PB_Appearance surfaceMount.
         * @member {number} surfaceMount
         * @memberof PB_Appearance
         * @instance
         */
        PB_Appearance.prototype.surfaceMount = 0;
    
        /**
         * PB_Appearance surfaceHead.
         * @member {number} surfaceHead
         * @memberof PB_Appearance
         * @instance
         */
        PB_Appearance.prototype.surfaceHead = 0;
    
        /**
         * PB_Appearance surfaceAngel.
         * @member {number} surfaceAngel
         * @memberof PB_Appearance
         * @instance
         */
        PB_Appearance.prototype.surfaceAngel = 0;
    
        /**
         * Creates a new PB_Appearance instance using the specified properties.
         * @function create
         * @memberof PB_Appearance
         * @static
         * @param {IPB_Appearance=} [properties] Properties to set
         * @returns {PB_Appearance} PB_Appearance instance
         */
        PB_Appearance.create = function create(properties) {
            return new PB_Appearance(properties);
        };
    
        /**
         * Encodes the specified PB_Appearance message. Does not implicitly {@link PB_Appearance.verify|verify} messages.
         * @function encode
         * @memberof PB_Appearance
         * @static
         * @param {IPB_Appearance} message PB_Appearance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_Appearance.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.surfaceWeapon != null && Object.hasOwnProperty.call(message, "surfaceWeapon"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.surfaceWeapon);
            if (message.surfaceShield != null && Object.hasOwnProperty.call(message, "surfaceShield"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.surfaceShield);
            if (message.surfaceBody != null && Object.hasOwnProperty.call(message, "surfaceBody"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.surfaceBody);
            if (message.surfaceMount != null && Object.hasOwnProperty.call(message, "surfaceMount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.surfaceMount);
            if (message.surfaceHead != null && Object.hasOwnProperty.call(message, "surfaceHead"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.surfaceHead);
            if (message.surfaceAngel != null && Object.hasOwnProperty.call(message, "surfaceAngel"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.surfaceAngel);
            return writer;
        };
    
        /**
         * Encodes the specified PB_Appearance message, length delimited. Does not implicitly {@link PB_Appearance.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_Appearance
         * @static
         * @param {IPB_Appearance} message PB_Appearance message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_Appearance.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_Appearance message from the specified reader or buffer.
         * @function decode
         * @memberof PB_Appearance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_Appearance} PB_Appearance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_Appearance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_Appearance();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.surfaceWeapon = reader.int32();
                    break;
                case 2:
                    message.surfaceShield = reader.int32();
                    break;
                case 3:
                    message.surfaceBody = reader.int32();
                    break;
                case 4:
                    message.surfaceMount = reader.int32();
                    break;
                case 5:
                    message.surfaceHead = reader.int32();
                    break;
                case 6:
                    message.surfaceAngel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_Appearance message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_Appearance
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_Appearance} PB_Appearance
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_Appearance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_Appearance message.
         * @function verify
         * @memberof PB_Appearance
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_Appearance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.surfaceWeapon != null && message.hasOwnProperty("surfaceWeapon"))
                if (!$util.isInteger(message.surfaceWeapon))
                    return "surfaceWeapon: integer expected";
            if (message.surfaceShield != null && message.hasOwnProperty("surfaceShield"))
                if (!$util.isInteger(message.surfaceShield))
                    return "surfaceShield: integer expected";
            if (message.surfaceBody != null && message.hasOwnProperty("surfaceBody"))
                if (!$util.isInteger(message.surfaceBody))
                    return "surfaceBody: integer expected";
            if (message.surfaceMount != null && message.hasOwnProperty("surfaceMount"))
                if (!$util.isInteger(message.surfaceMount))
                    return "surfaceMount: integer expected";
            if (message.surfaceHead != null && message.hasOwnProperty("surfaceHead"))
                if (!$util.isInteger(message.surfaceHead))
                    return "surfaceHead: integer expected";
            if (message.surfaceAngel != null && message.hasOwnProperty("surfaceAngel"))
                if (!$util.isInteger(message.surfaceAngel))
                    return "surfaceAngel: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_Appearance message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_Appearance
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_Appearance} PB_Appearance
         */
        PB_Appearance.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_Appearance)
                return object;
            var message = new $root.PB_Appearance();
            if (object.surfaceWeapon != null)
                message.surfaceWeapon = object.surfaceWeapon | 0;
            if (object.surfaceShield != null)
                message.surfaceShield = object.surfaceShield | 0;
            if (object.surfaceBody != null)
                message.surfaceBody = object.surfaceBody | 0;
            if (object.surfaceMount != null)
                message.surfaceMount = object.surfaceMount | 0;
            if (object.surfaceHead != null)
                message.surfaceHead = object.surfaceHead | 0;
            if (object.surfaceAngel != null)
                message.surfaceAngel = object.surfaceAngel | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_Appearance message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_Appearance
         * @static
         * @param {PB_Appearance} message PB_Appearance
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_Appearance.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.surfaceWeapon = 0;
                object.surfaceShield = 0;
                object.surfaceBody = 0;
                object.surfaceMount = 0;
                object.surfaceHead = 0;
                object.surfaceAngel = 0;
            }
            if (message.surfaceWeapon != null && message.hasOwnProperty("surfaceWeapon"))
                object.surfaceWeapon = message.surfaceWeapon;
            if (message.surfaceShield != null && message.hasOwnProperty("surfaceShield"))
                object.surfaceShield = message.surfaceShield;
            if (message.surfaceBody != null && message.hasOwnProperty("surfaceBody"))
                object.surfaceBody = message.surfaceBody;
            if (message.surfaceMount != null && message.hasOwnProperty("surfaceMount"))
                object.surfaceMount = message.surfaceMount;
            if (message.surfaceHead != null && message.hasOwnProperty("surfaceHead"))
                object.surfaceHead = message.surfaceHead;
            if (message.surfaceAngel != null && message.hasOwnProperty("surfaceAngel"))
                object.surfaceAngel = message.surfaceAngel;
            return object;
        };
    
        /**
         * Converts this PB_Appearance to JSON.
         * @function toJSON
         * @memberof PB_Appearance
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_Appearance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_Appearance;
    })();
    
    $root.PB_RoleInfo = (function() {
    
        /**
         * Properties of a PB_RoleInfo.
         * @exports IPB_RoleInfo
         * @interface IPB_RoleInfo
         * @property {number|null} [roleId] PB_RoleInfo roleId
         * @property {Uint8Array|null} [name] PB_RoleInfo name
         * @property {number|null} [level] PB_RoleInfo level
         * @property {number|null} [headPicId] PB_RoleInfo headPicId
         * @property {Uint8Array|null} [headChar] PB_RoleInfo headChar
         * @property {number|null} [headFrame] PB_RoleInfo headFrame
         * @property {Array.<number>|null} [heroId] PB_RoleInfo heroId
         * @property {Array.<number>|null} [heroLevel] PB_RoleInfo heroLevel
         */
    
        /**
         * Constructs a new PB_RoleInfo.
         * @exports PB_RoleInfo
         * @classdesc Represents a PB_RoleInfo.
         * @implements IPB_RoleInfo
         * @constructor
         * @param {IPB_RoleInfo=} [properties] Properties to set
         */
        function PB_RoleInfo(properties) {
            this.heroId = [];
            this.heroLevel = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RoleInfo roleId.
         * @member {number} roleId
         * @memberof PB_RoleInfo
         * @instance
         */
        PB_RoleInfo.prototype.roleId = 0;
    
        /**
         * PB_RoleInfo name.
         * @member {Uint8Array} name
         * @memberof PB_RoleInfo
         * @instance
         */
        PB_RoleInfo.prototype.name = $util.newBuffer([]);
    
        /**
         * PB_RoleInfo level.
         * @member {number} level
         * @memberof PB_RoleInfo
         * @instance
         */
        PB_RoleInfo.prototype.level = 0;
    
        /**
         * PB_RoleInfo headPicId.
         * @member {number} headPicId
         * @memberof PB_RoleInfo
         * @instance
         */
        PB_RoleInfo.prototype.headPicId = 0;
    
        /**
         * PB_RoleInfo headChar.
         * @member {Uint8Array} headChar
         * @memberof PB_RoleInfo
         * @instance
         */
        PB_RoleInfo.prototype.headChar = $util.newBuffer([]);
    
        /**
         * PB_RoleInfo headFrame.
         * @member {number} headFrame
         * @memberof PB_RoleInfo
         * @instance
         */
        PB_RoleInfo.prototype.headFrame = 0;
    
        /**
         * PB_RoleInfo heroId.
         * @member {Array.<number>} heroId
         * @memberof PB_RoleInfo
         * @instance
         */
        PB_RoleInfo.prototype.heroId = $util.emptyArray;
    
        /**
         * PB_RoleInfo heroLevel.
         * @member {Array.<number>} heroLevel
         * @memberof PB_RoleInfo
         * @instance
         */
        PB_RoleInfo.prototype.heroLevel = $util.emptyArray;
    
        /**
         * Creates a new PB_RoleInfo instance using the specified properties.
         * @function create
         * @memberof PB_RoleInfo
         * @static
         * @param {IPB_RoleInfo=} [properties] Properties to set
         * @returns {PB_RoleInfo} PB_RoleInfo instance
         */
        PB_RoleInfo.create = function create(properties) {
            return new PB_RoleInfo(properties);
        };
    
        /**
         * Encodes the specified PB_RoleInfo message. Does not implicitly {@link PB_RoleInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_RoleInfo
         * @static
         * @param {IPB_RoleInfo} message PB_RoleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.name);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
            if (message.headPicId != null && Object.hasOwnProperty.call(message, "headPicId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.headPicId);
            if (message.headChar != null && Object.hasOwnProperty.call(message, "headChar"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.headChar);
            if (message.headFrame != null && Object.hasOwnProperty.call(message, "headFrame"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.headFrame);
            if (message.heroId != null && message.heroId.length)
                for (var i = 0; i < message.heroId.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.heroId[i]);
            if (message.heroLevel != null && message.heroLevel.length)
                for (var i = 0; i < message.heroLevel.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.heroLevel[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RoleInfo message, length delimited. Does not implicitly {@link PB_RoleInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RoleInfo
         * @static
         * @param {IPB_RoleInfo} message PB_RoleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RoleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RoleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RoleInfo} PB_RoleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RoleInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int32();
                    break;
                case 2:
                    message.name = reader.bytes();
                    break;
                case 3:
                    message.level = reader.int32();
                    break;
                case 4:
                    message.headPicId = reader.int32();
                    break;
                case 5:
                    message.headChar = reader.bytes();
                    break;
                case 6:
                    message.headFrame = reader.int32();
                    break;
                case 7:
                    if (!(message.heroId && message.heroId.length))
                        message.heroId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.heroId.push(reader.int32());
                    } else
                        message.heroId.push(reader.int32());
                    break;
                case 8:
                    if (!(message.heroLevel && message.heroLevel.length))
                        message.heroLevel = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.heroLevel.push(reader.int32());
                    } else
                        message.heroLevel.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RoleInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RoleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RoleInfo} PB_RoleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RoleInfo message.
         * @function verify
         * @memberof PB_RoleInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RoleInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.headPicId != null && message.hasOwnProperty("headPicId"))
                if (!$util.isInteger(message.headPicId))
                    return "headPicId: integer expected";
            if (message.headChar != null && message.hasOwnProperty("headChar"))
                if (!(message.headChar && typeof message.headChar.length === "number" || $util.isString(message.headChar)))
                    return "headChar: buffer expected";
            if (message.headFrame != null && message.hasOwnProperty("headFrame"))
                if (!$util.isInteger(message.headFrame))
                    return "headFrame: integer expected";
            if (message.heroId != null && message.hasOwnProperty("heroId")) {
                if (!Array.isArray(message.heroId))
                    return "heroId: array expected";
                for (var i = 0; i < message.heroId.length; ++i)
                    if (!$util.isInteger(message.heroId[i]))
                        return "heroId: integer[] expected";
            }
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel")) {
                if (!Array.isArray(message.heroLevel))
                    return "heroLevel: array expected";
                for (var i = 0; i < message.heroLevel.length; ++i)
                    if (!$util.isInteger(message.heroLevel[i]))
                        return "heroLevel: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_RoleInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RoleInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RoleInfo} PB_RoleInfo
         */
        PB_RoleInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RoleInfo)
                return object;
            var message = new $root.PB_RoleInfo();
            if (object.roleId != null)
                message.roleId = object.roleId | 0;
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.level != null)
                message.level = object.level | 0;
            if (object.headPicId != null)
                message.headPicId = object.headPicId | 0;
            if (object.headChar != null)
                if (typeof object.headChar === "string")
                    $util.base64.decode(object.headChar, message.headChar = $util.newBuffer($util.base64.length(object.headChar)), 0);
                else if (object.headChar.length)
                    message.headChar = object.headChar;
            if (object.headFrame != null)
                message.headFrame = object.headFrame | 0;
            if (object.heroId) {
                if (!Array.isArray(object.heroId))
                    throw TypeError(".PB_RoleInfo.heroId: array expected");
                message.heroId = [];
                for (var i = 0; i < object.heroId.length; ++i)
                    message.heroId[i] = object.heroId[i] | 0;
            }
            if (object.heroLevel) {
                if (!Array.isArray(object.heroLevel))
                    throw TypeError(".PB_RoleInfo.heroLevel: array expected");
                message.heroLevel = [];
                for (var i = 0; i < object.heroLevel.length; ++i)
                    message.heroLevel[i] = object.heroLevel[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RoleInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RoleInfo
         * @static
         * @param {PB_RoleInfo} message PB_RoleInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RoleInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.heroId = [];
                object.heroLevel = [];
            }
            if (options.defaults) {
                object.roleId = 0;
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                object.level = 0;
                object.headPicId = 0;
                if (options.bytes === String)
                    object.headChar = "";
                else {
                    object.headChar = [];
                    if (options.bytes !== Array)
                        object.headChar = $util.newBuffer(object.headChar);
                }
                object.headFrame = 0;
            }
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                object.roleId = message.roleId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.headPicId != null && message.hasOwnProperty("headPicId"))
                object.headPicId = message.headPicId;
            if (message.headChar != null && message.hasOwnProperty("headChar"))
                object.headChar = options.bytes === String ? $util.base64.encode(message.headChar, 0, message.headChar.length) : options.bytes === Array ? Array.prototype.slice.call(message.headChar) : message.headChar;
            if (message.headFrame != null && message.hasOwnProperty("headFrame"))
                object.headFrame = message.headFrame;
            if (message.heroId && message.heroId.length) {
                object.heroId = [];
                for (var j = 0; j < message.heroId.length; ++j)
                    object.heroId[j] = message.heroId[j];
            }
            if (message.heroLevel && message.heroLevel.length) {
                object.heroLevel = [];
                for (var j = 0; j < message.heroLevel.length; ++j)
                    object.heroLevel[j] = message.heroLevel[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_RoleInfo to JSON.
         * @function toJSON
         * @memberof PB_RoleInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RoleInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RoleInfo;
    })();
    
    $root.PB_SCRoleInfoAck = (function() {
    
        /**
         * Properties of a PB_SCRoleInfoAck.
         * @exports IPB_SCRoleInfoAck
         * @interface IPB_SCRoleInfoAck
         * @property {number|Long|null} [curExp] PB_SCRoleInfoAck curExp
         * @property {number|Long|null} [createTime] PB_SCRoleInfoAck createTime
         * @property {IPB_RoleInfo|null} [roleinfo] PB_SCRoleInfoAck roleinfo
         * @property {IPB_Appearance|null} [appearance] PB_SCRoleInfoAck appearance
         * @property {number|null} [sendReason] PB_SCRoleInfoAck sendReason
         * @property {number|Long|null} [energy] PB_SCRoleInfoAck energy
         * @property {number|Long|null} [energyUpTime] PB_SCRoleInfoAck energyUpTime
         * @property {Array.<number>|null} [fightList] PB_SCRoleInfoAck fightList
         * @property {number|null} [mainFbLevel] PB_SCRoleInfoAck mainFbLevel
         * @property {number|null} [mainFbRound] PB_SCRoleInfoAck mainFbRound
         * @property {Array.<boolean>|null} [mainFbReward] PB_SCRoleInfoAck mainFbReward
         * @property {Uint8Array|null} [token] PB_SCRoleInfoAck token
         * @property {number|null} [setNameCount] PB_SCRoleInfoAck setNameCount
         */
    
        /**
         * Constructs a new PB_SCRoleInfoAck.
         * @exports PB_SCRoleInfoAck
         * @classdesc Represents a PB_SCRoleInfoAck.
         * @implements IPB_SCRoleInfoAck
         * @constructor
         * @param {IPB_SCRoleInfoAck=} [properties] Properties to set
         */
        function PB_SCRoleInfoAck(properties) {
            this.fightList = [];
            this.mainFbReward = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleInfoAck curExp.
         * @member {number|Long} curExp
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.curExp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCRoleInfoAck createTime.
         * @member {number|Long} createTime
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCRoleInfoAck roleinfo.
         * @member {IPB_RoleInfo|null|undefined} roleinfo
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.roleinfo = null;
    
        /**
         * PB_SCRoleInfoAck appearance.
         * @member {IPB_Appearance|null|undefined} appearance
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.appearance = null;
    
        /**
         * PB_SCRoleInfoAck sendReason.
         * @member {number} sendReason
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.sendReason = 0;
    
        /**
         * PB_SCRoleInfoAck energy.
         * @member {number|Long} energy
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.energy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCRoleInfoAck energyUpTime.
         * @member {number|Long} energyUpTime
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.energyUpTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCRoleInfoAck fightList.
         * @member {Array.<number>} fightList
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.fightList = $util.emptyArray;
    
        /**
         * PB_SCRoleInfoAck mainFbLevel.
         * @member {number} mainFbLevel
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.mainFbLevel = 0;
    
        /**
         * PB_SCRoleInfoAck mainFbRound.
         * @member {number} mainFbRound
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.mainFbRound = 0;
    
        /**
         * PB_SCRoleInfoAck mainFbReward.
         * @member {Array.<boolean>} mainFbReward
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.mainFbReward = $util.emptyArray;
    
        /**
         * PB_SCRoleInfoAck token.
         * @member {Uint8Array} token
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.token = $util.newBuffer([]);
    
        /**
         * PB_SCRoleInfoAck setNameCount.
         * @member {number} setNameCount
         * @memberof PB_SCRoleInfoAck
         * @instance
         */
        PB_SCRoleInfoAck.prototype.setNameCount = 0;
    
        /**
         * Creates a new PB_SCRoleInfoAck instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleInfoAck
         * @static
         * @param {IPB_SCRoleInfoAck=} [properties] Properties to set
         * @returns {PB_SCRoleInfoAck} PB_SCRoleInfoAck instance
         */
        PB_SCRoleInfoAck.create = function create(properties) {
            return new PB_SCRoleInfoAck(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleInfoAck message. Does not implicitly {@link PB_SCRoleInfoAck.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleInfoAck
         * @static
         * @param {IPB_SCRoleInfoAck} message PB_SCRoleInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleInfoAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.curExp != null && Object.hasOwnProperty.call(message, "curExp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.curExp);
            if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.createTime);
            if (message.roleinfo != null && Object.hasOwnProperty.call(message, "roleinfo"))
                $root.PB_RoleInfo.encode(message.roleinfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.appearance != null && Object.hasOwnProperty.call(message, "appearance"))
                $root.PB_Appearance.encode(message.appearance, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.sendReason != null && Object.hasOwnProperty.call(message, "sendReason"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sendReason);
            if (message.energy != null && Object.hasOwnProperty.call(message, "energy"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.energy);
            if (message.energyUpTime != null && Object.hasOwnProperty.call(message, "energyUpTime"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.energyUpTime);
            if (message.fightList != null && message.fightList.length)
                for (var i = 0; i < message.fightList.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.fightList[i]);
            if (message.mainFbLevel != null && Object.hasOwnProperty.call(message, "mainFbLevel"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.mainFbLevel);
            if (message.mainFbRound != null && Object.hasOwnProperty.call(message, "mainFbRound"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.mainFbRound);
            if (message.mainFbReward != null && message.mainFbReward.length)
                for (var i = 0; i < message.mainFbReward.length; ++i)
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.mainFbReward[i]);
            if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.token);
            if (message.setNameCount != null && Object.hasOwnProperty.call(message, "setNameCount"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.setNameCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleInfoAck message, length delimited. Does not implicitly {@link PB_SCRoleInfoAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleInfoAck
         * @static
         * @param {IPB_SCRoleInfoAck} message PB_SCRoleInfoAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleInfoAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleInfoAck message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleInfoAck} PB_SCRoleInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleInfoAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleInfoAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.curExp = reader.int64();
                    break;
                case 2:
                    message.createTime = reader.int64();
                    break;
                case 3:
                    message.roleinfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.appearance = $root.PB_Appearance.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.sendReason = reader.int32();
                    break;
                case 6:
                    message.energy = reader.int64();
                    break;
                case 7:
                    message.energyUpTime = reader.int64();
                    break;
                case 8:
                    if (!(message.fightList && message.fightList.length))
                        message.fightList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.fightList.push(reader.int32());
                    } else
                        message.fightList.push(reader.int32());
                    break;
                case 9:
                    message.mainFbLevel = reader.int32();
                    break;
                case 10:
                    message.mainFbRound = reader.int32();
                    break;
                case 11:
                    if (!(message.mainFbReward && message.mainFbReward.length))
                        message.mainFbReward = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.mainFbReward.push(reader.bool());
                    } else
                        message.mainFbReward.push(reader.bool());
                    break;
                case 12:
                    message.token = reader.bytes();
                    break;
                case 13:
                    message.setNameCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleInfoAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleInfoAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleInfoAck} PB_SCRoleInfoAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleInfoAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleInfoAck message.
         * @function verify
         * @memberof PB_SCRoleInfoAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleInfoAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.curExp != null && message.hasOwnProperty("curExp"))
                if (!$util.isInteger(message.curExp) && !(message.curExp && $util.isInteger(message.curExp.low) && $util.isInteger(message.curExp.high)))
                    return "curExp: integer|Long expected";
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                    return "createTime: integer|Long expected";
            if (message.roleinfo != null && message.hasOwnProperty("roleinfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleinfo);
                if (error)
                    return "roleinfo." + error;
            }
            if (message.appearance != null && message.hasOwnProperty("appearance")) {
                var error = $root.PB_Appearance.verify(message.appearance);
                if (error)
                    return "appearance." + error;
            }
            if (message.sendReason != null && message.hasOwnProperty("sendReason"))
                if (!$util.isInteger(message.sendReason))
                    return "sendReason: integer expected";
            if (message.energy != null && message.hasOwnProperty("energy"))
                if (!$util.isInteger(message.energy) && !(message.energy && $util.isInteger(message.energy.low) && $util.isInteger(message.energy.high)))
                    return "energy: integer|Long expected";
            if (message.energyUpTime != null && message.hasOwnProperty("energyUpTime"))
                if (!$util.isInteger(message.energyUpTime) && !(message.energyUpTime && $util.isInteger(message.energyUpTime.low) && $util.isInteger(message.energyUpTime.high)))
                    return "energyUpTime: integer|Long expected";
            if (message.fightList != null && message.hasOwnProperty("fightList")) {
                if (!Array.isArray(message.fightList))
                    return "fightList: array expected";
                for (var i = 0; i < message.fightList.length; ++i)
                    if (!$util.isInteger(message.fightList[i]))
                        return "fightList: integer[] expected";
            }
            if (message.mainFbLevel != null && message.hasOwnProperty("mainFbLevel"))
                if (!$util.isInteger(message.mainFbLevel))
                    return "mainFbLevel: integer expected";
            if (message.mainFbRound != null && message.hasOwnProperty("mainFbRound"))
                if (!$util.isInteger(message.mainFbRound))
                    return "mainFbRound: integer expected";
            if (message.mainFbReward != null && message.hasOwnProperty("mainFbReward")) {
                if (!Array.isArray(message.mainFbReward))
                    return "mainFbReward: array expected";
                for (var i = 0; i < message.mainFbReward.length; ++i)
                    if (typeof message.mainFbReward[i] !== "boolean")
                        return "mainFbReward: boolean[] expected";
            }
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            if (message.setNameCount != null && message.hasOwnProperty("setNameCount"))
                if (!$util.isInteger(message.setNameCount))
                    return "setNameCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleInfoAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleInfoAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleInfoAck} PB_SCRoleInfoAck
         */
        PB_SCRoleInfoAck.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleInfoAck)
                return object;
            var message = new $root.PB_SCRoleInfoAck();
            if (object.curExp != null)
                if ($util.Long)
                    (message.curExp = $util.Long.fromValue(object.curExp)).unsigned = false;
                else if (typeof object.curExp === "string")
                    message.curExp = parseInt(object.curExp, 10);
                else if (typeof object.curExp === "number")
                    message.curExp = object.curExp;
                else if (typeof object.curExp === "object")
                    message.curExp = new $util.LongBits(object.curExp.low >>> 0, object.curExp.high >>> 0).toNumber();
            if (object.createTime != null)
                if ($util.Long)
                    (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = false;
                else if (typeof object.createTime === "string")
                    message.createTime = parseInt(object.createTime, 10);
                else if (typeof object.createTime === "number")
                    message.createTime = object.createTime;
                else if (typeof object.createTime === "object")
                    message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber();
            if (object.roleinfo != null) {
                if (typeof object.roleinfo !== "object")
                    throw TypeError(".PB_SCRoleInfoAck.roleinfo: object expected");
                message.roleinfo = $root.PB_RoleInfo.fromObject(object.roleinfo);
            }
            if (object.appearance != null) {
                if (typeof object.appearance !== "object")
                    throw TypeError(".PB_SCRoleInfoAck.appearance: object expected");
                message.appearance = $root.PB_Appearance.fromObject(object.appearance);
            }
            if (object.sendReason != null)
                message.sendReason = object.sendReason | 0;
            if (object.energy != null)
                if ($util.Long)
                    (message.energy = $util.Long.fromValue(object.energy)).unsigned = false;
                else if (typeof object.energy === "string")
                    message.energy = parseInt(object.energy, 10);
                else if (typeof object.energy === "number")
                    message.energy = object.energy;
                else if (typeof object.energy === "object")
                    message.energy = new $util.LongBits(object.energy.low >>> 0, object.energy.high >>> 0).toNumber();
            if (object.energyUpTime != null)
                if ($util.Long)
                    (message.energyUpTime = $util.Long.fromValue(object.energyUpTime)).unsigned = false;
                else if (typeof object.energyUpTime === "string")
                    message.energyUpTime = parseInt(object.energyUpTime, 10);
                else if (typeof object.energyUpTime === "number")
                    message.energyUpTime = object.energyUpTime;
                else if (typeof object.energyUpTime === "object")
                    message.energyUpTime = new $util.LongBits(object.energyUpTime.low >>> 0, object.energyUpTime.high >>> 0).toNumber();
            if (object.fightList) {
                if (!Array.isArray(object.fightList))
                    throw TypeError(".PB_SCRoleInfoAck.fightList: array expected");
                message.fightList = [];
                for (var i = 0; i < object.fightList.length; ++i)
                    message.fightList[i] = object.fightList[i] | 0;
            }
            if (object.mainFbLevel != null)
                message.mainFbLevel = object.mainFbLevel | 0;
            if (object.mainFbRound != null)
                message.mainFbRound = object.mainFbRound | 0;
            if (object.mainFbReward) {
                if (!Array.isArray(object.mainFbReward))
                    throw TypeError(".PB_SCRoleInfoAck.mainFbReward: array expected");
                message.mainFbReward = [];
                for (var i = 0; i < object.mainFbReward.length; ++i)
                    message.mainFbReward[i] = Boolean(object.mainFbReward[i]);
            }
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            if (object.setNameCount != null)
                message.setNameCount = object.setNameCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleInfoAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleInfoAck
         * @static
         * @param {PB_SCRoleInfoAck} message PB_SCRoleInfoAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleInfoAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fightList = [];
                object.mainFbReward = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.curExp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.curExp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createTime = options.longs === String ? "0" : 0;
                object.roleinfo = null;
                object.appearance = null;
                object.sendReason = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.energy = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energyUpTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.energyUpTime = options.longs === String ? "0" : 0;
                object.mainFbLevel = 0;
                object.mainFbRound = 0;
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
                object.setNameCount = 0;
            }
            if (message.curExp != null && message.hasOwnProperty("curExp"))
                if (typeof message.curExp === "number")
                    object.curExp = options.longs === String ? String(message.curExp) : message.curExp;
                else
                    object.curExp = options.longs === String ? $util.Long.prototype.toString.call(message.curExp) : options.longs === Number ? new $util.LongBits(message.curExp.low >>> 0, message.curExp.high >>> 0).toNumber() : message.curExp;
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (typeof message.createTime === "number")
                    object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                else
                    object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber() : message.createTime;
            if (message.roleinfo != null && message.hasOwnProperty("roleinfo"))
                object.roleinfo = $root.PB_RoleInfo.toObject(message.roleinfo, options);
            if (message.appearance != null && message.hasOwnProperty("appearance"))
                object.appearance = $root.PB_Appearance.toObject(message.appearance, options);
            if (message.sendReason != null && message.hasOwnProperty("sendReason"))
                object.sendReason = message.sendReason;
            if (message.energy != null && message.hasOwnProperty("energy"))
                if (typeof message.energy === "number")
                    object.energy = options.longs === String ? String(message.energy) : message.energy;
                else
                    object.energy = options.longs === String ? $util.Long.prototype.toString.call(message.energy) : options.longs === Number ? new $util.LongBits(message.energy.low >>> 0, message.energy.high >>> 0).toNumber() : message.energy;
            if (message.energyUpTime != null && message.hasOwnProperty("energyUpTime"))
                if (typeof message.energyUpTime === "number")
                    object.energyUpTime = options.longs === String ? String(message.energyUpTime) : message.energyUpTime;
                else
                    object.energyUpTime = options.longs === String ? $util.Long.prototype.toString.call(message.energyUpTime) : options.longs === Number ? new $util.LongBits(message.energyUpTime.low >>> 0, message.energyUpTime.high >>> 0).toNumber() : message.energyUpTime;
            if (message.fightList && message.fightList.length) {
                object.fightList = [];
                for (var j = 0; j < message.fightList.length; ++j)
                    object.fightList[j] = message.fightList[j];
            }
            if (message.mainFbLevel != null && message.hasOwnProperty("mainFbLevel"))
                object.mainFbLevel = message.mainFbLevel;
            if (message.mainFbRound != null && message.hasOwnProperty("mainFbRound"))
                object.mainFbRound = message.mainFbRound;
            if (message.mainFbReward && message.mainFbReward.length) {
                object.mainFbReward = [];
                for (var j = 0; j < message.mainFbReward.length; ++j)
                    object.mainFbReward[j] = message.mainFbReward[j];
            }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            if (message.setNameCount != null && message.hasOwnProperty("setNameCount"))
                object.setNameCount = message.setNameCount;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleInfoAck to JSON.
         * @function toJSON
         * @memberof PB_SCRoleInfoAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleInfoAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleInfoAck;
    })();
    
    $root.PB_AttrPair = (function() {
    
        /**
         * Properties of a PB_AttrPair.
         * @exports IPB_AttrPair
         * @interface IPB_AttrPair
         * @property {number|null} [attrType] PB_AttrPair attrType
         * @property {number|Long|null} [attrValue] PB_AttrPair attrValue
         */
    
        /**
         * Constructs a new PB_AttrPair.
         * @exports PB_AttrPair
         * @classdesc Represents a PB_AttrPair.
         * @implements IPB_AttrPair
         * @constructor
         * @param {IPB_AttrPair=} [properties] Properties to set
         */
        function PB_AttrPair(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_AttrPair attrType.
         * @member {number} attrType
         * @memberof PB_AttrPair
         * @instance
         */
        PB_AttrPair.prototype.attrType = 0;
    
        /**
         * PB_AttrPair attrValue.
         * @member {number|Long} attrValue
         * @memberof PB_AttrPair
         * @instance
         */
        PB_AttrPair.prototype.attrValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_AttrPair instance using the specified properties.
         * @function create
         * @memberof PB_AttrPair
         * @static
         * @param {IPB_AttrPair=} [properties] Properties to set
         * @returns {PB_AttrPair} PB_AttrPair instance
         */
        PB_AttrPair.create = function create(properties) {
            return new PB_AttrPair(properties);
        };
    
        /**
         * Encodes the specified PB_AttrPair message. Does not implicitly {@link PB_AttrPair.verify|verify} messages.
         * @function encode
         * @memberof PB_AttrPair
         * @static
         * @param {IPB_AttrPair} message PB_AttrPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_AttrPair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.attrType != null && Object.hasOwnProperty.call(message, "attrType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.attrType);
            if (message.attrValue != null && Object.hasOwnProperty.call(message, "attrValue"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.attrValue);
            return writer;
        };
    
        /**
         * Encodes the specified PB_AttrPair message, length delimited. Does not implicitly {@link PB_AttrPair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_AttrPair
         * @static
         * @param {IPB_AttrPair} message PB_AttrPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_AttrPair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_AttrPair message from the specified reader or buffer.
         * @function decode
         * @memberof PB_AttrPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_AttrPair} PB_AttrPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_AttrPair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_AttrPair();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.attrType = reader.int32();
                    break;
                case 2:
                    message.attrValue = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_AttrPair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_AttrPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_AttrPair} PB_AttrPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_AttrPair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_AttrPair message.
         * @function verify
         * @memberof PB_AttrPair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_AttrPair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.attrType != null && message.hasOwnProperty("attrType"))
                if (!$util.isInteger(message.attrType))
                    return "attrType: integer expected";
            if (message.attrValue != null && message.hasOwnProperty("attrValue"))
                if (!$util.isInteger(message.attrValue) && !(message.attrValue && $util.isInteger(message.attrValue.low) && $util.isInteger(message.attrValue.high)))
                    return "attrValue: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_AttrPair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_AttrPair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_AttrPair} PB_AttrPair
         */
        PB_AttrPair.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_AttrPair)
                return object;
            var message = new $root.PB_AttrPair();
            if (object.attrType != null)
                message.attrType = object.attrType | 0;
            if (object.attrValue != null)
                if ($util.Long)
                    (message.attrValue = $util.Long.fromValue(object.attrValue)).unsigned = false;
                else if (typeof object.attrValue === "string")
                    message.attrValue = parseInt(object.attrValue, 10);
                else if (typeof object.attrValue === "number")
                    message.attrValue = object.attrValue;
                else if (typeof object.attrValue === "object")
                    message.attrValue = new $util.LongBits(object.attrValue.low >>> 0, object.attrValue.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_AttrPair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_AttrPair
         * @static
         * @param {PB_AttrPair} message PB_AttrPair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_AttrPair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.attrType = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.attrValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.attrValue = options.longs === String ? "0" : 0;
            }
            if (message.attrType != null && message.hasOwnProperty("attrType"))
                object.attrType = message.attrType;
            if (message.attrValue != null && message.hasOwnProperty("attrValue"))
                if (typeof message.attrValue === "number")
                    object.attrValue = options.longs === String ? String(message.attrValue) : message.attrValue;
                else
                    object.attrValue = options.longs === String ? $util.Long.prototype.toString.call(message.attrValue) : options.longs === Number ? new $util.LongBits(message.attrValue.low >>> 0, message.attrValue.high >>> 0).toNumber() : message.attrValue;
            return object;
        };
    
        /**
         * Converts this PB_AttrPair to JSON.
         * @function toJSON
         * @memberof PB_AttrPair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_AttrPair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_AttrPair;
    })();
    
    $root.PB_SCRoleExpChange = (function() {
    
        /**
         * Properties of a PB_SCRoleExpChange.
         * @exports IPB_SCRoleExpChange
         * @interface IPB_SCRoleExpChange
         * @property {number|Long|null} [changeExp] PB_SCRoleExpChange changeExp
         * @property {number|Long|null} [curExp] PB_SCRoleExpChange curExp
         */
    
        /**
         * Constructs a new PB_SCRoleExpChange.
         * @exports PB_SCRoleExpChange
         * @classdesc Represents a PB_SCRoleExpChange.
         * @implements IPB_SCRoleExpChange
         * @constructor
         * @param {IPB_SCRoleExpChange=} [properties] Properties to set
         */
        function PB_SCRoleExpChange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleExpChange changeExp.
         * @member {number|Long} changeExp
         * @memberof PB_SCRoleExpChange
         * @instance
         */
        PB_SCRoleExpChange.prototype.changeExp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCRoleExpChange curExp.
         * @member {number|Long} curExp
         * @memberof PB_SCRoleExpChange
         * @instance
         */
        PB_SCRoleExpChange.prototype.curExp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCRoleExpChange instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleExpChange
         * @static
         * @param {IPB_SCRoleExpChange=} [properties] Properties to set
         * @returns {PB_SCRoleExpChange} PB_SCRoleExpChange instance
         */
        PB_SCRoleExpChange.create = function create(properties) {
            return new PB_SCRoleExpChange(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleExpChange message. Does not implicitly {@link PB_SCRoleExpChange.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleExpChange
         * @static
         * @param {IPB_SCRoleExpChange} message PB_SCRoleExpChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleExpChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.changeExp != null && Object.hasOwnProperty.call(message, "changeExp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.changeExp);
            if (message.curExp != null && Object.hasOwnProperty.call(message, "curExp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.curExp);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleExpChange message, length delimited. Does not implicitly {@link PB_SCRoleExpChange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleExpChange
         * @static
         * @param {IPB_SCRoleExpChange} message PB_SCRoleExpChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleExpChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleExpChange message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleExpChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleExpChange} PB_SCRoleExpChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleExpChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleExpChange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.changeExp = reader.int64();
                    break;
                case 2:
                    message.curExp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleExpChange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleExpChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleExpChange} PB_SCRoleExpChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleExpChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleExpChange message.
         * @function verify
         * @memberof PB_SCRoleExpChange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleExpChange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.changeExp != null && message.hasOwnProperty("changeExp"))
                if (!$util.isInteger(message.changeExp) && !(message.changeExp && $util.isInteger(message.changeExp.low) && $util.isInteger(message.changeExp.high)))
                    return "changeExp: integer|Long expected";
            if (message.curExp != null && message.hasOwnProperty("curExp"))
                if (!$util.isInteger(message.curExp) && !(message.curExp && $util.isInteger(message.curExp.low) && $util.isInteger(message.curExp.high)))
                    return "curExp: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleExpChange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleExpChange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleExpChange} PB_SCRoleExpChange
         */
        PB_SCRoleExpChange.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleExpChange)
                return object;
            var message = new $root.PB_SCRoleExpChange();
            if (object.changeExp != null)
                if ($util.Long)
                    (message.changeExp = $util.Long.fromValue(object.changeExp)).unsigned = false;
                else if (typeof object.changeExp === "string")
                    message.changeExp = parseInt(object.changeExp, 10);
                else if (typeof object.changeExp === "number")
                    message.changeExp = object.changeExp;
                else if (typeof object.changeExp === "object")
                    message.changeExp = new $util.LongBits(object.changeExp.low >>> 0, object.changeExp.high >>> 0).toNumber();
            if (object.curExp != null)
                if ($util.Long)
                    (message.curExp = $util.Long.fromValue(object.curExp)).unsigned = false;
                else if (typeof object.curExp === "string")
                    message.curExp = parseInt(object.curExp, 10);
                else if (typeof object.curExp === "number")
                    message.curExp = object.curExp;
                else if (typeof object.curExp === "object")
                    message.curExp = new $util.LongBits(object.curExp.low >>> 0, object.curExp.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleExpChange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleExpChange
         * @static
         * @param {PB_SCRoleExpChange} message PB_SCRoleExpChange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleExpChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.changeExp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.changeExp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.curExp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.curExp = options.longs === String ? "0" : 0;
            }
            if (message.changeExp != null && message.hasOwnProperty("changeExp"))
                if (typeof message.changeExp === "number")
                    object.changeExp = options.longs === String ? String(message.changeExp) : message.changeExp;
                else
                    object.changeExp = options.longs === String ? $util.Long.prototype.toString.call(message.changeExp) : options.longs === Number ? new $util.LongBits(message.changeExp.low >>> 0, message.changeExp.high >>> 0).toNumber() : message.changeExp;
            if (message.curExp != null && message.hasOwnProperty("curExp"))
                if (typeof message.curExp === "number")
                    object.curExp = options.longs === String ? String(message.curExp) : message.curExp;
                else
                    object.curExp = options.longs === String ? $util.Long.prototype.toString.call(message.curExp) : options.longs === Number ? new $util.LongBits(message.curExp.low >>> 0, message.curExp.high >>> 0).toNumber() : message.curExp;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleExpChange to JSON.
         * @function toJSON
         * @memberof PB_SCRoleExpChange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleExpChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleExpChange;
    })();
    
    $root.PB_SCRoleLevelChange = (function() {
    
        /**
         * Properties of a PB_SCRoleLevelChange.
         * @exports IPB_SCRoleLevelChange
         * @interface IPB_SCRoleLevelChange
         * @property {number|null} [level] PB_SCRoleLevelChange level
         * @property {number|Long|null} [exp] PB_SCRoleLevelChange exp
         */
    
        /**
         * Constructs a new PB_SCRoleLevelChange.
         * @exports PB_SCRoleLevelChange
         * @classdesc Represents a PB_SCRoleLevelChange.
         * @implements IPB_SCRoleLevelChange
         * @constructor
         * @param {IPB_SCRoleLevelChange=} [properties] Properties to set
         */
        function PB_SCRoleLevelChange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleLevelChange level.
         * @member {number} level
         * @memberof PB_SCRoleLevelChange
         * @instance
         */
        PB_SCRoleLevelChange.prototype.level = 0;
    
        /**
         * PB_SCRoleLevelChange exp.
         * @member {number|Long} exp
         * @memberof PB_SCRoleLevelChange
         * @instance
         */
        PB_SCRoleLevelChange.prototype.exp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCRoleLevelChange instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleLevelChange
         * @static
         * @param {IPB_SCRoleLevelChange=} [properties] Properties to set
         * @returns {PB_SCRoleLevelChange} PB_SCRoleLevelChange instance
         */
        PB_SCRoleLevelChange.create = function create(properties) {
            return new PB_SCRoleLevelChange(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleLevelChange message. Does not implicitly {@link PB_SCRoleLevelChange.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleLevelChange
         * @static
         * @param {IPB_SCRoleLevelChange} message PB_SCRoleLevelChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleLevelChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.exp);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleLevelChange message, length delimited. Does not implicitly {@link PB_SCRoleLevelChange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleLevelChange
         * @static
         * @param {IPB_SCRoleLevelChange} message PB_SCRoleLevelChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleLevelChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleLevelChange message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleLevelChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleLevelChange} PB_SCRoleLevelChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleLevelChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleLevelChange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.level = reader.int32();
                    break;
                case 2:
                    message.exp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleLevelChange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleLevelChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleLevelChange} PB_SCRoleLevelChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleLevelChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleLevelChange message.
         * @function verify
         * @memberof PB_SCRoleLevelChange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleLevelChange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp) && !(message.exp && $util.isInteger(message.exp.low) && $util.isInteger(message.exp.high)))
                    return "exp: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleLevelChange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleLevelChange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleLevelChange} PB_SCRoleLevelChange
         */
        PB_SCRoleLevelChange.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleLevelChange)
                return object;
            var message = new $root.PB_SCRoleLevelChange();
            if (object.level != null)
                message.level = object.level | 0;
            if (object.exp != null)
                if ($util.Long)
                    (message.exp = $util.Long.fromValue(object.exp)).unsigned = false;
                else if (typeof object.exp === "string")
                    message.exp = parseInt(object.exp, 10);
                else if (typeof object.exp === "number")
                    message.exp = object.exp;
                else if (typeof object.exp === "object")
                    message.exp = new $util.LongBits(object.exp.low >>> 0, object.exp.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleLevelChange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleLevelChange
         * @static
         * @param {PB_SCRoleLevelChange} message PB_SCRoleLevelChange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleLevelChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.level = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exp = options.longs === String ? "0" : 0;
            }
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (typeof message.exp === "number")
                    object.exp = options.longs === String ? String(message.exp) : message.exp;
                else
                    object.exp = options.longs === String ? $util.Long.prototype.toString.call(message.exp) : options.longs === Number ? new $util.LongBits(message.exp.low >>> 0, message.exp.high >>> 0).toNumber() : message.exp;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleLevelChange to JSON.
         * @function toJSON
         * @memberof PB_SCRoleLevelChange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleLevelChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleLevelChange;
    })();
    
    $root.PB_CSAllInfoReq = (function() {
    
        /**
         * Properties of a PB_CSAllInfoReq.
         * @exports IPB_CSAllInfoReq
         * @interface IPB_CSAllInfoReq
         * @property {number|null} [reserve] PB_CSAllInfoReq reserve
         */
    
        /**
         * Constructs a new PB_CSAllInfoReq.
         * @exports PB_CSAllInfoReq
         * @classdesc Represents a PB_CSAllInfoReq.
         * @implements IPB_CSAllInfoReq
         * @constructor
         * @param {IPB_CSAllInfoReq=} [properties] Properties to set
         */
        function PB_CSAllInfoReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSAllInfoReq reserve.
         * @member {number} reserve
         * @memberof PB_CSAllInfoReq
         * @instance
         */
        PB_CSAllInfoReq.prototype.reserve = 0;
    
        /**
         * Creates a new PB_CSAllInfoReq instance using the specified properties.
         * @function create
         * @memberof PB_CSAllInfoReq
         * @static
         * @param {IPB_CSAllInfoReq=} [properties] Properties to set
         * @returns {PB_CSAllInfoReq} PB_CSAllInfoReq instance
         */
        PB_CSAllInfoReq.create = function create(properties) {
            return new PB_CSAllInfoReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSAllInfoReq message. Does not implicitly {@link PB_CSAllInfoReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSAllInfoReq
         * @static
         * @param {IPB_CSAllInfoReq} message PB_CSAllInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSAllInfoReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reserve != null && Object.hasOwnProperty.call(message, "reserve"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reserve);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSAllInfoReq message, length delimited. Does not implicitly {@link PB_CSAllInfoReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSAllInfoReq
         * @static
         * @param {IPB_CSAllInfoReq} message PB_CSAllInfoReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSAllInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSAllInfoReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSAllInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSAllInfoReq} PB_CSAllInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSAllInfoReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSAllInfoReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reserve = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSAllInfoReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSAllInfoReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSAllInfoReq} PB_CSAllInfoReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSAllInfoReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSAllInfoReq message.
         * @function verify
         * @memberof PB_CSAllInfoReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSAllInfoReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                if (!$util.isInteger(message.reserve))
                    return "reserve: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSAllInfoReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSAllInfoReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSAllInfoReq} PB_CSAllInfoReq
         */
        PB_CSAllInfoReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSAllInfoReq)
                return object;
            var message = new $root.PB_CSAllInfoReq();
            if (object.reserve != null)
                message.reserve = object.reserve | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSAllInfoReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSAllInfoReq
         * @static
         * @param {PB_CSAllInfoReq} message PB_CSAllInfoReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSAllInfoReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reserve = 0;
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                object.reserve = message.reserve;
            return object;
        };
    
        /**
         * Converts this PB_CSAllInfoReq to JSON.
         * @function toJSON
         * @memberof PB_CSAllInfoReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSAllInfoReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSAllInfoReq;
    })();
    
    $root.PB_CSRoleOtherOperReq = (function() {
    
        /**
         * Properties of a PB_CSRoleOtherOperReq.
         * @exports IPB_CSRoleOtherOperReq
         * @interface IPB_CSRoleOtherOperReq
         * @property {number|null} [type] PB_CSRoleOtherOperReq type
         * @property {Array.<number>|null} [param] PB_CSRoleOtherOperReq param
         */
    
        /**
         * Constructs a new PB_CSRoleOtherOperReq.
         * @exports PB_CSRoleOtherOperReq
         * @classdesc Represents a PB_CSRoleOtherOperReq.
         * @implements IPB_CSRoleOtherOperReq
         * @constructor
         * @param {IPB_CSRoleOtherOperReq=} [properties] Properties to set
         */
        function PB_CSRoleOtherOperReq(properties) {
            this.param = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSRoleOtherOperReq type.
         * @member {number} type
         * @memberof PB_CSRoleOtherOperReq
         * @instance
         */
        PB_CSRoleOtherOperReq.prototype.type = 0;
    
        /**
         * PB_CSRoleOtherOperReq param.
         * @member {Array.<number>} param
         * @memberof PB_CSRoleOtherOperReq
         * @instance
         */
        PB_CSRoleOtherOperReq.prototype.param = $util.emptyArray;
    
        /**
         * Creates a new PB_CSRoleOtherOperReq instance using the specified properties.
         * @function create
         * @memberof PB_CSRoleOtherOperReq
         * @static
         * @param {IPB_CSRoleOtherOperReq=} [properties] Properties to set
         * @returns {PB_CSRoleOtherOperReq} PB_CSRoleOtherOperReq instance
         */
        PB_CSRoleOtherOperReq.create = function create(properties) {
            return new PB_CSRoleOtherOperReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSRoleOtherOperReq message. Does not implicitly {@link PB_CSRoleOtherOperReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSRoleOtherOperReq
         * @static
         * @param {IPB_CSRoleOtherOperReq} message PB_CSRoleOtherOperReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleOtherOperReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.param != null && message.param.length)
                for (var i = 0; i < message.param.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.param[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSRoleOtherOperReq message, length delimited. Does not implicitly {@link PB_CSRoleOtherOperReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSRoleOtherOperReq
         * @static
         * @param {IPB_CSRoleOtherOperReq} message PB_CSRoleOtherOperReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleOtherOperReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSRoleOtherOperReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSRoleOtherOperReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSRoleOtherOperReq} PB_CSRoleOtherOperReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleOtherOperReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSRoleOtherOperReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSRoleOtherOperReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSRoleOtherOperReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSRoleOtherOperReq} PB_CSRoleOtherOperReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleOtherOperReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSRoleOtherOperReq message.
         * @function verify
         * @memberof PB_CSRoleOtherOperReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSRoleOtherOperReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (var i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSRoleOtherOperReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSRoleOtherOperReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSRoleOtherOperReq} PB_CSRoleOtherOperReq
         */
        PB_CSRoleOtherOperReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSRoleOtherOperReq)
                return object;
            var message = new $root.PB_CSRoleOtherOperReq();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".PB_CSRoleOtherOperReq.param: array expected");
                message.param = [];
                for (var i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSRoleOtherOperReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSRoleOtherOperReq
         * @static
         * @param {PB_CSRoleOtherOperReq} message PB_CSRoleOtherOperReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSRoleOtherOperReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.param = [];
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.param && message.param.length) {
                object.param = [];
                for (var j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSRoleOtherOperReq to JSON.
         * @function toJSON
         * @memberof PB_CSRoleOtherOperReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSRoleOtherOperReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSRoleOtherOperReq;
    })();
    
    $root.PB_SCRoleZhuoMianReward = (function() {
    
        /**
         * Properties of a PB_SCRoleZhuoMianReward.
         * @exports IPB_SCRoleZhuoMianReward
         * @interface IPB_SCRoleZhuoMianReward
         * @property {boolean|null} [isFetch] PB_SCRoleZhuoMianReward isFetch
         */
    
        /**
         * Constructs a new PB_SCRoleZhuoMianReward.
         * @exports PB_SCRoleZhuoMianReward
         * @classdesc Represents a PB_SCRoleZhuoMianReward.
         * @implements IPB_SCRoleZhuoMianReward
         * @constructor
         * @param {IPB_SCRoleZhuoMianReward=} [properties] Properties to set
         */
        function PB_SCRoleZhuoMianReward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleZhuoMianReward isFetch.
         * @member {boolean} isFetch
         * @memberof PB_SCRoleZhuoMianReward
         * @instance
         */
        PB_SCRoleZhuoMianReward.prototype.isFetch = false;
    
        /**
         * Creates a new PB_SCRoleZhuoMianReward instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleZhuoMianReward
         * @static
         * @param {IPB_SCRoleZhuoMianReward=} [properties] Properties to set
         * @returns {PB_SCRoleZhuoMianReward} PB_SCRoleZhuoMianReward instance
         */
        PB_SCRoleZhuoMianReward.create = function create(properties) {
            return new PB_SCRoleZhuoMianReward(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleZhuoMianReward message. Does not implicitly {@link PB_SCRoleZhuoMianReward.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleZhuoMianReward
         * @static
         * @param {IPB_SCRoleZhuoMianReward} message PB_SCRoleZhuoMianReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleZhuoMianReward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isFetch != null && Object.hasOwnProperty.call(message, "isFetch"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isFetch);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleZhuoMianReward message, length delimited. Does not implicitly {@link PB_SCRoleZhuoMianReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleZhuoMianReward
         * @static
         * @param {IPB_SCRoleZhuoMianReward} message PB_SCRoleZhuoMianReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleZhuoMianReward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleZhuoMianReward message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleZhuoMianReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleZhuoMianReward} PB_SCRoleZhuoMianReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleZhuoMianReward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleZhuoMianReward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isFetch = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleZhuoMianReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleZhuoMianReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleZhuoMianReward} PB_SCRoleZhuoMianReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleZhuoMianReward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleZhuoMianReward message.
         * @function verify
         * @memberof PB_SCRoleZhuoMianReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleZhuoMianReward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                if (typeof message.isFetch !== "boolean")
                    return "isFetch: boolean expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleZhuoMianReward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleZhuoMianReward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleZhuoMianReward} PB_SCRoleZhuoMianReward
         */
        PB_SCRoleZhuoMianReward.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleZhuoMianReward)
                return object;
            var message = new $root.PB_SCRoleZhuoMianReward();
            if (object.isFetch != null)
                message.isFetch = Boolean(object.isFetch);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleZhuoMianReward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleZhuoMianReward
         * @static
         * @param {PB_SCRoleZhuoMianReward} message PB_SCRoleZhuoMianReward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleZhuoMianReward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isFetch = false;
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                object.isFetch = message.isFetch;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleZhuoMianReward to JSON.
         * @function toJSON
         * @memberof PB_SCRoleZhuoMianReward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleZhuoMianReward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleZhuoMianReward;
    })();
    
    $root.PB_system_set = (function() {
    
        /**
         * Properties of a PB_system_set.
         * @exports IPB_system_set
         * @interface IPB_system_set
         * @property {number|null} [systemSetType] PB_system_set systemSetType
         * @property {number|null} [systemSetParam] PB_system_set systemSetParam
         */
    
        /**
         * Constructs a new PB_system_set.
         * @exports PB_system_set
         * @classdesc Represents a PB_system_set.
         * @implements IPB_system_set
         * @constructor
         * @param {IPB_system_set=} [properties] Properties to set
         */
        function PB_system_set(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_system_set systemSetType.
         * @member {number} systemSetType
         * @memberof PB_system_set
         * @instance
         */
        PB_system_set.prototype.systemSetType = 0;
    
        /**
         * PB_system_set systemSetParam.
         * @member {number} systemSetParam
         * @memberof PB_system_set
         * @instance
         */
        PB_system_set.prototype.systemSetParam = 0;
    
        /**
         * Creates a new PB_system_set instance using the specified properties.
         * @function create
         * @memberof PB_system_set
         * @static
         * @param {IPB_system_set=} [properties] Properties to set
         * @returns {PB_system_set} PB_system_set instance
         */
        PB_system_set.create = function create(properties) {
            return new PB_system_set(properties);
        };
    
        /**
         * Encodes the specified PB_system_set message. Does not implicitly {@link PB_system_set.verify|verify} messages.
         * @function encode
         * @memberof PB_system_set
         * @static
         * @param {IPB_system_set} message PB_system_set message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_system_set.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.systemSetType != null && Object.hasOwnProperty.call(message, "systemSetType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.systemSetType);
            if (message.systemSetParam != null && Object.hasOwnProperty.call(message, "systemSetParam"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.systemSetParam);
            return writer;
        };
    
        /**
         * Encodes the specified PB_system_set message, length delimited. Does not implicitly {@link PB_system_set.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_system_set
         * @static
         * @param {IPB_system_set} message PB_system_set message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_system_set.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_system_set message from the specified reader or buffer.
         * @function decode
         * @memberof PB_system_set
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_system_set} PB_system_set
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_system_set.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_system_set();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.systemSetType = reader.int32();
                    break;
                case 2:
                    message.systemSetParam = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_system_set message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_system_set
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_system_set} PB_system_set
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_system_set.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_system_set message.
         * @function verify
         * @memberof PB_system_set
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_system_set.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.systemSetType != null && message.hasOwnProperty("systemSetType"))
                if (!$util.isInteger(message.systemSetType))
                    return "systemSetType: integer expected";
            if (message.systemSetParam != null && message.hasOwnProperty("systemSetParam"))
                if (!$util.isInteger(message.systemSetParam))
                    return "systemSetParam: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_system_set message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_system_set
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_system_set} PB_system_set
         */
        PB_system_set.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_system_set)
                return object;
            var message = new $root.PB_system_set();
            if (object.systemSetType != null)
                message.systemSetType = object.systemSetType | 0;
            if (object.systemSetParam != null)
                message.systemSetParam = object.systemSetParam | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_system_set message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_system_set
         * @static
         * @param {PB_system_set} message PB_system_set
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_system_set.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.systemSetType = 0;
                object.systemSetParam = 0;
            }
            if (message.systemSetType != null && message.hasOwnProperty("systemSetType"))
                object.systemSetType = message.systemSetType;
            if (message.systemSetParam != null && message.hasOwnProperty("systemSetParam"))
                object.systemSetParam = message.systemSetParam;
            return object;
        };
    
        /**
         * Converts this PB_system_set to JSON.
         * @function toJSON
         * @memberof PB_system_set
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_system_set.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_system_set;
    })();
    
    $root.PB_CSRoleSystemSetReq = (function() {
    
        /**
         * Properties of a PB_CSRoleSystemSetReq.
         * @exports IPB_CSRoleSystemSetReq
         * @interface IPB_CSRoleSystemSetReq
         * @property {Array.<IPB_system_set>|null} [systemSetList] PB_CSRoleSystemSetReq systemSetList
         */
    
        /**
         * Constructs a new PB_CSRoleSystemSetReq.
         * @exports PB_CSRoleSystemSetReq
         * @classdesc Represents a PB_CSRoleSystemSetReq.
         * @implements IPB_CSRoleSystemSetReq
         * @constructor
         * @param {IPB_CSRoleSystemSetReq=} [properties] Properties to set
         */
        function PB_CSRoleSystemSetReq(properties) {
            this.systemSetList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSRoleSystemSetReq systemSetList.
         * @member {Array.<IPB_system_set>} systemSetList
         * @memberof PB_CSRoleSystemSetReq
         * @instance
         */
        PB_CSRoleSystemSetReq.prototype.systemSetList = $util.emptyArray;
    
        /**
         * Creates a new PB_CSRoleSystemSetReq instance using the specified properties.
         * @function create
         * @memberof PB_CSRoleSystemSetReq
         * @static
         * @param {IPB_CSRoleSystemSetReq=} [properties] Properties to set
         * @returns {PB_CSRoleSystemSetReq} PB_CSRoleSystemSetReq instance
         */
        PB_CSRoleSystemSetReq.create = function create(properties) {
            return new PB_CSRoleSystemSetReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSRoleSystemSetReq message. Does not implicitly {@link PB_CSRoleSystemSetReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSRoleSystemSetReq
         * @static
         * @param {IPB_CSRoleSystemSetReq} message PB_CSRoleSystemSetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleSystemSetReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.systemSetList != null && message.systemSetList.length)
                for (var i = 0; i < message.systemSetList.length; ++i)
                    $root.PB_system_set.encode(message.systemSetList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSRoleSystemSetReq message, length delimited. Does not implicitly {@link PB_CSRoleSystemSetReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSRoleSystemSetReq
         * @static
         * @param {IPB_CSRoleSystemSetReq} message PB_CSRoleSystemSetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleSystemSetReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSRoleSystemSetReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSRoleSystemSetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSRoleSystemSetReq} PB_CSRoleSystemSetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleSystemSetReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSRoleSystemSetReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.systemSetList && message.systemSetList.length))
                        message.systemSetList = [];
                    message.systemSetList.push($root.PB_system_set.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSRoleSystemSetReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSRoleSystemSetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSRoleSystemSetReq} PB_CSRoleSystemSetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleSystemSetReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSRoleSystemSetReq message.
         * @function verify
         * @memberof PB_CSRoleSystemSetReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSRoleSystemSetReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.systemSetList != null && message.hasOwnProperty("systemSetList")) {
                if (!Array.isArray(message.systemSetList))
                    return "systemSetList: array expected";
                for (var i = 0; i < message.systemSetList.length; ++i) {
                    var error = $root.PB_system_set.verify(message.systemSetList[i]);
                    if (error)
                        return "systemSetList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_CSRoleSystemSetReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSRoleSystemSetReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSRoleSystemSetReq} PB_CSRoleSystemSetReq
         */
        PB_CSRoleSystemSetReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSRoleSystemSetReq)
                return object;
            var message = new $root.PB_CSRoleSystemSetReq();
            if (object.systemSetList) {
                if (!Array.isArray(object.systemSetList))
                    throw TypeError(".PB_CSRoleSystemSetReq.systemSetList: array expected");
                message.systemSetList = [];
                for (var i = 0; i < object.systemSetList.length; ++i) {
                    if (typeof object.systemSetList[i] !== "object")
                        throw TypeError(".PB_CSRoleSystemSetReq.systemSetList: object expected");
                    message.systemSetList[i] = $root.PB_system_set.fromObject(object.systemSetList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSRoleSystemSetReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSRoleSystemSetReq
         * @static
         * @param {PB_CSRoleSystemSetReq} message PB_CSRoleSystemSetReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSRoleSystemSetReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.systemSetList = [];
            if (message.systemSetList && message.systemSetList.length) {
                object.systemSetList = [];
                for (var j = 0; j < message.systemSetList.length; ++j)
                    object.systemSetList[j] = $root.PB_system_set.toObject(message.systemSetList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_CSRoleSystemSetReq to JSON.
         * @function toJSON
         * @memberof PB_CSRoleSystemSetReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSRoleSystemSetReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSRoleSystemSetReq;
    })();
    
    $root.PB_SCRoleSystemSetInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleSystemSetInfo.
         * @exports IPB_SCRoleSystemSetInfo
         * @interface IPB_SCRoleSystemSetInfo
         * @property {Array.<IPB_system_set>|null} [systemSetList] PB_SCRoleSystemSetInfo systemSetList
         */
    
        /**
         * Constructs a new PB_SCRoleSystemSetInfo.
         * @exports PB_SCRoleSystemSetInfo
         * @classdesc Represents a PB_SCRoleSystemSetInfo.
         * @implements IPB_SCRoleSystemSetInfo
         * @constructor
         * @param {IPB_SCRoleSystemSetInfo=} [properties] Properties to set
         */
        function PB_SCRoleSystemSetInfo(properties) {
            this.systemSetList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleSystemSetInfo systemSetList.
         * @member {Array.<IPB_system_set>} systemSetList
         * @memberof PB_SCRoleSystemSetInfo
         * @instance
         */
        PB_SCRoleSystemSetInfo.prototype.systemSetList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRoleSystemSetInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleSystemSetInfo
         * @static
         * @param {IPB_SCRoleSystemSetInfo=} [properties] Properties to set
         * @returns {PB_SCRoleSystemSetInfo} PB_SCRoleSystemSetInfo instance
         */
        PB_SCRoleSystemSetInfo.create = function create(properties) {
            return new PB_SCRoleSystemSetInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleSystemSetInfo message. Does not implicitly {@link PB_SCRoleSystemSetInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleSystemSetInfo
         * @static
         * @param {IPB_SCRoleSystemSetInfo} message PB_SCRoleSystemSetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleSystemSetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.systemSetList != null && message.systemSetList.length)
                for (var i = 0; i < message.systemSetList.length; ++i)
                    $root.PB_system_set.encode(message.systemSetList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleSystemSetInfo message, length delimited. Does not implicitly {@link PB_SCRoleSystemSetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleSystemSetInfo
         * @static
         * @param {IPB_SCRoleSystemSetInfo} message PB_SCRoleSystemSetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleSystemSetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleSystemSetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleSystemSetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleSystemSetInfo} PB_SCRoleSystemSetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleSystemSetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleSystemSetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.systemSetList && message.systemSetList.length))
                        message.systemSetList = [];
                    message.systemSetList.push($root.PB_system_set.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleSystemSetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleSystemSetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleSystemSetInfo} PB_SCRoleSystemSetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleSystemSetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleSystemSetInfo message.
         * @function verify
         * @memberof PB_SCRoleSystemSetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleSystemSetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.systemSetList != null && message.hasOwnProperty("systemSetList")) {
                if (!Array.isArray(message.systemSetList))
                    return "systemSetList: array expected";
                for (var i = 0; i < message.systemSetList.length; ++i) {
                    var error = $root.PB_system_set.verify(message.systemSetList[i]);
                    if (error)
                        return "systemSetList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRoleSystemSetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleSystemSetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleSystemSetInfo} PB_SCRoleSystemSetInfo
         */
        PB_SCRoleSystemSetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleSystemSetInfo)
                return object;
            var message = new $root.PB_SCRoleSystemSetInfo();
            if (object.systemSetList) {
                if (!Array.isArray(object.systemSetList))
                    throw TypeError(".PB_SCRoleSystemSetInfo.systemSetList: array expected");
                message.systemSetList = [];
                for (var i = 0; i < object.systemSetList.length; ++i) {
                    if (typeof object.systemSetList[i] !== "object")
                        throw TypeError(".PB_SCRoleSystemSetInfo.systemSetList: object expected");
                    message.systemSetList[i] = $root.PB_system_set.fromObject(object.systemSetList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleSystemSetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleSystemSetInfo
         * @static
         * @param {PB_SCRoleSystemSetInfo} message PB_SCRoleSystemSetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleSystemSetInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.systemSetList = [];
            if (message.systemSetList && message.systemSetList.length) {
                object.systemSetList = [];
                for (var j = 0; j < message.systemSetList.length; ++j)
                    object.systemSetList[j] = $root.PB_system_set.toObject(message.systemSetList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRoleSystemSetInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleSystemSetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleSystemSetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleSystemSetInfo;
    })();
    
    $root.PB_CSRoleWXInfoSetReq = (function() {
    
        /**
         * Properties of a PB_CSRoleWXInfoSetReq.
         * @exports IPB_CSRoleWXInfoSetReq
         * @interface IPB_CSRoleWXInfoSetReq
         * @property {Uint8Array|null} [name] PB_CSRoleWXInfoSetReq name
         * @property {Uint8Array|null} [headChar] PB_CSRoleWXInfoSetReq headChar
         * @property {boolean|null} [isWx] PB_CSRoleWXInfoSetReq isWx
         */
    
        /**
         * Constructs a new PB_CSRoleWXInfoSetReq.
         * @exports PB_CSRoleWXInfoSetReq
         * @classdesc Represents a PB_CSRoleWXInfoSetReq.
         * @implements IPB_CSRoleWXInfoSetReq
         * @constructor
         * @param {IPB_CSRoleWXInfoSetReq=} [properties] Properties to set
         */
        function PB_CSRoleWXInfoSetReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSRoleWXInfoSetReq name.
         * @member {Uint8Array} name
         * @memberof PB_CSRoleWXInfoSetReq
         * @instance
         */
        PB_CSRoleWXInfoSetReq.prototype.name = $util.newBuffer([]);
    
        /**
         * PB_CSRoleWXInfoSetReq headChar.
         * @member {Uint8Array} headChar
         * @memberof PB_CSRoleWXInfoSetReq
         * @instance
         */
        PB_CSRoleWXInfoSetReq.prototype.headChar = $util.newBuffer([]);
    
        /**
         * PB_CSRoleWXInfoSetReq isWx.
         * @member {boolean} isWx
         * @memberof PB_CSRoleWXInfoSetReq
         * @instance
         */
        PB_CSRoleWXInfoSetReq.prototype.isWx = false;
    
        /**
         * Creates a new PB_CSRoleWXInfoSetReq instance using the specified properties.
         * @function create
         * @memberof PB_CSRoleWXInfoSetReq
         * @static
         * @param {IPB_CSRoleWXInfoSetReq=} [properties] Properties to set
         * @returns {PB_CSRoleWXInfoSetReq} PB_CSRoleWXInfoSetReq instance
         */
        PB_CSRoleWXInfoSetReq.create = function create(properties) {
            return new PB_CSRoleWXInfoSetReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSRoleWXInfoSetReq message. Does not implicitly {@link PB_CSRoleWXInfoSetReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSRoleWXInfoSetReq
         * @static
         * @param {IPB_CSRoleWXInfoSetReq} message PB_CSRoleWXInfoSetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleWXInfoSetReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.name);
            if (message.headChar != null && Object.hasOwnProperty.call(message, "headChar"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.headChar);
            if (message.isWx != null && Object.hasOwnProperty.call(message, "isWx"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isWx);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSRoleWXInfoSetReq message, length delimited. Does not implicitly {@link PB_CSRoleWXInfoSetReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSRoleWXInfoSetReq
         * @static
         * @param {IPB_CSRoleWXInfoSetReq} message PB_CSRoleWXInfoSetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleWXInfoSetReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSRoleWXInfoSetReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSRoleWXInfoSetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSRoleWXInfoSetReq} PB_CSRoleWXInfoSetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleWXInfoSetReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSRoleWXInfoSetReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.bytes();
                    break;
                case 2:
                    message.headChar = reader.bytes();
                    break;
                case 3:
                    message.isWx = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSRoleWXInfoSetReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSRoleWXInfoSetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSRoleWXInfoSetReq} PB_CSRoleWXInfoSetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleWXInfoSetReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSRoleWXInfoSetReq message.
         * @function verify
         * @memberof PB_CSRoleWXInfoSetReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSRoleWXInfoSetReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.headChar != null && message.hasOwnProperty("headChar"))
                if (!(message.headChar && typeof message.headChar.length === "number" || $util.isString(message.headChar)))
                    return "headChar: buffer expected";
            if (message.isWx != null && message.hasOwnProperty("isWx"))
                if (typeof message.isWx !== "boolean")
                    return "isWx: boolean expected";
            return null;
        };
    
        /**
         * Creates a PB_CSRoleWXInfoSetReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSRoleWXInfoSetReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSRoleWXInfoSetReq} PB_CSRoleWXInfoSetReq
         */
        PB_CSRoleWXInfoSetReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSRoleWXInfoSetReq)
                return object;
            var message = new $root.PB_CSRoleWXInfoSetReq();
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.headChar != null)
                if (typeof object.headChar === "string")
                    $util.base64.decode(object.headChar, message.headChar = $util.newBuffer($util.base64.length(object.headChar)), 0);
                else if (object.headChar.length)
                    message.headChar = object.headChar;
            if (object.isWx != null)
                message.isWx = Boolean(object.isWx);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSRoleWXInfoSetReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSRoleWXInfoSetReq
         * @static
         * @param {PB_CSRoleWXInfoSetReq} message PB_CSRoleWXInfoSetReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSRoleWXInfoSetReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                if (options.bytes === String)
                    object.headChar = "";
                else {
                    object.headChar = [];
                    if (options.bytes !== Array)
                        object.headChar = $util.newBuffer(object.headChar);
                }
                object.isWx = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.headChar != null && message.hasOwnProperty("headChar"))
                object.headChar = options.bytes === String ? $util.base64.encode(message.headChar, 0, message.headChar.length) : options.bytes === Array ? Array.prototype.slice.call(message.headChar) : message.headChar;
            if (message.isWx != null && message.hasOwnProperty("isWx"))
                object.isWx = message.isWx;
            return object;
        };
    
        /**
         * Converts this PB_CSRoleWXInfoSetReq to JSON.
         * @function toJSON
         * @memberof PB_CSRoleWXInfoSetReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSRoleWXInfoSetReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSRoleWXInfoSetReq;
    })();
    
    $root.PB_CSRoleResetReq = (function() {
    
        /**
         * Properties of a PB_CSRoleResetReq.
         * @exports IPB_CSRoleResetReq
         * @interface IPB_CSRoleResetReq
         */
    
        /**
         * Constructs a new PB_CSRoleResetReq.
         * @exports PB_CSRoleResetReq
         * @classdesc Represents a PB_CSRoleResetReq.
         * @implements IPB_CSRoleResetReq
         * @constructor
         * @param {IPB_CSRoleResetReq=} [properties] Properties to set
         */
        function PB_CSRoleResetReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new PB_CSRoleResetReq instance using the specified properties.
         * @function create
         * @memberof PB_CSRoleResetReq
         * @static
         * @param {IPB_CSRoleResetReq=} [properties] Properties to set
         * @returns {PB_CSRoleResetReq} PB_CSRoleResetReq instance
         */
        PB_CSRoleResetReq.create = function create(properties) {
            return new PB_CSRoleResetReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSRoleResetReq message. Does not implicitly {@link PB_CSRoleResetReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSRoleResetReq
         * @static
         * @param {IPB_CSRoleResetReq} message PB_CSRoleResetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleResetReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSRoleResetReq message, length delimited. Does not implicitly {@link PB_CSRoleResetReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSRoleResetReq
         * @static
         * @param {IPB_CSRoleResetReq} message PB_CSRoleResetReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleResetReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSRoleResetReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSRoleResetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSRoleResetReq} PB_CSRoleResetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleResetReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSRoleResetReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSRoleResetReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSRoleResetReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSRoleResetReq} PB_CSRoleResetReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleResetReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSRoleResetReq message.
         * @function verify
         * @memberof PB_CSRoleResetReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSRoleResetReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a PB_CSRoleResetReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSRoleResetReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSRoleResetReq} PB_CSRoleResetReq
         */
        PB_CSRoleResetReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSRoleResetReq)
                return object;
            return new $root.PB_CSRoleResetReq();
        };
    
        /**
         * Creates a plain object from a PB_CSRoleResetReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSRoleResetReq
         * @static
         * @param {PB_CSRoleResetReq} message PB_CSRoleResetReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSRoleResetReq.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this PB_CSRoleResetReq to JSON.
         * @function toJSON
         * @memberof PB_CSRoleResetReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSRoleResetReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSRoleResetReq;
    })();
    
    $root.PB_CSRoleSetHeadFrame = (function() {
    
        /**
         * Properties of a PB_CSRoleSetHeadFrame.
         * @exports IPB_CSRoleSetHeadFrame
         * @interface IPB_CSRoleSetHeadFrame
         * @property {number|null} [id] PB_CSRoleSetHeadFrame id
         * @property {number|null} [headId] PB_CSRoleSetHeadFrame headId
         */
    
        /**
         * Constructs a new PB_CSRoleSetHeadFrame.
         * @exports PB_CSRoleSetHeadFrame
         * @classdesc Represents a PB_CSRoleSetHeadFrame.
         * @implements IPB_CSRoleSetHeadFrame
         * @constructor
         * @param {IPB_CSRoleSetHeadFrame=} [properties] Properties to set
         */
        function PB_CSRoleSetHeadFrame(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSRoleSetHeadFrame id.
         * @member {number} id
         * @memberof PB_CSRoleSetHeadFrame
         * @instance
         */
        PB_CSRoleSetHeadFrame.prototype.id = 0;
    
        /**
         * PB_CSRoleSetHeadFrame headId.
         * @member {number} headId
         * @memberof PB_CSRoleSetHeadFrame
         * @instance
         */
        PB_CSRoleSetHeadFrame.prototype.headId = 0;
    
        /**
         * Creates a new PB_CSRoleSetHeadFrame instance using the specified properties.
         * @function create
         * @memberof PB_CSRoleSetHeadFrame
         * @static
         * @param {IPB_CSRoleSetHeadFrame=} [properties] Properties to set
         * @returns {PB_CSRoleSetHeadFrame} PB_CSRoleSetHeadFrame instance
         */
        PB_CSRoleSetHeadFrame.create = function create(properties) {
            return new PB_CSRoleSetHeadFrame(properties);
        };
    
        /**
         * Encodes the specified PB_CSRoleSetHeadFrame message. Does not implicitly {@link PB_CSRoleSetHeadFrame.verify|verify} messages.
         * @function encode
         * @memberof PB_CSRoleSetHeadFrame
         * @static
         * @param {IPB_CSRoleSetHeadFrame} message PB_CSRoleSetHeadFrame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleSetHeadFrame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.headId != null && Object.hasOwnProperty.call(message, "headId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.headId);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSRoleSetHeadFrame message, length delimited. Does not implicitly {@link PB_CSRoleSetHeadFrame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSRoleSetHeadFrame
         * @static
         * @param {IPB_CSRoleSetHeadFrame} message PB_CSRoleSetHeadFrame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleSetHeadFrame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSRoleSetHeadFrame message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSRoleSetHeadFrame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSRoleSetHeadFrame} PB_CSRoleSetHeadFrame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleSetHeadFrame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSRoleSetHeadFrame();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.headId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSRoleSetHeadFrame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSRoleSetHeadFrame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSRoleSetHeadFrame} PB_CSRoleSetHeadFrame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleSetHeadFrame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSRoleSetHeadFrame message.
         * @function verify
         * @memberof PB_CSRoleSetHeadFrame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSRoleSetHeadFrame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.headId != null && message.hasOwnProperty("headId"))
                if (!$util.isInteger(message.headId))
                    return "headId: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSRoleSetHeadFrame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSRoleSetHeadFrame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSRoleSetHeadFrame} PB_CSRoleSetHeadFrame
         */
        PB_CSRoleSetHeadFrame.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSRoleSetHeadFrame)
                return object;
            var message = new $root.PB_CSRoleSetHeadFrame();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.headId != null)
                message.headId = object.headId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSRoleSetHeadFrame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSRoleSetHeadFrame
         * @static
         * @param {PB_CSRoleSetHeadFrame} message PB_CSRoleSetHeadFrame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSRoleSetHeadFrame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.headId = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.headId != null && message.hasOwnProperty("headId"))
                object.headId = message.headId;
            return object;
        };
    
        /**
         * Converts this PB_CSRoleSetHeadFrame to JSON.
         * @function toJSON
         * @memberof PB_CSRoleSetHeadFrame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSRoleSetHeadFrame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSRoleSetHeadFrame;
    })();
    
    $root.PB_RoleBaseInfo = (function() {
    
        /**
         * Properties of a PB_RoleBaseInfo.
         * @exports IPB_RoleBaseInfo
         * @interface IPB_RoleBaseInfo
         * @property {Uint8Array|null} [newName] PB_RoleBaseInfo newName
         * @property {number|null} [newSex] PB_RoleBaseInfo newSex
         * @property {number|Long|null} [newNameStrId] PB_RoleBaseInfo newNameStrId
         */
    
        /**
         * Constructs a new PB_RoleBaseInfo.
         * @exports PB_RoleBaseInfo
         * @classdesc Represents a PB_RoleBaseInfo.
         * @implements IPB_RoleBaseInfo
         * @constructor
         * @param {IPB_RoleBaseInfo=} [properties] Properties to set
         */
        function PB_RoleBaseInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RoleBaseInfo newName.
         * @member {Uint8Array} newName
         * @memberof PB_RoleBaseInfo
         * @instance
         */
        PB_RoleBaseInfo.prototype.newName = $util.newBuffer([]);
    
        /**
         * PB_RoleBaseInfo newSex.
         * @member {number} newSex
         * @memberof PB_RoleBaseInfo
         * @instance
         */
        PB_RoleBaseInfo.prototype.newSex = 0;
    
        /**
         * PB_RoleBaseInfo newNameStrId.
         * @member {number|Long} newNameStrId
         * @memberof PB_RoleBaseInfo
         * @instance
         */
        PB_RoleBaseInfo.prototype.newNameStrId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_RoleBaseInfo instance using the specified properties.
         * @function create
         * @memberof PB_RoleBaseInfo
         * @static
         * @param {IPB_RoleBaseInfo=} [properties] Properties to set
         * @returns {PB_RoleBaseInfo} PB_RoleBaseInfo instance
         */
        PB_RoleBaseInfo.create = function create(properties) {
            return new PB_RoleBaseInfo(properties);
        };
    
        /**
         * Encodes the specified PB_RoleBaseInfo message. Does not implicitly {@link PB_RoleBaseInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_RoleBaseInfo
         * @static
         * @param {IPB_RoleBaseInfo} message PB_RoleBaseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleBaseInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.newName != null && Object.hasOwnProperty.call(message, "newName"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.newName);
            if (message.newSex != null && Object.hasOwnProperty.call(message, "newSex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.newSex);
            if (message.newNameStrId != null && Object.hasOwnProperty.call(message, "newNameStrId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.newNameStrId);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RoleBaseInfo message, length delimited. Does not implicitly {@link PB_RoleBaseInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RoleBaseInfo
         * @static
         * @param {IPB_RoleBaseInfo} message PB_RoleBaseInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleBaseInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RoleBaseInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RoleBaseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RoleBaseInfo} PB_RoleBaseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleBaseInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RoleBaseInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newName = reader.bytes();
                    break;
                case 2:
                    message.newSex = reader.int32();
                    break;
                case 3:
                    message.newNameStrId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RoleBaseInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RoleBaseInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RoleBaseInfo} PB_RoleBaseInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleBaseInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RoleBaseInfo message.
         * @function verify
         * @memberof PB_RoleBaseInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RoleBaseInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.newName != null && message.hasOwnProperty("newName"))
                if (!(message.newName && typeof message.newName.length === "number" || $util.isString(message.newName)))
                    return "newName: buffer expected";
            if (message.newSex != null && message.hasOwnProperty("newSex"))
                if (!$util.isInteger(message.newSex))
                    return "newSex: integer expected";
            if (message.newNameStrId != null && message.hasOwnProperty("newNameStrId"))
                if (!$util.isInteger(message.newNameStrId) && !(message.newNameStrId && $util.isInteger(message.newNameStrId.low) && $util.isInteger(message.newNameStrId.high)))
                    return "newNameStrId: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_RoleBaseInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RoleBaseInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RoleBaseInfo} PB_RoleBaseInfo
         */
        PB_RoleBaseInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RoleBaseInfo)
                return object;
            var message = new $root.PB_RoleBaseInfo();
            if (object.newName != null)
                if (typeof object.newName === "string")
                    $util.base64.decode(object.newName, message.newName = $util.newBuffer($util.base64.length(object.newName)), 0);
                else if (object.newName.length)
                    message.newName = object.newName;
            if (object.newSex != null)
                message.newSex = object.newSex | 0;
            if (object.newNameStrId != null)
                if ($util.Long)
                    (message.newNameStrId = $util.Long.fromValue(object.newNameStrId)).unsigned = false;
                else if (typeof object.newNameStrId === "string")
                    message.newNameStrId = parseInt(object.newNameStrId, 10);
                else if (typeof object.newNameStrId === "number")
                    message.newNameStrId = object.newNameStrId;
                else if (typeof object.newNameStrId === "object")
                    message.newNameStrId = new $util.LongBits(object.newNameStrId.low >>> 0, object.newNameStrId.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RoleBaseInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RoleBaseInfo
         * @static
         * @param {PB_RoleBaseInfo} message PB_RoleBaseInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RoleBaseInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.newName = "";
                else {
                    object.newName = [];
                    if (options.bytes !== Array)
                        object.newName = $util.newBuffer(object.newName);
                }
                object.newSex = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.newNameStrId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.newNameStrId = options.longs === String ? "0" : 0;
            }
            if (message.newName != null && message.hasOwnProperty("newName"))
                object.newName = options.bytes === String ? $util.base64.encode(message.newName, 0, message.newName.length) : options.bytes === Array ? Array.prototype.slice.call(message.newName) : message.newName;
            if (message.newSex != null && message.hasOwnProperty("newSex"))
                object.newSex = message.newSex;
            if (message.newNameStrId != null && message.hasOwnProperty("newNameStrId"))
                if (typeof message.newNameStrId === "number")
                    object.newNameStrId = options.longs === String ? String(message.newNameStrId) : message.newNameStrId;
                else
                    object.newNameStrId = options.longs === String ? $util.Long.prototype.toString.call(message.newNameStrId) : options.longs === Number ? new $util.LongBits(message.newNameStrId.low >>> 0, message.newNameStrId.high >>> 0).toNumber() : message.newNameStrId;
            return object;
        };
    
        /**
         * Converts this PB_RoleBaseInfo to JSON.
         * @function toJSON
         * @memberof PB_RoleBaseInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RoleBaseInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RoleBaseInfo;
    })();
    
    $root.PB_CSRoleResetBaseReq = (function() {
    
        /**
         * Properties of a PB_CSRoleResetBaseReq.
         * @exports IPB_CSRoleResetBaseReq
         * @interface IPB_CSRoleResetBaseReq
         * @property {PB_CSRoleResetBaseReq.ReqType|null} [reqType] PB_CSRoleResetBaseReq reqType
         * @property {IPB_RoleBaseInfo|null} [newBaseInfo] PB_CSRoleResetBaseReq newBaseInfo
         */
    
        /**
         * Constructs a new PB_CSRoleResetBaseReq.
         * @exports PB_CSRoleResetBaseReq
         * @classdesc Represents a PB_CSRoleResetBaseReq.
         * @implements IPB_CSRoleResetBaseReq
         * @constructor
         * @param {IPB_CSRoleResetBaseReq=} [properties] Properties to set
         */
        function PB_CSRoleResetBaseReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSRoleResetBaseReq reqType.
         * @member {PB_CSRoleResetBaseReq.ReqType} reqType
         * @memberof PB_CSRoleResetBaseReq
         * @instance
         */
        PB_CSRoleResetBaseReq.prototype.reqType = 0;
    
        /**
         * PB_CSRoleResetBaseReq newBaseInfo.
         * @member {IPB_RoleBaseInfo|null|undefined} newBaseInfo
         * @memberof PB_CSRoleResetBaseReq
         * @instance
         */
        PB_CSRoleResetBaseReq.prototype.newBaseInfo = null;
    
        /**
         * Creates a new PB_CSRoleResetBaseReq instance using the specified properties.
         * @function create
         * @memberof PB_CSRoleResetBaseReq
         * @static
         * @param {IPB_CSRoleResetBaseReq=} [properties] Properties to set
         * @returns {PB_CSRoleResetBaseReq} PB_CSRoleResetBaseReq instance
         */
        PB_CSRoleResetBaseReq.create = function create(properties) {
            return new PB_CSRoleResetBaseReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSRoleResetBaseReq message. Does not implicitly {@link PB_CSRoleResetBaseReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSRoleResetBaseReq
         * @static
         * @param {IPB_CSRoleResetBaseReq} message PB_CSRoleResetBaseReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleResetBaseReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.newBaseInfo != null && Object.hasOwnProperty.call(message, "newBaseInfo"))
                $root.PB_RoleBaseInfo.encode(message.newBaseInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSRoleResetBaseReq message, length delimited. Does not implicitly {@link PB_CSRoleResetBaseReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSRoleResetBaseReq
         * @static
         * @param {IPB_CSRoleResetBaseReq} message PB_CSRoleResetBaseReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleResetBaseReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSRoleResetBaseReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSRoleResetBaseReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSRoleResetBaseReq} PB_CSRoleResetBaseReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleResetBaseReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSRoleResetBaseReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    message.newBaseInfo = $root.PB_RoleBaseInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSRoleResetBaseReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSRoleResetBaseReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSRoleResetBaseReq} PB_CSRoleResetBaseReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleResetBaseReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSRoleResetBaseReq message.
         * @function verify
         * @memberof PB_CSRoleResetBaseReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSRoleResetBaseReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                switch (message.reqType) {
                default:
                    return "reqType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.newBaseInfo != null && message.hasOwnProperty("newBaseInfo")) {
                var error = $root.PB_RoleBaseInfo.verify(message.newBaseInfo);
                if (error)
                    return "newBaseInfo." + error;
            }
            return null;
        };
    
        /**
         * Creates a PB_CSRoleResetBaseReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSRoleResetBaseReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSRoleResetBaseReq} PB_CSRoleResetBaseReq
         */
        PB_CSRoleResetBaseReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSRoleResetBaseReq)
                return object;
            var message = new $root.PB_CSRoleResetBaseReq();
            switch (object.reqType) {
            case "CREAT_ROLE":
            case 0:
                message.reqType = 0;
                break;
            case "COST_ITEM":
            case 1:
                message.reqType = 1;
                break;
            }
            if (object.newBaseInfo != null) {
                if (typeof object.newBaseInfo !== "object")
                    throw TypeError(".PB_CSRoleResetBaseReq.newBaseInfo: object expected");
                message.newBaseInfo = $root.PB_RoleBaseInfo.fromObject(object.newBaseInfo);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSRoleResetBaseReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSRoleResetBaseReq
         * @static
         * @param {PB_CSRoleResetBaseReq} message PB_CSRoleResetBaseReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSRoleResetBaseReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reqType = options.enums === String ? "CREAT_ROLE" : 0;
                object.newBaseInfo = null;
            }
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = options.enums === String ? $root.PB_CSRoleResetBaseReq.ReqType[message.reqType] : message.reqType;
            if (message.newBaseInfo != null && message.hasOwnProperty("newBaseInfo"))
                object.newBaseInfo = $root.PB_RoleBaseInfo.toObject(message.newBaseInfo, options);
            return object;
        };
    
        /**
         * Converts this PB_CSRoleResetBaseReq to JSON.
         * @function toJSON
         * @memberof PB_CSRoleResetBaseReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSRoleResetBaseReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * ReqType enum.
         * @name PB_CSRoleResetBaseReq.ReqType
         * @enum {number}
         * @property {number} CREAT_ROLE=0 CREAT_ROLE value
         * @property {number} COST_ITEM=1 COST_ITEM value
         */
        PB_CSRoleResetBaseReq.ReqType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CREAT_ROLE"] = 0;
            values[valuesById[1] = "COST_ITEM"] = 1;
            return values;
        })();
    
        return PB_CSRoleResetBaseReq;
    })();
    
    $root.PB_SCRoleCreatResetInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleCreatResetInfo.
         * @exports IPB_SCRoleCreatResetInfo
         * @interface IPB_SCRoleCreatResetInfo
         * @property {number|null} [finishCreatRoleReset] PB_SCRoleCreatResetInfo finishCreatRoleReset
         */
    
        /**
         * Constructs a new PB_SCRoleCreatResetInfo.
         * @exports PB_SCRoleCreatResetInfo
         * @classdesc Represents a PB_SCRoleCreatResetInfo.
         * @implements IPB_SCRoleCreatResetInfo
         * @constructor
         * @param {IPB_SCRoleCreatResetInfo=} [properties] Properties to set
         */
        function PB_SCRoleCreatResetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleCreatResetInfo finishCreatRoleReset.
         * @member {number} finishCreatRoleReset
         * @memberof PB_SCRoleCreatResetInfo
         * @instance
         */
        PB_SCRoleCreatResetInfo.prototype.finishCreatRoleReset = 0;
    
        /**
         * Creates a new PB_SCRoleCreatResetInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleCreatResetInfo
         * @static
         * @param {IPB_SCRoleCreatResetInfo=} [properties] Properties to set
         * @returns {PB_SCRoleCreatResetInfo} PB_SCRoleCreatResetInfo instance
         */
        PB_SCRoleCreatResetInfo.create = function create(properties) {
            return new PB_SCRoleCreatResetInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleCreatResetInfo message. Does not implicitly {@link PB_SCRoleCreatResetInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleCreatResetInfo
         * @static
         * @param {IPB_SCRoleCreatResetInfo} message PB_SCRoleCreatResetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleCreatResetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.finishCreatRoleReset != null && Object.hasOwnProperty.call(message, "finishCreatRoleReset"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.finishCreatRoleReset);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleCreatResetInfo message, length delimited. Does not implicitly {@link PB_SCRoleCreatResetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleCreatResetInfo
         * @static
         * @param {IPB_SCRoleCreatResetInfo} message PB_SCRoleCreatResetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleCreatResetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleCreatResetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleCreatResetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleCreatResetInfo} PB_SCRoleCreatResetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleCreatResetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleCreatResetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.finishCreatRoleReset = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleCreatResetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleCreatResetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleCreatResetInfo} PB_SCRoleCreatResetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleCreatResetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleCreatResetInfo message.
         * @function verify
         * @memberof PB_SCRoleCreatResetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleCreatResetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.finishCreatRoleReset != null && message.hasOwnProperty("finishCreatRoleReset"))
                if (!$util.isInteger(message.finishCreatRoleReset))
                    return "finishCreatRoleReset: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleCreatResetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleCreatResetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleCreatResetInfo} PB_SCRoleCreatResetInfo
         */
        PB_SCRoleCreatResetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleCreatResetInfo)
                return object;
            var message = new $root.PB_SCRoleCreatResetInfo();
            if (object.finishCreatRoleReset != null)
                message.finishCreatRoleReset = object.finishCreatRoleReset | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleCreatResetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleCreatResetInfo
         * @static
         * @param {PB_SCRoleCreatResetInfo} message PB_SCRoleCreatResetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleCreatResetInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.finishCreatRoleReset = 0;
            if (message.finishCreatRoleReset != null && message.hasOwnProperty("finishCreatRoleReset"))
                object.finishCreatRoleReset = message.finishCreatRoleReset;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleCreatResetInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleCreatResetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleCreatResetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleCreatResetInfo;
    })();
    
    $root.PB_CSGetRandNameStrIDReq = (function() {
    
        /**
         * Properties of a PB_CSGetRandNameStrIDReq.
         * @exports IPB_CSGetRandNameStrIDReq
         * @interface IPB_CSGetRandNameStrIDReq
         * @property {number|null} [sex] PB_CSGetRandNameStrIDReq sex
         */
    
        /**
         * Constructs a new PB_CSGetRandNameStrIDReq.
         * @exports PB_CSGetRandNameStrIDReq
         * @classdesc Represents a PB_CSGetRandNameStrIDReq.
         * @implements IPB_CSGetRandNameStrIDReq
         * @constructor
         * @param {IPB_CSGetRandNameStrIDReq=} [properties] Properties to set
         */
        function PB_CSGetRandNameStrIDReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSGetRandNameStrIDReq sex.
         * @member {number} sex
         * @memberof PB_CSGetRandNameStrIDReq
         * @instance
         */
        PB_CSGetRandNameStrIDReq.prototype.sex = 0;
    
        /**
         * Creates a new PB_CSGetRandNameStrIDReq instance using the specified properties.
         * @function create
         * @memberof PB_CSGetRandNameStrIDReq
         * @static
         * @param {IPB_CSGetRandNameStrIDReq=} [properties] Properties to set
         * @returns {PB_CSGetRandNameStrIDReq} PB_CSGetRandNameStrIDReq instance
         */
        PB_CSGetRandNameStrIDReq.create = function create(properties) {
            return new PB_CSGetRandNameStrIDReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSGetRandNameStrIDReq message. Does not implicitly {@link PB_CSGetRandNameStrIDReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSGetRandNameStrIDReq
         * @static
         * @param {IPB_CSGetRandNameStrIDReq} message PB_CSGetRandNameStrIDReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGetRandNameStrIDReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sex != null && Object.hasOwnProperty.call(message, "sex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sex);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSGetRandNameStrIDReq message, length delimited. Does not implicitly {@link PB_CSGetRandNameStrIDReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSGetRandNameStrIDReq
         * @static
         * @param {IPB_CSGetRandNameStrIDReq} message PB_CSGetRandNameStrIDReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGetRandNameStrIDReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSGetRandNameStrIDReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSGetRandNameStrIDReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSGetRandNameStrIDReq} PB_CSGetRandNameStrIDReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGetRandNameStrIDReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSGetRandNameStrIDReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSGetRandNameStrIDReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSGetRandNameStrIDReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSGetRandNameStrIDReq} PB_CSGetRandNameStrIDReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGetRandNameStrIDReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSGetRandNameStrIDReq message.
         * @function verify
         * @memberof PB_CSGetRandNameStrIDReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSGetRandNameStrIDReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sex != null && message.hasOwnProperty("sex"))
                if (!$util.isInteger(message.sex))
                    return "sex: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSGetRandNameStrIDReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSGetRandNameStrIDReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSGetRandNameStrIDReq} PB_CSGetRandNameStrIDReq
         */
        PB_CSGetRandNameStrIDReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSGetRandNameStrIDReq)
                return object;
            var message = new $root.PB_CSGetRandNameStrIDReq();
            if (object.sex != null)
                message.sex = object.sex | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSGetRandNameStrIDReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSGetRandNameStrIDReq
         * @static
         * @param {PB_CSGetRandNameStrIDReq} message PB_CSGetRandNameStrIDReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSGetRandNameStrIDReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.sex = 0;
            if (message.sex != null && message.hasOwnProperty("sex"))
                object.sex = message.sex;
            return object;
        };
    
        /**
         * Converts this PB_CSGetRandNameStrIDReq to JSON.
         * @function toJSON
         * @memberof PB_CSGetRandNameStrIDReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSGetRandNameStrIDReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSGetRandNameStrIDReq;
    })();
    
    $root.PB_SCGetRandNameStrIDRet = (function() {
    
        /**
         * Properties of a PB_SCGetRandNameStrIDRet.
         * @exports IPB_SCGetRandNameStrIDRet
         * @interface IPB_SCGetRandNameStrIDRet
         * @property {number|null} [frontSex] PB_SCGetRandNameStrIDRet frontSex
         * @property {number|null} [frontId] PB_SCGetRandNameStrIDRet frontId
         * @property {number|null} [middleSex] PB_SCGetRandNameStrIDRet middleSex
         * @property {number|null} [middleId] PB_SCGetRandNameStrIDRet middleId
         * @property {number|null} [lastSex] PB_SCGetRandNameStrIDRet lastSex
         * @property {number|null} [lastId] PB_SCGetRandNameStrIDRet lastId
         * @property {number|Long|null} [randNameStrId] PB_SCGetRandNameStrIDRet randNameStrId
         */
    
        /**
         * Constructs a new PB_SCGetRandNameStrIDRet.
         * @exports PB_SCGetRandNameStrIDRet
         * @classdesc Represents a PB_SCGetRandNameStrIDRet.
         * @implements IPB_SCGetRandNameStrIDRet
         * @constructor
         * @param {IPB_SCGetRandNameStrIDRet=} [properties] Properties to set
         */
        function PB_SCGetRandNameStrIDRet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCGetRandNameStrIDRet frontSex.
         * @member {number} frontSex
         * @memberof PB_SCGetRandNameStrIDRet
         * @instance
         */
        PB_SCGetRandNameStrIDRet.prototype.frontSex = 0;
    
        /**
         * PB_SCGetRandNameStrIDRet frontId.
         * @member {number} frontId
         * @memberof PB_SCGetRandNameStrIDRet
         * @instance
         */
        PB_SCGetRandNameStrIDRet.prototype.frontId = 0;
    
        /**
         * PB_SCGetRandNameStrIDRet middleSex.
         * @member {number} middleSex
         * @memberof PB_SCGetRandNameStrIDRet
         * @instance
         */
        PB_SCGetRandNameStrIDRet.prototype.middleSex = 0;
    
        /**
         * PB_SCGetRandNameStrIDRet middleId.
         * @member {number} middleId
         * @memberof PB_SCGetRandNameStrIDRet
         * @instance
         */
        PB_SCGetRandNameStrIDRet.prototype.middleId = 0;
    
        /**
         * PB_SCGetRandNameStrIDRet lastSex.
         * @member {number} lastSex
         * @memberof PB_SCGetRandNameStrIDRet
         * @instance
         */
        PB_SCGetRandNameStrIDRet.prototype.lastSex = 0;
    
        /**
         * PB_SCGetRandNameStrIDRet lastId.
         * @member {number} lastId
         * @memberof PB_SCGetRandNameStrIDRet
         * @instance
         */
        PB_SCGetRandNameStrIDRet.prototype.lastId = 0;
    
        /**
         * PB_SCGetRandNameStrIDRet randNameStrId.
         * @member {number|Long} randNameStrId
         * @memberof PB_SCGetRandNameStrIDRet
         * @instance
         */
        PB_SCGetRandNameStrIDRet.prototype.randNameStrId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCGetRandNameStrIDRet instance using the specified properties.
         * @function create
         * @memberof PB_SCGetRandNameStrIDRet
         * @static
         * @param {IPB_SCGetRandNameStrIDRet=} [properties] Properties to set
         * @returns {PB_SCGetRandNameStrIDRet} PB_SCGetRandNameStrIDRet instance
         */
        PB_SCGetRandNameStrIDRet.create = function create(properties) {
            return new PB_SCGetRandNameStrIDRet(properties);
        };
    
        /**
         * Encodes the specified PB_SCGetRandNameStrIDRet message. Does not implicitly {@link PB_SCGetRandNameStrIDRet.verify|verify} messages.
         * @function encode
         * @memberof PB_SCGetRandNameStrIDRet
         * @static
         * @param {IPB_SCGetRandNameStrIDRet} message PB_SCGetRandNameStrIDRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGetRandNameStrIDRet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.frontSex != null && Object.hasOwnProperty.call(message, "frontSex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.frontSex);
            if (message.frontId != null && Object.hasOwnProperty.call(message, "frontId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.frontId);
            if (message.middleSex != null && Object.hasOwnProperty.call(message, "middleSex"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.middleSex);
            if (message.middleId != null && Object.hasOwnProperty.call(message, "middleId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.middleId);
            if (message.lastSex != null && Object.hasOwnProperty.call(message, "lastSex"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lastSex);
            if (message.lastId != null && Object.hasOwnProperty.call(message, "lastId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.lastId);
            if (message.randNameStrId != null && Object.hasOwnProperty.call(message, "randNameStrId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.randNameStrId);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCGetRandNameStrIDRet message, length delimited. Does not implicitly {@link PB_SCGetRandNameStrIDRet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCGetRandNameStrIDRet
         * @static
         * @param {IPB_SCGetRandNameStrIDRet} message PB_SCGetRandNameStrIDRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGetRandNameStrIDRet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCGetRandNameStrIDRet message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCGetRandNameStrIDRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCGetRandNameStrIDRet} PB_SCGetRandNameStrIDRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGetRandNameStrIDRet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCGetRandNameStrIDRet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.frontSex = reader.int32();
                    break;
                case 2:
                    message.frontId = reader.int32();
                    break;
                case 3:
                    message.middleSex = reader.int32();
                    break;
                case 4:
                    message.middleId = reader.int32();
                    break;
                case 5:
                    message.lastSex = reader.int32();
                    break;
                case 6:
                    message.lastId = reader.int32();
                    break;
                case 7:
                    message.randNameStrId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCGetRandNameStrIDRet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCGetRandNameStrIDRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCGetRandNameStrIDRet} PB_SCGetRandNameStrIDRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGetRandNameStrIDRet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCGetRandNameStrIDRet message.
         * @function verify
         * @memberof PB_SCGetRandNameStrIDRet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCGetRandNameStrIDRet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.frontSex != null && message.hasOwnProperty("frontSex"))
                if (!$util.isInteger(message.frontSex))
                    return "frontSex: integer expected";
            if (message.frontId != null && message.hasOwnProperty("frontId"))
                if (!$util.isInteger(message.frontId))
                    return "frontId: integer expected";
            if (message.middleSex != null && message.hasOwnProperty("middleSex"))
                if (!$util.isInteger(message.middleSex))
                    return "middleSex: integer expected";
            if (message.middleId != null && message.hasOwnProperty("middleId"))
                if (!$util.isInteger(message.middleId))
                    return "middleId: integer expected";
            if (message.lastSex != null && message.hasOwnProperty("lastSex"))
                if (!$util.isInteger(message.lastSex))
                    return "lastSex: integer expected";
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                if (!$util.isInteger(message.lastId))
                    return "lastId: integer expected";
            if (message.randNameStrId != null && message.hasOwnProperty("randNameStrId"))
                if (!$util.isInteger(message.randNameStrId) && !(message.randNameStrId && $util.isInteger(message.randNameStrId.low) && $util.isInteger(message.randNameStrId.high)))
                    return "randNameStrId: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCGetRandNameStrIDRet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCGetRandNameStrIDRet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCGetRandNameStrIDRet} PB_SCGetRandNameStrIDRet
         */
        PB_SCGetRandNameStrIDRet.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCGetRandNameStrIDRet)
                return object;
            var message = new $root.PB_SCGetRandNameStrIDRet();
            if (object.frontSex != null)
                message.frontSex = object.frontSex | 0;
            if (object.frontId != null)
                message.frontId = object.frontId | 0;
            if (object.middleSex != null)
                message.middleSex = object.middleSex | 0;
            if (object.middleId != null)
                message.middleId = object.middleId | 0;
            if (object.lastSex != null)
                message.lastSex = object.lastSex | 0;
            if (object.lastId != null)
                message.lastId = object.lastId | 0;
            if (object.randNameStrId != null)
                if ($util.Long)
                    (message.randNameStrId = $util.Long.fromValue(object.randNameStrId)).unsigned = false;
                else if (typeof object.randNameStrId === "string")
                    message.randNameStrId = parseInt(object.randNameStrId, 10);
                else if (typeof object.randNameStrId === "number")
                    message.randNameStrId = object.randNameStrId;
                else if (typeof object.randNameStrId === "object")
                    message.randNameStrId = new $util.LongBits(object.randNameStrId.low >>> 0, object.randNameStrId.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCGetRandNameStrIDRet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCGetRandNameStrIDRet
         * @static
         * @param {PB_SCGetRandNameStrIDRet} message PB_SCGetRandNameStrIDRet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCGetRandNameStrIDRet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.frontSex = 0;
                object.frontId = 0;
                object.middleSex = 0;
                object.middleId = 0;
                object.lastSex = 0;
                object.lastId = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.randNameStrId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.randNameStrId = options.longs === String ? "0" : 0;
            }
            if (message.frontSex != null && message.hasOwnProperty("frontSex"))
                object.frontSex = message.frontSex;
            if (message.frontId != null && message.hasOwnProperty("frontId"))
                object.frontId = message.frontId;
            if (message.middleSex != null && message.hasOwnProperty("middleSex"))
                object.middleSex = message.middleSex;
            if (message.middleId != null && message.hasOwnProperty("middleId"))
                object.middleId = message.middleId;
            if (message.lastSex != null && message.hasOwnProperty("lastSex"))
                object.lastSex = message.lastSex;
            if (message.lastId != null && message.hasOwnProperty("lastId"))
                object.lastId = message.lastId;
            if (message.randNameStrId != null && message.hasOwnProperty("randNameStrId"))
                if (typeof message.randNameStrId === "number")
                    object.randNameStrId = options.longs === String ? String(message.randNameStrId) : message.randNameStrId;
                else
                    object.randNameStrId = options.longs === String ? $util.Long.prototype.toString.call(message.randNameStrId) : options.longs === Number ? new $util.LongBits(message.randNameStrId.low >>> 0, message.randNameStrId.high >>> 0).toNumber() : message.randNameStrId;
            return object;
        };
    
        /**
         * Converts this PB_SCGetRandNameStrIDRet to JSON.
         * @function toJSON
         * @memberof PB_SCGetRandNameStrIDRet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCGetRandNameStrIDRet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCGetRandNameStrIDRet;
    })();
    
    $root.PB_CSGetOtherRoleInfo = (function() {
    
        /**
         * Properties of a PB_CSGetOtherRoleInfo.
         * @exports IPB_CSGetOtherRoleInfo
         * @interface IPB_CSGetOtherRoleInfo
         * @property {number|null} [uid] PB_CSGetOtherRoleInfo uid
         */
    
        /**
         * Constructs a new PB_CSGetOtherRoleInfo.
         * @exports PB_CSGetOtherRoleInfo
         * @classdesc Represents a PB_CSGetOtherRoleInfo.
         * @implements IPB_CSGetOtherRoleInfo
         * @constructor
         * @param {IPB_CSGetOtherRoleInfo=} [properties] Properties to set
         */
        function PB_CSGetOtherRoleInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSGetOtherRoleInfo uid.
         * @member {number} uid
         * @memberof PB_CSGetOtherRoleInfo
         * @instance
         */
        PB_CSGetOtherRoleInfo.prototype.uid = 0;
    
        /**
         * Creates a new PB_CSGetOtherRoleInfo instance using the specified properties.
         * @function create
         * @memberof PB_CSGetOtherRoleInfo
         * @static
         * @param {IPB_CSGetOtherRoleInfo=} [properties] Properties to set
         * @returns {PB_CSGetOtherRoleInfo} PB_CSGetOtherRoleInfo instance
         */
        PB_CSGetOtherRoleInfo.create = function create(properties) {
            return new PB_CSGetOtherRoleInfo(properties);
        };
    
        /**
         * Encodes the specified PB_CSGetOtherRoleInfo message. Does not implicitly {@link PB_CSGetOtherRoleInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_CSGetOtherRoleInfo
         * @static
         * @param {IPB_CSGetOtherRoleInfo} message PB_CSGetOtherRoleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGetOtherRoleInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.uid);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSGetOtherRoleInfo message, length delimited. Does not implicitly {@link PB_CSGetOtherRoleInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSGetOtherRoleInfo
         * @static
         * @param {IPB_CSGetOtherRoleInfo} message PB_CSGetOtherRoleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGetOtherRoleInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSGetOtherRoleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSGetOtherRoleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSGetOtherRoleInfo} PB_CSGetOtherRoleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGetOtherRoleInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSGetOtherRoleInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSGetOtherRoleInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSGetOtherRoleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSGetOtherRoleInfo} PB_CSGetOtherRoleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGetOtherRoleInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSGetOtherRoleInfo message.
         * @function verify
         * @memberof PB_CSGetOtherRoleInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSGetOtherRoleInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSGetOtherRoleInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSGetOtherRoleInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSGetOtherRoleInfo} PB_CSGetOtherRoleInfo
         */
        PB_CSGetOtherRoleInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSGetOtherRoleInfo)
                return object;
            var message = new $root.PB_CSGetOtherRoleInfo();
            if (object.uid != null)
                message.uid = object.uid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSGetOtherRoleInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSGetOtherRoleInfo
         * @static
         * @param {PB_CSGetOtherRoleInfo} message PB_CSGetOtherRoleInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSGetOtherRoleInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.uid = 0;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            return object;
        };
    
        /**
         * Converts this PB_CSGetOtherRoleInfo to JSON.
         * @function toJSON
         * @memberof PB_CSGetOtherRoleInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSGetOtherRoleInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSGetOtherRoleInfo;
    })();
    
    $root.PB_SCGetOtherRoleRet = (function() {
    
        /**
         * Properties of a PB_SCGetOtherRoleRet.
         * @exports IPB_SCGetOtherRoleRet
         * @interface IPB_SCGetOtherRoleRet
         * @property {number|null} [uid] PB_SCGetOtherRoleRet uid
         * @property {IPB_RoleInfo|null} [roleinfo] PB_SCGetOtherRoleRet roleinfo
         */
    
        /**
         * Constructs a new PB_SCGetOtherRoleRet.
         * @exports PB_SCGetOtherRoleRet
         * @classdesc Represents a PB_SCGetOtherRoleRet.
         * @implements IPB_SCGetOtherRoleRet
         * @constructor
         * @param {IPB_SCGetOtherRoleRet=} [properties] Properties to set
         */
        function PB_SCGetOtherRoleRet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCGetOtherRoleRet uid.
         * @member {number} uid
         * @memberof PB_SCGetOtherRoleRet
         * @instance
         */
        PB_SCGetOtherRoleRet.prototype.uid = 0;
    
        /**
         * PB_SCGetOtherRoleRet roleinfo.
         * @member {IPB_RoleInfo|null|undefined} roleinfo
         * @memberof PB_SCGetOtherRoleRet
         * @instance
         */
        PB_SCGetOtherRoleRet.prototype.roleinfo = null;
    
        /**
         * Creates a new PB_SCGetOtherRoleRet instance using the specified properties.
         * @function create
         * @memberof PB_SCGetOtherRoleRet
         * @static
         * @param {IPB_SCGetOtherRoleRet=} [properties] Properties to set
         * @returns {PB_SCGetOtherRoleRet} PB_SCGetOtherRoleRet instance
         */
        PB_SCGetOtherRoleRet.create = function create(properties) {
            return new PB_SCGetOtherRoleRet(properties);
        };
    
        /**
         * Encodes the specified PB_SCGetOtherRoleRet message. Does not implicitly {@link PB_SCGetOtherRoleRet.verify|verify} messages.
         * @function encode
         * @memberof PB_SCGetOtherRoleRet
         * @static
         * @param {IPB_SCGetOtherRoleRet} message PB_SCGetOtherRoleRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGetOtherRoleRet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.uid);
            if (message.roleinfo != null && Object.hasOwnProperty.call(message, "roleinfo"))
                $root.PB_RoleInfo.encode(message.roleinfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCGetOtherRoleRet message, length delimited. Does not implicitly {@link PB_SCGetOtherRoleRet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCGetOtherRoleRet
         * @static
         * @param {IPB_SCGetOtherRoleRet} message PB_SCGetOtherRoleRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGetOtherRoleRet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCGetOtherRoleRet message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCGetOtherRoleRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCGetOtherRoleRet} PB_SCGetOtherRoleRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGetOtherRoleRet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCGetOtherRoleRet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.int32();
                    break;
                case 2:
                    message.roleinfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCGetOtherRoleRet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCGetOtherRoleRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCGetOtherRoleRet} PB_SCGetOtherRoleRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGetOtherRoleRet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCGetOtherRoleRet message.
         * @function verify
         * @memberof PB_SCGetOtherRoleRet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCGetOtherRoleRet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.roleinfo != null && message.hasOwnProperty("roleinfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleinfo);
                if (error)
                    return "roleinfo." + error;
            }
            return null;
        };
    
        /**
         * Creates a PB_SCGetOtherRoleRet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCGetOtherRoleRet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCGetOtherRoleRet} PB_SCGetOtherRoleRet
         */
        PB_SCGetOtherRoleRet.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCGetOtherRoleRet)
                return object;
            var message = new $root.PB_SCGetOtherRoleRet();
            if (object.uid != null)
                message.uid = object.uid | 0;
            if (object.roleinfo != null) {
                if (typeof object.roleinfo !== "object")
                    throw TypeError(".PB_SCGetOtherRoleRet.roleinfo: object expected");
                message.roleinfo = $root.PB_RoleInfo.fromObject(object.roleinfo);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCGetOtherRoleRet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCGetOtherRoleRet
         * @static
         * @param {PB_SCGetOtherRoleRet} message PB_SCGetOtherRoleRet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCGetOtherRoleRet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.uid = 0;
                object.roleinfo = null;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.roleinfo != null && message.hasOwnProperty("roleinfo"))
                object.roleinfo = $root.PB_RoleInfo.toObject(message.roleinfo, options);
            return object;
        };
    
        /**
         * Converts this PB_SCGetOtherRoleRet to JSON.
         * @function toJSON
         * @memberof PB_SCGetOtherRoleRet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCGetOtherRoleRet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCGetOtherRoleRet;
    })();
    
    $root.PB_BattleHeroInfo = (function() {
    
        /**
         * Properties of a PB_BattleHeroInfo.
         * @exports IPB_BattleHeroInfo
         * @interface IPB_BattleHeroInfo
         * @property {number|null} [heroId] PB_BattleHeroInfo heroId
         * @property {number|Long|null} [heroDamage] PB_BattleHeroInfo heroDamage
         * @property {number|null} [heroLevel] PB_BattleHeroInfo heroLevel
         */
    
        /**
         * Constructs a new PB_BattleHeroInfo.
         * @exports PB_BattleHeroInfo
         * @classdesc Represents a PB_BattleHeroInfo.
         * @implements IPB_BattleHeroInfo
         * @constructor
         * @param {IPB_BattleHeroInfo=} [properties] Properties to set
         */
        function PB_BattleHeroInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_BattleHeroInfo heroId.
         * @member {number} heroId
         * @memberof PB_BattleHeroInfo
         * @instance
         */
        PB_BattleHeroInfo.prototype.heroId = 0;
    
        /**
         * PB_BattleHeroInfo heroDamage.
         * @member {number|Long} heroDamage
         * @memberof PB_BattleHeroInfo
         * @instance
         */
        PB_BattleHeroInfo.prototype.heroDamage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_BattleHeroInfo heroLevel.
         * @member {number} heroLevel
         * @memberof PB_BattleHeroInfo
         * @instance
         */
        PB_BattleHeroInfo.prototype.heroLevel = 0;
    
        /**
         * Creates a new PB_BattleHeroInfo instance using the specified properties.
         * @function create
         * @memberof PB_BattleHeroInfo
         * @static
         * @param {IPB_BattleHeroInfo=} [properties] Properties to set
         * @returns {PB_BattleHeroInfo} PB_BattleHeroInfo instance
         */
        PB_BattleHeroInfo.create = function create(properties) {
            return new PB_BattleHeroInfo(properties);
        };
    
        /**
         * Encodes the specified PB_BattleHeroInfo message. Does not implicitly {@link PB_BattleHeroInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_BattleHeroInfo
         * @static
         * @param {IPB_BattleHeroInfo} message PB_BattleHeroInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_BattleHeroInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.heroId);
            if (message.heroDamage != null && Object.hasOwnProperty.call(message, "heroDamage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.heroDamage);
            if (message.heroLevel != null && Object.hasOwnProperty.call(message, "heroLevel"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.heroLevel);
            return writer;
        };
    
        /**
         * Encodes the specified PB_BattleHeroInfo message, length delimited. Does not implicitly {@link PB_BattleHeroInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_BattleHeroInfo
         * @static
         * @param {IPB_BattleHeroInfo} message PB_BattleHeroInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_BattleHeroInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_BattleHeroInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_BattleHeroInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_BattleHeroInfo} PB_BattleHeroInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_BattleHeroInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_BattleHeroInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroId = reader.int32();
                    break;
                case 2:
                    message.heroDamage = reader.int64();
                    break;
                case 3:
                    message.heroLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_BattleHeroInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_BattleHeroInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_BattleHeroInfo} PB_BattleHeroInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_BattleHeroInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_BattleHeroInfo message.
         * @function verify
         * @memberof PB_BattleHeroInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_BattleHeroInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.heroDamage != null && message.hasOwnProperty("heroDamage"))
                if (!$util.isInteger(message.heroDamage) && !(message.heroDamage && $util.isInteger(message.heroDamage.low) && $util.isInteger(message.heroDamage.high)))
                    return "heroDamage: integer|Long expected";
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                if (!$util.isInteger(message.heroLevel))
                    return "heroLevel: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_BattleHeroInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_BattleHeroInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_BattleHeroInfo} PB_BattleHeroInfo
         */
        PB_BattleHeroInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_BattleHeroInfo)
                return object;
            var message = new $root.PB_BattleHeroInfo();
            if (object.heroId != null)
                message.heroId = object.heroId | 0;
            if (object.heroDamage != null)
                if ($util.Long)
                    (message.heroDamage = $util.Long.fromValue(object.heroDamage)).unsigned = false;
                else if (typeof object.heroDamage === "string")
                    message.heroDamage = parseInt(object.heroDamage, 10);
                else if (typeof object.heroDamage === "number")
                    message.heroDamage = object.heroDamage;
                else if (typeof object.heroDamage === "object")
                    message.heroDamage = new $util.LongBits(object.heroDamage.low >>> 0, object.heroDamage.high >>> 0).toNumber();
            if (object.heroLevel != null)
                message.heroLevel = object.heroLevel | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_BattleHeroInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_BattleHeroInfo
         * @static
         * @param {PB_BattleHeroInfo} message PB_BattleHeroInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_BattleHeroInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heroId = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.heroDamage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.heroDamage = options.longs === String ? "0" : 0;
                object.heroLevel = 0;
            }
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.heroDamage != null && message.hasOwnProperty("heroDamage"))
                if (typeof message.heroDamage === "number")
                    object.heroDamage = options.longs === String ? String(message.heroDamage) : message.heroDamage;
                else
                    object.heroDamage = options.longs === String ? $util.Long.prototype.toString.call(message.heroDamage) : options.longs === Number ? new $util.LongBits(message.heroDamage.low >>> 0, message.heroDamage.high >>> 0).toNumber() : message.heroDamage;
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                object.heroLevel = message.heroLevel;
            return object;
        };
    
        /**
         * Converts this PB_BattleHeroInfo to JSON.
         * @function toJSON
         * @memberof PB_BattleHeroInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_BattleHeroInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_BattleHeroInfo;
    })();
    
    $root.PB_CSBattleRet = (function() {
    
        /**
         * Properties of a PB_CSBattleRet.
         * @exports IPB_CSBattleRet
         * @interface IPB_CSBattleRet
         * @property {number|null} [battleResult] PB_CSBattleRet battleResult
         * @property {number|null} [battleMode] PB_CSBattleRet battleMode
         * @property {number|null} [battleRound] PB_CSBattleRet battleRound
         * @property {Array.<number>|null} [battleParam] PB_CSBattleRet battleParam
         * @property {Array.<IPB_SCBattleRoundInfo>|null} [roundList] PB_CSBattleRet roundList
         * @property {number|null} [killElite] PB_CSBattleRet killElite
         * @property {number|null} [comboNum] PB_CSBattleRet comboNum
         * @property {number|null} [boxNum] PB_CSBattleRet boxNum
         * @property {number|null} [compNum] PB_CSBattleRet compNum
         * @property {Array.<IPB_BattleHeroInfo>|null} [heroList] PB_CSBattleRet heroList
         * @property {number|null} [killBoss] PB_CSBattleRet killBoss
         * @property {number|null} [killMonster] PB_CSBattleRet killMonster
         */
    
        /**
         * Constructs a new PB_CSBattleRet.
         * @exports PB_CSBattleRet
         * @classdesc Represents a PB_CSBattleRet.
         * @implements IPB_CSBattleRet
         * @constructor
         * @param {IPB_CSBattleRet=} [properties] Properties to set
         */
        function PB_CSBattleRet(properties) {
            this.battleParam = [];
            this.roundList = [];
            this.heroList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSBattleRet battleResult.
         * @member {number} battleResult
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.battleResult = 0;
    
        /**
         * PB_CSBattleRet battleMode.
         * @member {number} battleMode
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.battleMode = 0;
    
        /**
         * PB_CSBattleRet battleRound.
         * @member {number} battleRound
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.battleRound = 0;
    
        /**
         * PB_CSBattleRet battleParam.
         * @member {Array.<number>} battleParam
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.battleParam = $util.emptyArray;
    
        /**
         * PB_CSBattleRet roundList.
         * @member {Array.<IPB_SCBattleRoundInfo>} roundList
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.roundList = $util.emptyArray;
    
        /**
         * PB_CSBattleRet killElite.
         * @member {number} killElite
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.killElite = 0;
    
        /**
         * PB_CSBattleRet comboNum.
         * @member {number} comboNum
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.comboNum = 0;
    
        /**
         * PB_CSBattleRet boxNum.
         * @member {number} boxNum
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.boxNum = 0;
    
        /**
         * PB_CSBattleRet compNum.
         * @member {number} compNum
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.compNum = 0;
    
        /**
         * PB_CSBattleRet heroList.
         * @member {Array.<IPB_BattleHeroInfo>} heroList
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.heroList = $util.emptyArray;
    
        /**
         * PB_CSBattleRet killBoss.
         * @member {number} killBoss
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.killBoss = 0;
    
        /**
         * PB_CSBattleRet killMonster.
         * @member {number} killMonster
         * @memberof PB_CSBattleRet
         * @instance
         */
        PB_CSBattleRet.prototype.killMonster = 0;
    
        /**
         * Creates a new PB_CSBattleRet instance using the specified properties.
         * @function create
         * @memberof PB_CSBattleRet
         * @static
         * @param {IPB_CSBattleRet=} [properties] Properties to set
         * @returns {PB_CSBattleRet} PB_CSBattleRet instance
         */
        PB_CSBattleRet.create = function create(properties) {
            return new PB_CSBattleRet(properties);
        };
    
        /**
         * Encodes the specified PB_CSBattleRet message. Does not implicitly {@link PB_CSBattleRet.verify|verify} messages.
         * @function encode
         * @memberof PB_CSBattleRet
         * @static
         * @param {IPB_CSBattleRet} message PB_CSBattleRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSBattleRet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleResult != null && Object.hasOwnProperty.call(message, "battleResult"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.battleResult);
            if (message.battleMode != null && Object.hasOwnProperty.call(message, "battleMode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.battleMode);
            if (message.battleRound != null && Object.hasOwnProperty.call(message, "battleRound"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.battleRound);
            if (message.battleParam != null && message.battleParam.length)
                for (var i = 0; i < message.battleParam.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.battleParam[i]);
            if (message.roundList != null && message.roundList.length)
                for (var i = 0; i < message.roundList.length; ++i)
                    $root.PB_SCBattleRoundInfo.encode(message.roundList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.killElite != null && Object.hasOwnProperty.call(message, "killElite"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.killElite);
            if (message.comboNum != null && Object.hasOwnProperty.call(message, "comboNum"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.comboNum);
            if (message.boxNum != null && Object.hasOwnProperty.call(message, "boxNum"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.boxNum);
            if (message.compNum != null && Object.hasOwnProperty.call(message, "compNum"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.compNum);
            if (message.heroList != null && message.heroList.length)
                for (var i = 0; i < message.heroList.length; ++i)
                    $root.PB_BattleHeroInfo.encode(message.heroList[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.killBoss != null && Object.hasOwnProperty.call(message, "killBoss"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.killBoss);
            if (message.killMonster != null && Object.hasOwnProperty.call(message, "killMonster"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.killMonster);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSBattleRet message, length delimited. Does not implicitly {@link PB_CSBattleRet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSBattleRet
         * @static
         * @param {IPB_CSBattleRet} message PB_CSBattleRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSBattleRet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSBattleRet message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSBattleRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSBattleRet} PB_CSBattleRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSBattleRet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSBattleRet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.battleResult = reader.int32();
                    break;
                case 2:
                    message.battleMode = reader.int32();
                    break;
                case 3:
                    message.battleRound = reader.int32();
                    break;
                case 4:
                    if (!(message.battleParam && message.battleParam.length))
                        message.battleParam = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.battleParam.push(reader.int32());
                    } else
                        message.battleParam.push(reader.int32());
                    break;
                case 5:
                    if (!(message.roundList && message.roundList.length))
                        message.roundList = [];
                    message.roundList.push($root.PB_SCBattleRoundInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.killElite = reader.int32();
                    break;
                case 7:
                    message.comboNum = reader.int32();
                    break;
                case 8:
                    message.boxNum = reader.int32();
                    break;
                case 9:
                    message.compNum = reader.int32();
                    break;
                case 10:
                    if (!(message.heroList && message.heroList.length))
                        message.heroList = [];
                    message.heroList.push($root.PB_BattleHeroInfo.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.killBoss = reader.int32();
                    break;
                case 12:
                    message.killMonster = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSBattleRet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSBattleRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSBattleRet} PB_CSBattleRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSBattleRet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSBattleRet message.
         * @function verify
         * @memberof PB_CSBattleRet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSBattleRet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleResult != null && message.hasOwnProperty("battleResult"))
                if (!$util.isInteger(message.battleResult))
                    return "battleResult: integer expected";
            if (message.battleMode != null && message.hasOwnProperty("battleMode"))
                if (!$util.isInteger(message.battleMode))
                    return "battleMode: integer expected";
            if (message.battleRound != null && message.hasOwnProperty("battleRound"))
                if (!$util.isInteger(message.battleRound))
                    return "battleRound: integer expected";
            if (message.battleParam != null && message.hasOwnProperty("battleParam")) {
                if (!Array.isArray(message.battleParam))
                    return "battleParam: array expected";
                for (var i = 0; i < message.battleParam.length; ++i)
                    if (!$util.isInteger(message.battleParam[i]))
                        return "battleParam: integer[] expected";
            }
            if (message.roundList != null && message.hasOwnProperty("roundList")) {
                if (!Array.isArray(message.roundList))
                    return "roundList: array expected";
                for (var i = 0; i < message.roundList.length; ++i) {
                    var error = $root.PB_SCBattleRoundInfo.verify(message.roundList[i]);
                    if (error)
                        return "roundList." + error;
                }
            }
            if (message.killElite != null && message.hasOwnProperty("killElite"))
                if (!$util.isInteger(message.killElite))
                    return "killElite: integer expected";
            if (message.comboNum != null && message.hasOwnProperty("comboNum"))
                if (!$util.isInteger(message.comboNum))
                    return "comboNum: integer expected";
            if (message.boxNum != null && message.hasOwnProperty("boxNum"))
                if (!$util.isInteger(message.boxNum))
                    return "boxNum: integer expected";
            if (message.compNum != null && message.hasOwnProperty("compNum"))
                if (!$util.isInteger(message.compNum))
                    return "compNum: integer expected";
            if (message.heroList != null && message.hasOwnProperty("heroList")) {
                if (!Array.isArray(message.heroList))
                    return "heroList: array expected";
                for (var i = 0; i < message.heroList.length; ++i) {
                    var error = $root.PB_BattleHeroInfo.verify(message.heroList[i]);
                    if (error)
                        return "heroList." + error;
                }
            }
            if (message.killBoss != null && message.hasOwnProperty("killBoss"))
                if (!$util.isInteger(message.killBoss))
                    return "killBoss: integer expected";
            if (message.killMonster != null && message.hasOwnProperty("killMonster"))
                if (!$util.isInteger(message.killMonster))
                    return "killMonster: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSBattleRet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSBattleRet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSBattleRet} PB_CSBattleRet
         */
        PB_CSBattleRet.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSBattleRet)
                return object;
            var message = new $root.PB_CSBattleRet();
            if (object.battleResult != null)
                message.battleResult = object.battleResult | 0;
            if (object.battleMode != null)
                message.battleMode = object.battleMode | 0;
            if (object.battleRound != null)
                message.battleRound = object.battleRound | 0;
            if (object.battleParam) {
                if (!Array.isArray(object.battleParam))
                    throw TypeError(".PB_CSBattleRet.battleParam: array expected");
                message.battleParam = [];
                for (var i = 0; i < object.battleParam.length; ++i)
                    message.battleParam[i] = object.battleParam[i] | 0;
            }
            if (object.roundList) {
                if (!Array.isArray(object.roundList))
                    throw TypeError(".PB_CSBattleRet.roundList: array expected");
                message.roundList = [];
                for (var i = 0; i < object.roundList.length; ++i) {
                    if (typeof object.roundList[i] !== "object")
                        throw TypeError(".PB_CSBattleRet.roundList: object expected");
                    message.roundList[i] = $root.PB_SCBattleRoundInfo.fromObject(object.roundList[i]);
                }
            }
            if (object.killElite != null)
                message.killElite = object.killElite | 0;
            if (object.comboNum != null)
                message.comboNum = object.comboNum | 0;
            if (object.boxNum != null)
                message.boxNum = object.boxNum | 0;
            if (object.compNum != null)
                message.compNum = object.compNum | 0;
            if (object.heroList) {
                if (!Array.isArray(object.heroList))
                    throw TypeError(".PB_CSBattleRet.heroList: array expected");
                message.heroList = [];
                for (var i = 0; i < object.heroList.length; ++i) {
                    if (typeof object.heroList[i] !== "object")
                        throw TypeError(".PB_CSBattleRet.heroList: object expected");
                    message.heroList[i] = $root.PB_BattleHeroInfo.fromObject(object.heroList[i]);
                }
            }
            if (object.killBoss != null)
                message.killBoss = object.killBoss | 0;
            if (object.killMonster != null)
                message.killMonster = object.killMonster | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSBattleRet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSBattleRet
         * @static
         * @param {PB_CSBattleRet} message PB_CSBattleRet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSBattleRet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.battleParam = [];
                object.roundList = [];
                object.heroList = [];
            }
            if (options.defaults) {
                object.battleResult = 0;
                object.battleMode = 0;
                object.battleRound = 0;
                object.killElite = 0;
                object.comboNum = 0;
                object.boxNum = 0;
                object.compNum = 0;
                object.killBoss = 0;
                object.killMonster = 0;
            }
            if (message.battleResult != null && message.hasOwnProperty("battleResult"))
                object.battleResult = message.battleResult;
            if (message.battleMode != null && message.hasOwnProperty("battleMode"))
                object.battleMode = message.battleMode;
            if (message.battleRound != null && message.hasOwnProperty("battleRound"))
                object.battleRound = message.battleRound;
            if (message.battleParam && message.battleParam.length) {
                object.battleParam = [];
                for (var j = 0; j < message.battleParam.length; ++j)
                    object.battleParam[j] = message.battleParam[j];
            }
            if (message.roundList && message.roundList.length) {
                object.roundList = [];
                for (var j = 0; j < message.roundList.length; ++j)
                    object.roundList[j] = $root.PB_SCBattleRoundInfo.toObject(message.roundList[j], options);
            }
            if (message.killElite != null && message.hasOwnProperty("killElite"))
                object.killElite = message.killElite;
            if (message.comboNum != null && message.hasOwnProperty("comboNum"))
                object.comboNum = message.comboNum;
            if (message.boxNum != null && message.hasOwnProperty("boxNum"))
                object.boxNum = message.boxNum;
            if (message.compNum != null && message.hasOwnProperty("compNum"))
                object.compNum = message.compNum;
            if (message.heroList && message.heroList.length) {
                object.heroList = [];
                for (var j = 0; j < message.heroList.length; ++j)
                    object.heroList[j] = $root.PB_BattleHeroInfo.toObject(message.heroList[j], options);
            }
            if (message.killBoss != null && message.hasOwnProperty("killBoss"))
                object.killBoss = message.killBoss;
            if (message.killMonster != null && message.hasOwnProperty("killMonster"))
                object.killMonster = message.killMonster;
            return object;
        };
    
        /**
         * Converts this PB_CSBattleRet to JSON.
         * @function toJSON
         * @memberof PB_CSBattleRet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSBattleRet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSBattleRet;
    })();
    
    $root.PB_SCBattleReward = (function() {
    
        /**
         * Properties of a PB_SCBattleReward.
         * @exports IPB_SCBattleReward
         * @interface IPB_SCBattleReward
         * @property {number|null} [itemId] PB_SCBattleReward itemId
         * @property {number|Long|null} [itemNum] PB_SCBattleReward itemNum
         */
    
        /**
         * Constructs a new PB_SCBattleReward.
         * @exports PB_SCBattleReward
         * @classdesc Represents a PB_SCBattleReward.
         * @implements IPB_SCBattleReward
         * @constructor
         * @param {IPB_SCBattleReward=} [properties] Properties to set
         */
        function PB_SCBattleReward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCBattleReward itemId.
         * @member {number} itemId
         * @memberof PB_SCBattleReward
         * @instance
         */
        PB_SCBattleReward.prototype.itemId = 0;
    
        /**
         * PB_SCBattleReward itemNum.
         * @member {number|Long} itemNum
         * @memberof PB_SCBattleReward
         * @instance
         */
        PB_SCBattleReward.prototype.itemNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCBattleReward instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleReward
         * @static
         * @param {IPB_SCBattleReward=} [properties] Properties to set
         * @returns {PB_SCBattleReward} PB_SCBattleReward instance
         */
        PB_SCBattleReward.create = function create(properties) {
            return new PB_SCBattleReward(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleReward message. Does not implicitly {@link PB_SCBattleReward.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleReward
         * @static
         * @param {IPB_SCBattleReward} message PB_SCBattleReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleReward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            if (message.itemNum != null && Object.hasOwnProperty.call(message, "itemNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.itemNum);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleReward message, length delimited. Does not implicitly {@link PB_SCBattleReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleReward
         * @static
         * @param {IPB_SCBattleReward} message PB_SCBattleReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleReward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleReward message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleReward} PB_SCBattleReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleReward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleReward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                case 2:
                    message.itemNum = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleReward} PB_SCBattleReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleReward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleReward message.
         * @function verify
         * @memberof PB_SCBattleReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleReward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                if (!$util.isInteger(message.itemNum) && !(message.itemNum && $util.isInteger(message.itemNum.low) && $util.isInteger(message.itemNum.high)))
                    return "itemNum: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCBattleReward message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleReward
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleReward} PB_SCBattleReward
         */
        PB_SCBattleReward.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleReward)
                return object;
            var message = new $root.PB_SCBattleReward();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            if (object.itemNum != null)
                if ($util.Long)
                    (message.itemNum = $util.Long.fromValue(object.itemNum)).unsigned = false;
                else if (typeof object.itemNum === "string")
                    message.itemNum = parseInt(object.itemNum, 10);
                else if (typeof object.itemNum === "number")
                    message.itemNum = object.itemNum;
                else if (typeof object.itemNum === "object")
                    message.itemNum = new $util.LongBits(object.itemNum.low >>> 0, object.itemNum.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCBattleReward message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleReward
         * @static
         * @param {PB_SCBattleReward} message PB_SCBattleReward
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleReward.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.itemNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.itemNum = options.longs === String ? "0" : 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                if (typeof message.itemNum === "number")
                    object.itemNum = options.longs === String ? String(message.itemNum) : message.itemNum;
                else
                    object.itemNum = options.longs === String ? $util.Long.prototype.toString.call(message.itemNum) : options.longs === Number ? new $util.LongBits(message.itemNum.low >>> 0, message.itemNum.high >>> 0).toNumber() : message.itemNum;
            return object;
        };
    
        /**
         * Converts this PB_SCBattleReward to JSON.
         * @function toJSON
         * @memberof PB_SCBattleReward
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleReward.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleReward;
    })();
    
    $root.PB_SCBattleReport = (function() {
    
        /**
         * Properties of a PB_SCBattleReport.
         * @exports IPB_SCBattleReport
         * @interface IPB_SCBattleReport
         * @property {number|null} [battleResult] PB_SCBattleReport battleResult
         * @property {number|null} [battleMode] PB_SCBattleReport battleMode
         * @property {number|null} [battleRound] PB_SCBattleReport battleRound
         * @property {Array.<IPB_SCBattleReward>|null} [rewardList] PB_SCBattleReport rewardList
         * @property {Array.<number>|null} [battleParam] PB_SCBattleReport battleParam
         * @property {number|null} [arenaScoreChange] PB_SCBattleReport arenaScoreChange
         */
    
        /**
         * Constructs a new PB_SCBattleReport.
         * @exports PB_SCBattleReport
         * @classdesc Represents a PB_SCBattleReport.
         * @implements IPB_SCBattleReport
         * @constructor
         * @param {IPB_SCBattleReport=} [properties] Properties to set
         */
        function PB_SCBattleReport(properties) {
            this.rewardList = [];
            this.battleParam = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCBattleReport battleResult.
         * @member {number} battleResult
         * @memberof PB_SCBattleReport
         * @instance
         */
        PB_SCBattleReport.prototype.battleResult = 0;
    
        /**
         * PB_SCBattleReport battleMode.
         * @member {number} battleMode
         * @memberof PB_SCBattleReport
         * @instance
         */
        PB_SCBattleReport.prototype.battleMode = 0;
    
        /**
         * PB_SCBattleReport battleRound.
         * @member {number} battleRound
         * @memberof PB_SCBattleReport
         * @instance
         */
        PB_SCBattleReport.prototype.battleRound = 0;
    
        /**
         * PB_SCBattleReport rewardList.
         * @member {Array.<IPB_SCBattleReward>} rewardList
         * @memberof PB_SCBattleReport
         * @instance
         */
        PB_SCBattleReport.prototype.rewardList = $util.emptyArray;
    
        /**
         * PB_SCBattleReport battleParam.
         * @member {Array.<number>} battleParam
         * @memberof PB_SCBattleReport
         * @instance
         */
        PB_SCBattleReport.prototype.battleParam = $util.emptyArray;
    
        /**
         * PB_SCBattleReport arenaScoreChange.
         * @member {number} arenaScoreChange
         * @memberof PB_SCBattleReport
         * @instance
         */
        PB_SCBattleReport.prototype.arenaScoreChange = 0;
    
        /**
         * Creates a new PB_SCBattleReport instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleReport
         * @static
         * @param {IPB_SCBattleReport=} [properties] Properties to set
         * @returns {PB_SCBattleReport} PB_SCBattleReport instance
         */
        PB_SCBattleReport.create = function create(properties) {
            return new PB_SCBattleReport(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleReport message. Does not implicitly {@link PB_SCBattleReport.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleReport
         * @static
         * @param {IPB_SCBattleReport} message PB_SCBattleReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.battleResult != null && Object.hasOwnProperty.call(message, "battleResult"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.battleResult);
            if (message.battleMode != null && Object.hasOwnProperty.call(message, "battleMode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.battleMode);
            if (message.battleRound != null && Object.hasOwnProperty.call(message, "battleRound"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.battleRound);
            if (message.rewardList != null && message.rewardList.length)
                for (var i = 0; i < message.rewardList.length; ++i)
                    $root.PB_SCBattleReward.encode(message.rewardList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.battleParam != null && message.battleParam.length)
                for (var i = 0; i < message.battleParam.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.battleParam[i]);
            if (message.arenaScoreChange != null && Object.hasOwnProperty.call(message, "arenaScoreChange"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.arenaScoreChange);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleReport message, length delimited. Does not implicitly {@link PB_SCBattleReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleReport
         * @static
         * @param {IPB_SCBattleReport} message PB_SCBattleReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleReport message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleReport} PB_SCBattleReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleReport();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.battleResult = reader.int32();
                    break;
                case 2:
                    message.battleMode = reader.int32();
                    break;
                case 3:
                    message.battleRound = reader.int32();
                    break;
                case 4:
                    if (!(message.rewardList && message.rewardList.length))
                        message.rewardList = [];
                    message.rewardList.push($root.PB_SCBattleReward.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.battleParam && message.battleParam.length))
                        message.battleParam = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.battleParam.push(reader.int32());
                    } else
                        message.battleParam.push(reader.int32());
                    break;
                case 6:
                    message.arenaScoreChange = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleReport} PB_SCBattleReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleReport message.
         * @function verify
         * @memberof PB_SCBattleReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.battleResult != null && message.hasOwnProperty("battleResult"))
                if (!$util.isInteger(message.battleResult))
                    return "battleResult: integer expected";
            if (message.battleMode != null && message.hasOwnProperty("battleMode"))
                if (!$util.isInteger(message.battleMode))
                    return "battleMode: integer expected";
            if (message.battleRound != null && message.hasOwnProperty("battleRound"))
                if (!$util.isInteger(message.battleRound))
                    return "battleRound: integer expected";
            if (message.rewardList != null && message.hasOwnProperty("rewardList")) {
                if (!Array.isArray(message.rewardList))
                    return "rewardList: array expected";
                for (var i = 0; i < message.rewardList.length; ++i) {
                    var error = $root.PB_SCBattleReward.verify(message.rewardList[i]);
                    if (error)
                        return "rewardList." + error;
                }
            }
            if (message.battleParam != null && message.hasOwnProperty("battleParam")) {
                if (!Array.isArray(message.battleParam))
                    return "battleParam: array expected";
                for (var i = 0; i < message.battleParam.length; ++i)
                    if (!$util.isInteger(message.battleParam[i]))
                        return "battleParam: integer[] expected";
            }
            if (message.arenaScoreChange != null && message.hasOwnProperty("arenaScoreChange"))
                if (!$util.isInteger(message.arenaScoreChange))
                    return "arenaScoreChange: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCBattleReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleReport} PB_SCBattleReport
         */
        PB_SCBattleReport.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleReport)
                return object;
            var message = new $root.PB_SCBattleReport();
            if (object.battleResult != null)
                message.battleResult = object.battleResult | 0;
            if (object.battleMode != null)
                message.battleMode = object.battleMode | 0;
            if (object.battleRound != null)
                message.battleRound = object.battleRound | 0;
            if (object.rewardList) {
                if (!Array.isArray(object.rewardList))
                    throw TypeError(".PB_SCBattleReport.rewardList: array expected");
                message.rewardList = [];
                for (var i = 0; i < object.rewardList.length; ++i) {
                    if (typeof object.rewardList[i] !== "object")
                        throw TypeError(".PB_SCBattleReport.rewardList: object expected");
                    message.rewardList[i] = $root.PB_SCBattleReward.fromObject(object.rewardList[i]);
                }
            }
            if (object.battleParam) {
                if (!Array.isArray(object.battleParam))
                    throw TypeError(".PB_SCBattleReport.battleParam: array expected");
                message.battleParam = [];
                for (var i = 0; i < object.battleParam.length; ++i)
                    message.battleParam[i] = object.battleParam[i] | 0;
            }
            if (object.arenaScoreChange != null)
                message.arenaScoreChange = object.arenaScoreChange | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCBattleReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleReport
         * @static
         * @param {PB_SCBattleReport} message PB_SCBattleReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.rewardList = [];
                object.battleParam = [];
            }
            if (options.defaults) {
                object.battleResult = 0;
                object.battleMode = 0;
                object.battleRound = 0;
                object.arenaScoreChange = 0;
            }
            if (message.battleResult != null && message.hasOwnProperty("battleResult"))
                object.battleResult = message.battleResult;
            if (message.battleMode != null && message.hasOwnProperty("battleMode"))
                object.battleMode = message.battleMode;
            if (message.battleRound != null && message.hasOwnProperty("battleRound"))
                object.battleRound = message.battleRound;
            if (message.rewardList && message.rewardList.length) {
                object.rewardList = [];
                for (var j = 0; j < message.rewardList.length; ++j)
                    object.rewardList[j] = $root.PB_SCBattleReward.toObject(message.rewardList[j], options);
            }
            if (message.battleParam && message.battleParam.length) {
                object.battleParam = [];
                for (var j = 0; j < message.battleParam.length; ++j)
                    object.battleParam[j] = message.battleParam[j];
            }
            if (message.arenaScoreChange != null && message.hasOwnProperty("arenaScoreChange"))
                object.arenaScoreChange = message.arenaScoreChange;
            return object;
        };
    
        /**
         * Converts this PB_SCBattleReport to JSON.
         * @function toJSON
         * @memberof PB_SCBattleReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleReport;
    })();
    
    $root.PB_SCBattleAttackInfo = (function() {
    
        /**
         * Properties of a PB_SCBattleAttackInfo.
         * @exports IPB_SCBattleAttackInfo
         * @interface IPB_SCBattleAttackInfo
         * @property {number|null} [heroIndex] PB_SCBattleAttackInfo heroIndex
         * @property {number|null} [attackerTime] PB_SCBattleAttackInfo attackerTime
         * @property {number|null} [damage] PB_SCBattleAttackInfo damage
         */
    
        /**
         * Constructs a new PB_SCBattleAttackInfo.
         * @exports PB_SCBattleAttackInfo
         * @classdesc Represents a PB_SCBattleAttackInfo.
         * @implements IPB_SCBattleAttackInfo
         * @constructor
         * @param {IPB_SCBattleAttackInfo=} [properties] Properties to set
         */
        function PB_SCBattleAttackInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCBattleAttackInfo heroIndex.
         * @member {number} heroIndex
         * @memberof PB_SCBattleAttackInfo
         * @instance
         */
        PB_SCBattleAttackInfo.prototype.heroIndex = 0;
    
        /**
         * PB_SCBattleAttackInfo attackerTime.
         * @member {number} attackerTime
         * @memberof PB_SCBattleAttackInfo
         * @instance
         */
        PB_SCBattleAttackInfo.prototype.attackerTime = 0;
    
        /**
         * PB_SCBattleAttackInfo damage.
         * @member {number} damage
         * @memberof PB_SCBattleAttackInfo
         * @instance
         */
        PB_SCBattleAttackInfo.prototype.damage = 0;
    
        /**
         * Creates a new PB_SCBattleAttackInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleAttackInfo
         * @static
         * @param {IPB_SCBattleAttackInfo=} [properties] Properties to set
         * @returns {PB_SCBattleAttackInfo} PB_SCBattleAttackInfo instance
         */
        PB_SCBattleAttackInfo.create = function create(properties) {
            return new PB_SCBattleAttackInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleAttackInfo message. Does not implicitly {@link PB_SCBattleAttackInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleAttackInfo
         * @static
         * @param {IPB_SCBattleAttackInfo} message PB_SCBattleAttackInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleAttackInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroIndex != null && Object.hasOwnProperty.call(message, "heroIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.heroIndex);
            if (message.attackerTime != null && Object.hasOwnProperty.call(message, "attackerTime"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.attackerTime);
            if (message.damage != null && Object.hasOwnProperty.call(message, "damage"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.damage);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleAttackInfo message, length delimited. Does not implicitly {@link PB_SCBattleAttackInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleAttackInfo
         * @static
         * @param {IPB_SCBattleAttackInfo} message PB_SCBattleAttackInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleAttackInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleAttackInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleAttackInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleAttackInfo} PB_SCBattleAttackInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleAttackInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleAttackInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroIndex = reader.int32();
                    break;
                case 2:
                    message.attackerTime = reader.double();
                    break;
                case 3:
                    message.damage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleAttackInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleAttackInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleAttackInfo} PB_SCBattleAttackInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleAttackInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleAttackInfo message.
         * @function verify
         * @memberof PB_SCBattleAttackInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleAttackInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroIndex != null && message.hasOwnProperty("heroIndex"))
                if (!$util.isInteger(message.heroIndex))
                    return "heroIndex: integer expected";
            if (message.attackerTime != null && message.hasOwnProperty("attackerTime"))
                if (typeof message.attackerTime !== "number")
                    return "attackerTime: number expected";
            if (message.damage != null && message.hasOwnProperty("damage"))
                if (!$util.isInteger(message.damage))
                    return "damage: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCBattleAttackInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleAttackInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleAttackInfo} PB_SCBattleAttackInfo
         */
        PB_SCBattleAttackInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleAttackInfo)
                return object;
            var message = new $root.PB_SCBattleAttackInfo();
            if (object.heroIndex != null)
                message.heroIndex = object.heroIndex | 0;
            if (object.attackerTime != null)
                message.attackerTime = Number(object.attackerTime);
            if (object.damage != null)
                message.damage = object.damage | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCBattleAttackInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleAttackInfo
         * @static
         * @param {PB_SCBattleAttackInfo} message PB_SCBattleAttackInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleAttackInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heroIndex = 0;
                object.attackerTime = 0;
                object.damage = 0;
            }
            if (message.heroIndex != null && message.hasOwnProperty("heroIndex"))
                object.heroIndex = message.heroIndex;
            if (message.attackerTime != null && message.hasOwnProperty("attackerTime"))
                object.attackerTime = options.json && !isFinite(message.attackerTime) ? String(message.attackerTime) : message.attackerTime;
            if (message.damage != null && message.hasOwnProperty("damage"))
                object.damage = message.damage;
            return object;
        };
    
        /**
         * Converts this PB_SCBattleAttackInfo to JSON.
         * @function toJSON
         * @memberof PB_SCBattleAttackInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleAttackInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleAttackInfo;
    })();
    
    $root.PB_SCBattleMonsterInfo = (function() {
    
        /**
         * Properties of a PB_SCBattleMonsterInfo.
         * @exports IPB_SCBattleMonsterInfo
         * @interface IPB_SCBattleMonsterInfo
         * @property {number|null} [id] PB_SCBattleMonsterInfo id
         * @property {number|null} [hp] PB_SCBattleMonsterInfo hp
         * @property {Array.<IPB_SCBattleAttackInfo>|null} [attackList] PB_SCBattleMonsterInfo attackList
         */
    
        /**
         * Constructs a new PB_SCBattleMonsterInfo.
         * @exports PB_SCBattleMonsterInfo
         * @classdesc Represents a PB_SCBattleMonsterInfo.
         * @implements IPB_SCBattleMonsterInfo
         * @constructor
         * @param {IPB_SCBattleMonsterInfo=} [properties] Properties to set
         */
        function PB_SCBattleMonsterInfo(properties) {
            this.attackList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCBattleMonsterInfo id.
         * @member {number} id
         * @memberof PB_SCBattleMonsterInfo
         * @instance
         */
        PB_SCBattleMonsterInfo.prototype.id = 0;
    
        /**
         * PB_SCBattleMonsterInfo hp.
         * @member {number} hp
         * @memberof PB_SCBattleMonsterInfo
         * @instance
         */
        PB_SCBattleMonsterInfo.prototype.hp = 0;
    
        /**
         * PB_SCBattleMonsterInfo attackList.
         * @member {Array.<IPB_SCBattleAttackInfo>} attackList
         * @memberof PB_SCBattleMonsterInfo
         * @instance
         */
        PB_SCBattleMonsterInfo.prototype.attackList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCBattleMonsterInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleMonsterInfo
         * @static
         * @param {IPB_SCBattleMonsterInfo=} [properties] Properties to set
         * @returns {PB_SCBattleMonsterInfo} PB_SCBattleMonsterInfo instance
         */
        PB_SCBattleMonsterInfo.create = function create(properties) {
            return new PB_SCBattleMonsterInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleMonsterInfo message. Does not implicitly {@link PB_SCBattleMonsterInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleMonsterInfo
         * @static
         * @param {IPB_SCBattleMonsterInfo} message PB_SCBattleMonsterInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleMonsterInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hp);
            if (message.attackList != null && message.attackList.length)
                for (var i = 0; i < message.attackList.length; ++i)
                    $root.PB_SCBattleAttackInfo.encode(message.attackList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleMonsterInfo message, length delimited. Does not implicitly {@link PB_SCBattleMonsterInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleMonsterInfo
         * @static
         * @param {IPB_SCBattleMonsterInfo} message PB_SCBattleMonsterInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleMonsterInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleMonsterInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleMonsterInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleMonsterInfo} PB_SCBattleMonsterInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleMonsterInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleMonsterInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.hp = reader.int32();
                    break;
                case 3:
                    if (!(message.attackList && message.attackList.length))
                        message.attackList = [];
                    message.attackList.push($root.PB_SCBattleAttackInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleMonsterInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleMonsterInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleMonsterInfo} PB_SCBattleMonsterInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleMonsterInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleMonsterInfo message.
         * @function verify
         * @memberof PB_SCBattleMonsterInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleMonsterInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.attackList != null && message.hasOwnProperty("attackList")) {
                if (!Array.isArray(message.attackList))
                    return "attackList: array expected";
                for (var i = 0; i < message.attackList.length; ++i) {
                    var error = $root.PB_SCBattleAttackInfo.verify(message.attackList[i]);
                    if (error)
                        return "attackList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCBattleMonsterInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleMonsterInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleMonsterInfo} PB_SCBattleMonsterInfo
         */
        PB_SCBattleMonsterInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleMonsterInfo)
                return object;
            var message = new $root.PB_SCBattleMonsterInfo();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.hp != null)
                message.hp = object.hp | 0;
            if (object.attackList) {
                if (!Array.isArray(object.attackList))
                    throw TypeError(".PB_SCBattleMonsterInfo.attackList: array expected");
                message.attackList = [];
                for (var i = 0; i < object.attackList.length; ++i) {
                    if (typeof object.attackList[i] !== "object")
                        throw TypeError(".PB_SCBattleMonsterInfo.attackList: object expected");
                    message.attackList[i] = $root.PB_SCBattleAttackInfo.fromObject(object.attackList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCBattleMonsterInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleMonsterInfo
         * @static
         * @param {PB_SCBattleMonsterInfo} message PB_SCBattleMonsterInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleMonsterInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.attackList = [];
            if (options.defaults) {
                object.id = 0;
                object.hp = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.attackList && message.attackList.length) {
                object.attackList = [];
                for (var j = 0; j < message.attackList.length; ++j)
                    object.attackList[j] = $root.PB_SCBattleAttackInfo.toObject(message.attackList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCBattleMonsterInfo to JSON.
         * @function toJSON
         * @memberof PB_SCBattleMonsterInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleMonsterInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleMonsterInfo;
    })();
    
    $root.PB_SCBattleMoveNode = (function() {
    
        /**
         * Properties of a PB_SCBattleMoveNode.
         * @exports IPB_SCBattleMoveNode
         * @interface IPB_SCBattleMoveNode
         * @property {number|null} [heroIndex] PB_SCBattleMoveNode heroIndex
         * @property {number|null} [moveDir] PB_SCBattleMoveNode moveDir
         */
    
        /**
         * Constructs a new PB_SCBattleMoveNode.
         * @exports PB_SCBattleMoveNode
         * @classdesc Represents a PB_SCBattleMoveNode.
         * @implements IPB_SCBattleMoveNode
         * @constructor
         * @param {IPB_SCBattleMoveNode=} [properties] Properties to set
         */
        function PB_SCBattleMoveNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCBattleMoveNode heroIndex.
         * @member {number} heroIndex
         * @memberof PB_SCBattleMoveNode
         * @instance
         */
        PB_SCBattleMoveNode.prototype.heroIndex = 0;
    
        /**
         * PB_SCBattleMoveNode moveDir.
         * @member {number} moveDir
         * @memberof PB_SCBattleMoveNode
         * @instance
         */
        PB_SCBattleMoveNode.prototype.moveDir = 0;
    
        /**
         * Creates a new PB_SCBattleMoveNode instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleMoveNode
         * @static
         * @param {IPB_SCBattleMoveNode=} [properties] Properties to set
         * @returns {PB_SCBattleMoveNode} PB_SCBattleMoveNode instance
         */
        PB_SCBattleMoveNode.create = function create(properties) {
            return new PB_SCBattleMoveNode(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleMoveNode message. Does not implicitly {@link PB_SCBattleMoveNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleMoveNode
         * @static
         * @param {IPB_SCBattleMoveNode} message PB_SCBattleMoveNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleMoveNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroIndex != null && Object.hasOwnProperty.call(message, "heroIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.heroIndex);
            if (message.moveDir != null && Object.hasOwnProperty.call(message, "moveDir"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.moveDir);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleMoveNode message, length delimited. Does not implicitly {@link PB_SCBattleMoveNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleMoveNode
         * @static
         * @param {IPB_SCBattleMoveNode} message PB_SCBattleMoveNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleMoveNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleMoveNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleMoveNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleMoveNode} PB_SCBattleMoveNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleMoveNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleMoveNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroIndex = reader.int32();
                    break;
                case 2:
                    message.moveDir = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleMoveNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleMoveNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleMoveNode} PB_SCBattleMoveNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleMoveNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleMoveNode message.
         * @function verify
         * @memberof PB_SCBattleMoveNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleMoveNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroIndex != null && message.hasOwnProperty("heroIndex"))
                if (!$util.isInteger(message.heroIndex))
                    return "heroIndex: integer expected";
            if (message.moveDir != null && message.hasOwnProperty("moveDir"))
                if (!$util.isInteger(message.moveDir))
                    return "moveDir: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCBattleMoveNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleMoveNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleMoveNode} PB_SCBattleMoveNode
         */
        PB_SCBattleMoveNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleMoveNode)
                return object;
            var message = new $root.PB_SCBattleMoveNode();
            if (object.heroIndex != null)
                message.heroIndex = object.heroIndex | 0;
            if (object.moveDir != null)
                message.moveDir = object.moveDir | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCBattleMoveNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleMoveNode
         * @static
         * @param {PB_SCBattleMoveNode} message PB_SCBattleMoveNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleMoveNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heroIndex = 0;
                object.moveDir = 0;
            }
            if (message.heroIndex != null && message.hasOwnProperty("heroIndex"))
                object.heroIndex = message.heroIndex;
            if (message.moveDir != null && message.hasOwnProperty("moveDir"))
                object.moveDir = message.moveDir;
            return object;
        };
    
        /**
         * Converts this PB_SCBattleMoveNode to JSON.
         * @function toJSON
         * @memberof PB_SCBattleMoveNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleMoveNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleMoveNode;
    })();
    
    $root.PB_SCBattleHero = (function() {
    
        /**
         * Properties of a PB_SCBattleHero.
         * @exports IPB_SCBattleHero
         * @interface IPB_SCBattleHero
         * @property {number|null} [heroId] PB_SCBattleHero heroId
         * @property {number|null} [heroLevel] PB_SCBattleHero heroLevel
         * @property {number|null} [heroStage] PB_SCBattleHero heroStage
         */
    
        /**
         * Constructs a new PB_SCBattleHero.
         * @exports PB_SCBattleHero
         * @classdesc Represents a PB_SCBattleHero.
         * @implements IPB_SCBattleHero
         * @constructor
         * @param {IPB_SCBattleHero=} [properties] Properties to set
         */
        function PB_SCBattleHero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCBattleHero heroId.
         * @member {number} heroId
         * @memberof PB_SCBattleHero
         * @instance
         */
        PB_SCBattleHero.prototype.heroId = 0;
    
        /**
         * PB_SCBattleHero heroLevel.
         * @member {number} heroLevel
         * @memberof PB_SCBattleHero
         * @instance
         */
        PB_SCBattleHero.prototype.heroLevel = 0;
    
        /**
         * PB_SCBattleHero heroStage.
         * @member {number} heroStage
         * @memberof PB_SCBattleHero
         * @instance
         */
        PB_SCBattleHero.prototype.heroStage = 0;
    
        /**
         * Creates a new PB_SCBattleHero instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleHero
         * @static
         * @param {IPB_SCBattleHero=} [properties] Properties to set
         * @returns {PB_SCBattleHero} PB_SCBattleHero instance
         */
        PB_SCBattleHero.create = function create(properties) {
            return new PB_SCBattleHero(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleHero message. Does not implicitly {@link PB_SCBattleHero.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleHero
         * @static
         * @param {IPB_SCBattleHero} message PB_SCBattleHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleHero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.heroId);
            if (message.heroLevel != null && Object.hasOwnProperty.call(message, "heroLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroLevel);
            if (message.heroStage != null && Object.hasOwnProperty.call(message, "heroStage"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.heroStage);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleHero message, length delimited. Does not implicitly {@link PB_SCBattleHero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleHero
         * @static
         * @param {IPB_SCBattleHero} message PB_SCBattleHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleHero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleHero message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleHero} PB_SCBattleHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleHero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleHero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroId = reader.int32();
                    break;
                case 2:
                    message.heroLevel = reader.int32();
                    break;
                case 3:
                    message.heroStage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleHero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleHero} PB_SCBattleHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleHero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleHero message.
         * @function verify
         * @memberof PB_SCBattleHero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleHero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                if (!$util.isInteger(message.heroLevel))
                    return "heroLevel: integer expected";
            if (message.heroStage != null && message.hasOwnProperty("heroStage"))
                if (!$util.isInteger(message.heroStage))
                    return "heroStage: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCBattleHero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleHero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleHero} PB_SCBattleHero
         */
        PB_SCBattleHero.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleHero)
                return object;
            var message = new $root.PB_SCBattleHero();
            if (object.heroId != null)
                message.heroId = object.heroId | 0;
            if (object.heroLevel != null)
                message.heroLevel = object.heroLevel | 0;
            if (object.heroStage != null)
                message.heroStage = object.heroStage | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCBattleHero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleHero
         * @static
         * @param {PB_SCBattleHero} message PB_SCBattleHero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleHero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heroId = 0;
                object.heroLevel = 0;
                object.heroStage = 0;
            }
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                object.heroLevel = message.heroLevel;
            if (message.heroStage != null && message.hasOwnProperty("heroStage"))
                object.heroStage = message.heroStage;
            return object;
        };
    
        /**
         * Converts this PB_SCBattleHero to JSON.
         * @function toJSON
         * @memberof PB_SCBattleHero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleHero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleHero;
    })();
    
    $root.PB_SCBattleRoundInfo = (function() {
    
        /**
         * Properties of a PB_SCBattleRoundInfo.
         * @exports IPB_SCBattleRoundInfo
         * @interface IPB_SCBattleRoundInfo
         * @property {number|null} [totalTime] PB_SCBattleRoundInfo totalTime
         * @property {Array.<IPB_SCBattleHero>|null} [heroList] PB_SCBattleRoundInfo heroList
         * @property {Array.<IPB_SCBattleMonsterInfo>|null} [monsterList] PB_SCBattleRoundInfo monsterList
         * @property {Array.<number>|null} [buffId] PB_SCBattleRoundInfo buffId
         * @property {Array.<IPB_SCBattleMoveNode>|null} [moveList] PB_SCBattleRoundInfo moveList
         * @property {number|null} [comboAddStep] PB_SCBattleRoundInfo comboAddStep
         */
    
        /**
         * Constructs a new PB_SCBattleRoundInfo.
         * @exports PB_SCBattleRoundInfo
         * @classdesc Represents a PB_SCBattleRoundInfo.
         * @implements IPB_SCBattleRoundInfo
         * @constructor
         * @param {IPB_SCBattleRoundInfo=} [properties] Properties to set
         */
        function PB_SCBattleRoundInfo(properties) {
            this.heroList = [];
            this.monsterList = [];
            this.buffId = [];
            this.moveList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCBattleRoundInfo totalTime.
         * @member {number} totalTime
         * @memberof PB_SCBattleRoundInfo
         * @instance
         */
        PB_SCBattleRoundInfo.prototype.totalTime = 0;
    
        /**
         * PB_SCBattleRoundInfo heroList.
         * @member {Array.<IPB_SCBattleHero>} heroList
         * @memberof PB_SCBattleRoundInfo
         * @instance
         */
        PB_SCBattleRoundInfo.prototype.heroList = $util.emptyArray;
    
        /**
         * PB_SCBattleRoundInfo monsterList.
         * @member {Array.<IPB_SCBattleMonsterInfo>} monsterList
         * @memberof PB_SCBattleRoundInfo
         * @instance
         */
        PB_SCBattleRoundInfo.prototype.monsterList = $util.emptyArray;
    
        /**
         * PB_SCBattleRoundInfo buffId.
         * @member {Array.<number>} buffId
         * @memberof PB_SCBattleRoundInfo
         * @instance
         */
        PB_SCBattleRoundInfo.prototype.buffId = $util.emptyArray;
    
        /**
         * PB_SCBattleRoundInfo moveList.
         * @member {Array.<IPB_SCBattleMoveNode>} moveList
         * @memberof PB_SCBattleRoundInfo
         * @instance
         */
        PB_SCBattleRoundInfo.prototype.moveList = $util.emptyArray;
    
        /**
         * PB_SCBattleRoundInfo comboAddStep.
         * @member {number} comboAddStep
         * @memberof PB_SCBattleRoundInfo
         * @instance
         */
        PB_SCBattleRoundInfo.prototype.comboAddStep = 0;
    
        /**
         * Creates a new PB_SCBattleRoundInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleRoundInfo
         * @static
         * @param {IPB_SCBattleRoundInfo=} [properties] Properties to set
         * @returns {PB_SCBattleRoundInfo} PB_SCBattleRoundInfo instance
         */
        PB_SCBattleRoundInfo.create = function create(properties) {
            return new PB_SCBattleRoundInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleRoundInfo message. Does not implicitly {@link PB_SCBattleRoundInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleRoundInfo
         * @static
         * @param {IPB_SCBattleRoundInfo} message PB_SCBattleRoundInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleRoundInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalTime != null && Object.hasOwnProperty.call(message, "totalTime"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.totalTime);
            if (message.heroList != null && message.heroList.length)
                for (var i = 0; i < message.heroList.length; ++i)
                    $root.PB_SCBattleHero.encode(message.heroList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.monsterList != null && message.monsterList.length)
                for (var i = 0; i < message.monsterList.length; ++i)
                    $root.PB_SCBattleMonsterInfo.encode(message.monsterList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.buffId != null && message.buffId.length)
                for (var i = 0; i < message.buffId.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.buffId[i]);
            if (message.moveList != null && message.moveList.length)
                for (var i = 0; i < message.moveList.length; ++i)
                    $root.PB_SCBattleMoveNode.encode(message.moveList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.comboAddStep != null && Object.hasOwnProperty.call(message, "comboAddStep"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.comboAddStep);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleRoundInfo message, length delimited. Does not implicitly {@link PB_SCBattleRoundInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleRoundInfo
         * @static
         * @param {IPB_SCBattleRoundInfo} message PB_SCBattleRoundInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleRoundInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleRoundInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleRoundInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleRoundInfo} PB_SCBattleRoundInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleRoundInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleRoundInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalTime = reader.double();
                    break;
                case 2:
                    if (!(message.heroList && message.heroList.length))
                        message.heroList = [];
                    message.heroList.push($root.PB_SCBattleHero.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.monsterList && message.monsterList.length))
                        message.monsterList = [];
                    message.monsterList.push($root.PB_SCBattleMonsterInfo.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.buffId && message.buffId.length))
                        message.buffId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.buffId.push(reader.int32());
                    } else
                        message.buffId.push(reader.int32());
                    break;
                case 5:
                    if (!(message.moveList && message.moveList.length))
                        message.moveList = [];
                    message.moveList.push($root.PB_SCBattleMoveNode.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.comboAddStep = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleRoundInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleRoundInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleRoundInfo} PB_SCBattleRoundInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleRoundInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleRoundInfo message.
         * @function verify
         * @memberof PB_SCBattleRoundInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleRoundInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalTime != null && message.hasOwnProperty("totalTime"))
                if (typeof message.totalTime !== "number")
                    return "totalTime: number expected";
            if (message.heroList != null && message.hasOwnProperty("heroList")) {
                if (!Array.isArray(message.heroList))
                    return "heroList: array expected";
                for (var i = 0; i < message.heroList.length; ++i) {
                    var error = $root.PB_SCBattleHero.verify(message.heroList[i]);
                    if (error)
                        return "heroList." + error;
                }
            }
            if (message.monsterList != null && message.hasOwnProperty("monsterList")) {
                if (!Array.isArray(message.monsterList))
                    return "monsterList: array expected";
                for (var i = 0; i < message.monsterList.length; ++i) {
                    var error = $root.PB_SCBattleMonsterInfo.verify(message.monsterList[i]);
                    if (error)
                        return "monsterList." + error;
                }
            }
            if (message.buffId != null && message.hasOwnProperty("buffId")) {
                if (!Array.isArray(message.buffId))
                    return "buffId: array expected";
                for (var i = 0; i < message.buffId.length; ++i)
                    if (!$util.isInteger(message.buffId[i]))
                        return "buffId: integer[] expected";
            }
            if (message.moveList != null && message.hasOwnProperty("moveList")) {
                if (!Array.isArray(message.moveList))
                    return "moveList: array expected";
                for (var i = 0; i < message.moveList.length; ++i) {
                    var error = $root.PB_SCBattleMoveNode.verify(message.moveList[i]);
                    if (error)
                        return "moveList." + error;
                }
            }
            if (message.comboAddStep != null && message.hasOwnProperty("comboAddStep"))
                if (!$util.isInteger(message.comboAddStep))
                    return "comboAddStep: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCBattleRoundInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleRoundInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleRoundInfo} PB_SCBattleRoundInfo
         */
        PB_SCBattleRoundInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleRoundInfo)
                return object;
            var message = new $root.PB_SCBattleRoundInfo();
            if (object.totalTime != null)
                message.totalTime = Number(object.totalTime);
            if (object.heroList) {
                if (!Array.isArray(object.heroList))
                    throw TypeError(".PB_SCBattleRoundInfo.heroList: array expected");
                message.heroList = [];
                for (var i = 0; i < object.heroList.length; ++i) {
                    if (typeof object.heroList[i] !== "object")
                        throw TypeError(".PB_SCBattleRoundInfo.heroList: object expected");
                    message.heroList[i] = $root.PB_SCBattleHero.fromObject(object.heroList[i]);
                }
            }
            if (object.monsterList) {
                if (!Array.isArray(object.monsterList))
                    throw TypeError(".PB_SCBattleRoundInfo.monsterList: array expected");
                message.monsterList = [];
                for (var i = 0; i < object.monsterList.length; ++i) {
                    if (typeof object.monsterList[i] !== "object")
                        throw TypeError(".PB_SCBattleRoundInfo.monsterList: object expected");
                    message.monsterList[i] = $root.PB_SCBattleMonsterInfo.fromObject(object.monsterList[i]);
                }
            }
            if (object.buffId) {
                if (!Array.isArray(object.buffId))
                    throw TypeError(".PB_SCBattleRoundInfo.buffId: array expected");
                message.buffId = [];
                for (var i = 0; i < object.buffId.length; ++i)
                    message.buffId[i] = object.buffId[i] | 0;
            }
            if (object.moveList) {
                if (!Array.isArray(object.moveList))
                    throw TypeError(".PB_SCBattleRoundInfo.moveList: array expected");
                message.moveList = [];
                for (var i = 0; i < object.moveList.length; ++i) {
                    if (typeof object.moveList[i] !== "object")
                        throw TypeError(".PB_SCBattleRoundInfo.moveList: object expected");
                    message.moveList[i] = $root.PB_SCBattleMoveNode.fromObject(object.moveList[i]);
                }
            }
            if (object.comboAddStep != null)
                message.comboAddStep = object.comboAddStep | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCBattleRoundInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleRoundInfo
         * @static
         * @param {PB_SCBattleRoundInfo} message PB_SCBattleRoundInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleRoundInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.heroList = [];
                object.monsterList = [];
                object.buffId = [];
                object.moveList = [];
            }
            if (options.defaults) {
                object.totalTime = 0;
                object.comboAddStep = 0;
            }
            if (message.totalTime != null && message.hasOwnProperty("totalTime"))
                object.totalTime = options.json && !isFinite(message.totalTime) ? String(message.totalTime) : message.totalTime;
            if (message.heroList && message.heroList.length) {
                object.heroList = [];
                for (var j = 0; j < message.heroList.length; ++j)
                    object.heroList[j] = $root.PB_SCBattleHero.toObject(message.heroList[j], options);
            }
            if (message.monsterList && message.monsterList.length) {
                object.monsterList = [];
                for (var j = 0; j < message.monsterList.length; ++j)
                    object.monsterList[j] = $root.PB_SCBattleMonsterInfo.toObject(message.monsterList[j], options);
            }
            if (message.buffId && message.buffId.length) {
                object.buffId = [];
                for (var j = 0; j < message.buffId.length; ++j)
                    object.buffId[j] = message.buffId[j];
            }
            if (message.moveList && message.moveList.length) {
                object.moveList = [];
                for (var j = 0; j < message.moveList.length; ++j)
                    object.moveList[j] = $root.PB_SCBattleMoveNode.toObject(message.moveList[j], options);
            }
            if (message.comboAddStep != null && message.hasOwnProperty("comboAddStep"))
                object.comboAddStep = message.comboAddStep;
            return object;
        };
    
        /**
         * Converts this PB_SCBattleRoundInfo to JSON.
         * @function toJSON
         * @memberof PB_SCBattleRoundInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleRoundInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleRoundInfo;
    })();
    
    $root.PB_CSDailyTaskReq = (function() {
    
        /**
         * Properties of a PB_CSDailyTaskReq.
         * @exports IPB_CSDailyTaskReq
         * @interface IPB_CSDailyTaskReq
         * @property {number|null} [reqType] PB_CSDailyTaskReq reqType
         * @property {number|null} [p1] PB_CSDailyTaskReq p1
         */
    
        /**
         * Constructs a new PB_CSDailyTaskReq.
         * @exports PB_CSDailyTaskReq
         * @classdesc Represents a PB_CSDailyTaskReq.
         * @implements IPB_CSDailyTaskReq
         * @constructor
         * @param {IPB_CSDailyTaskReq=} [properties] Properties to set
         */
        function PB_CSDailyTaskReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSDailyTaskReq reqType.
         * @member {number} reqType
         * @memberof PB_CSDailyTaskReq
         * @instance
         */
        PB_CSDailyTaskReq.prototype.reqType = 0;
    
        /**
         * PB_CSDailyTaskReq p1.
         * @member {number} p1
         * @memberof PB_CSDailyTaskReq
         * @instance
         */
        PB_CSDailyTaskReq.prototype.p1 = 0;
    
        /**
         * Creates a new PB_CSDailyTaskReq instance using the specified properties.
         * @function create
         * @memberof PB_CSDailyTaskReq
         * @static
         * @param {IPB_CSDailyTaskReq=} [properties] Properties to set
         * @returns {PB_CSDailyTaskReq} PB_CSDailyTaskReq instance
         */
        PB_CSDailyTaskReq.create = function create(properties) {
            return new PB_CSDailyTaskReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSDailyTaskReq message. Does not implicitly {@link PB_CSDailyTaskReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSDailyTaskReq
         * @static
         * @param {IPB_CSDailyTaskReq} message PB_CSDailyTaskReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSDailyTaskReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.p1);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSDailyTaskReq message, length delimited. Does not implicitly {@link PB_CSDailyTaskReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSDailyTaskReq
         * @static
         * @param {IPB_CSDailyTaskReq} message PB_CSDailyTaskReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSDailyTaskReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSDailyTaskReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSDailyTaskReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSDailyTaskReq} PB_CSDailyTaskReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSDailyTaskReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSDailyTaskReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    message.p1 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSDailyTaskReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSDailyTaskReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSDailyTaskReq} PB_CSDailyTaskReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSDailyTaskReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSDailyTaskReq message.
         * @function verify
         * @memberof PB_CSDailyTaskReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSDailyTaskReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.p1 != null && message.hasOwnProperty("p1"))
                if (!$util.isInteger(message.p1))
                    return "p1: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSDailyTaskReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSDailyTaskReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSDailyTaskReq} PB_CSDailyTaskReq
         */
        PB_CSDailyTaskReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSDailyTaskReq)
                return object;
            var message = new $root.PB_CSDailyTaskReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.p1 != null)
                message.p1 = object.p1 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSDailyTaskReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSDailyTaskReq
         * @static
         * @param {PB_CSDailyTaskReq} message PB_CSDailyTaskReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSDailyTaskReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reqType = 0;
                object.p1 = 0;
            }
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = message.p1;
            return object;
        };
    
        /**
         * Converts this PB_CSDailyTaskReq to JSON.
         * @function toJSON
         * @memberof PB_CSDailyTaskReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSDailyTaskReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSDailyTaskReq;
    })();
    
    $root.PB_DailyTaskInfo = (function() {
    
        /**
         * Properties of a PB_DailyTaskInfo.
         * @exports IPB_DailyTaskInfo
         * @interface IPB_DailyTaskInfo
         * @property {number|null} [taskId] PB_DailyTaskInfo taskId
         * @property {number|null} [num] PB_DailyTaskInfo num
         * @property {number|null} [isFetch] PB_DailyTaskInfo isFetch
         */
    
        /**
         * Constructs a new PB_DailyTaskInfo.
         * @exports PB_DailyTaskInfo
         * @classdesc Represents a PB_DailyTaskInfo.
         * @implements IPB_DailyTaskInfo
         * @constructor
         * @param {IPB_DailyTaskInfo=} [properties] Properties to set
         */
        function PB_DailyTaskInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_DailyTaskInfo taskId.
         * @member {number} taskId
         * @memberof PB_DailyTaskInfo
         * @instance
         */
        PB_DailyTaskInfo.prototype.taskId = 0;
    
        /**
         * PB_DailyTaskInfo num.
         * @member {number} num
         * @memberof PB_DailyTaskInfo
         * @instance
         */
        PB_DailyTaskInfo.prototype.num = 0;
    
        /**
         * PB_DailyTaskInfo isFetch.
         * @member {number} isFetch
         * @memberof PB_DailyTaskInfo
         * @instance
         */
        PB_DailyTaskInfo.prototype.isFetch = 0;
    
        /**
         * Creates a new PB_DailyTaskInfo instance using the specified properties.
         * @function create
         * @memberof PB_DailyTaskInfo
         * @static
         * @param {IPB_DailyTaskInfo=} [properties] Properties to set
         * @returns {PB_DailyTaskInfo} PB_DailyTaskInfo instance
         */
        PB_DailyTaskInfo.create = function create(properties) {
            return new PB_DailyTaskInfo(properties);
        };
    
        /**
         * Encodes the specified PB_DailyTaskInfo message. Does not implicitly {@link PB_DailyTaskInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_DailyTaskInfo
         * @static
         * @param {IPB_DailyTaskInfo} message PB_DailyTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyTaskInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            if (message.isFetch != null && Object.hasOwnProperty.call(message, "isFetch"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isFetch);
            return writer;
        };
    
        /**
         * Encodes the specified PB_DailyTaskInfo message, length delimited. Does not implicitly {@link PB_DailyTaskInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_DailyTaskInfo
         * @static
         * @param {IPB_DailyTaskInfo} message PB_DailyTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyTaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_DailyTaskInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_DailyTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_DailyTaskInfo} PB_DailyTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyTaskInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_DailyTaskInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskId = reader.int32();
                    break;
                case 2:
                    message.num = reader.int32();
                    break;
                case 3:
                    message.isFetch = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_DailyTaskInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_DailyTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_DailyTaskInfo} PB_DailyTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyTaskInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_DailyTaskInfo message.
         * @function verify
         * @memberof PB_DailyTaskInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_DailyTaskInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                if (!$util.isInteger(message.taskId))
                    return "taskId: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                if (!$util.isInteger(message.isFetch))
                    return "isFetch: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_DailyTaskInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_DailyTaskInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_DailyTaskInfo} PB_DailyTaskInfo
         */
        PB_DailyTaskInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_DailyTaskInfo)
                return object;
            var message = new $root.PB_DailyTaskInfo();
            if (object.taskId != null)
                message.taskId = object.taskId | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.isFetch != null)
                message.isFetch = object.isFetch | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_DailyTaskInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_DailyTaskInfo
         * @static
         * @param {PB_DailyTaskInfo} message PB_DailyTaskInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_DailyTaskInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.taskId = 0;
                object.num = 0;
                object.isFetch = 0;
            }
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = message.taskId;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                object.isFetch = message.isFetch;
            return object;
        };
    
        /**
         * Converts this PB_DailyTaskInfo to JSON.
         * @function toJSON
         * @memberof PB_DailyTaskInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_DailyTaskInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_DailyTaskInfo;
    })();
    
    $root.PB_SCDailyTaskInfo = (function() {
    
        /**
         * Properties of a PB_SCDailyTaskInfo.
         * @exports IPB_SCDailyTaskInfo
         * @interface IPB_SCDailyTaskInfo
         * @property {Array.<IPB_DailyTaskInfo>|null} [taskList] PB_SCDailyTaskInfo taskList
         * @property {number|null} [adNum] PB_SCDailyTaskInfo adNum
         * @property {number|null} [taskNum] PB_SCDailyTaskInfo taskNum
         */
    
        /**
         * Constructs a new PB_SCDailyTaskInfo.
         * @exports PB_SCDailyTaskInfo
         * @classdesc Represents a PB_SCDailyTaskInfo.
         * @implements IPB_SCDailyTaskInfo
         * @constructor
         * @param {IPB_SCDailyTaskInfo=} [properties] Properties to set
         */
        function PB_SCDailyTaskInfo(properties) {
            this.taskList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCDailyTaskInfo taskList.
         * @member {Array.<IPB_DailyTaskInfo>} taskList
         * @memberof PB_SCDailyTaskInfo
         * @instance
         */
        PB_SCDailyTaskInfo.prototype.taskList = $util.emptyArray;
    
        /**
         * PB_SCDailyTaskInfo adNum.
         * @member {number} adNum
         * @memberof PB_SCDailyTaskInfo
         * @instance
         */
        PB_SCDailyTaskInfo.prototype.adNum = 0;
    
        /**
         * PB_SCDailyTaskInfo taskNum.
         * @member {number} taskNum
         * @memberof PB_SCDailyTaskInfo
         * @instance
         */
        PB_SCDailyTaskInfo.prototype.taskNum = 0;
    
        /**
         * Creates a new PB_SCDailyTaskInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCDailyTaskInfo
         * @static
         * @param {IPB_SCDailyTaskInfo=} [properties] Properties to set
         * @returns {PB_SCDailyTaskInfo} PB_SCDailyTaskInfo instance
         */
        PB_SCDailyTaskInfo.create = function create(properties) {
            return new PB_SCDailyTaskInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCDailyTaskInfo message. Does not implicitly {@link PB_SCDailyTaskInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCDailyTaskInfo
         * @static
         * @param {IPB_SCDailyTaskInfo} message PB_SCDailyTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCDailyTaskInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskList != null && message.taskList.length)
                for (var i = 0; i < message.taskList.length; ++i)
                    $root.PB_DailyTaskInfo.encode(message.taskList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.adNum != null && Object.hasOwnProperty.call(message, "adNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.adNum);
            if (message.taskNum != null && Object.hasOwnProperty.call(message, "taskNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.taskNum);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCDailyTaskInfo message, length delimited. Does not implicitly {@link PB_SCDailyTaskInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCDailyTaskInfo
         * @static
         * @param {IPB_SCDailyTaskInfo} message PB_SCDailyTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCDailyTaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCDailyTaskInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCDailyTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCDailyTaskInfo} PB_SCDailyTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCDailyTaskInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCDailyTaskInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.taskList && message.taskList.length))
                        message.taskList = [];
                    message.taskList.push($root.PB_DailyTaskInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.adNum = reader.int32();
                    break;
                case 3:
                    message.taskNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCDailyTaskInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCDailyTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCDailyTaskInfo} PB_SCDailyTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCDailyTaskInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCDailyTaskInfo message.
         * @function verify
         * @memberof PB_SCDailyTaskInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCDailyTaskInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskList != null && message.hasOwnProperty("taskList")) {
                if (!Array.isArray(message.taskList))
                    return "taskList: array expected";
                for (var i = 0; i < message.taskList.length; ++i) {
                    var error = $root.PB_DailyTaskInfo.verify(message.taskList[i]);
                    if (error)
                        return "taskList." + error;
                }
            }
            if (message.adNum != null && message.hasOwnProperty("adNum"))
                if (!$util.isInteger(message.adNum))
                    return "adNum: integer expected";
            if (message.taskNum != null && message.hasOwnProperty("taskNum"))
                if (!$util.isInteger(message.taskNum))
                    return "taskNum: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCDailyTaskInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCDailyTaskInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCDailyTaskInfo} PB_SCDailyTaskInfo
         */
        PB_SCDailyTaskInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCDailyTaskInfo)
                return object;
            var message = new $root.PB_SCDailyTaskInfo();
            if (object.taskList) {
                if (!Array.isArray(object.taskList))
                    throw TypeError(".PB_SCDailyTaskInfo.taskList: array expected");
                message.taskList = [];
                for (var i = 0; i < object.taskList.length; ++i) {
                    if (typeof object.taskList[i] !== "object")
                        throw TypeError(".PB_SCDailyTaskInfo.taskList: object expected");
                    message.taskList[i] = $root.PB_DailyTaskInfo.fromObject(object.taskList[i]);
                }
            }
            if (object.adNum != null)
                message.adNum = object.adNum | 0;
            if (object.taskNum != null)
                message.taskNum = object.taskNum | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCDailyTaskInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCDailyTaskInfo
         * @static
         * @param {PB_SCDailyTaskInfo} message PB_SCDailyTaskInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCDailyTaskInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.taskList = [];
            if (options.defaults) {
                object.adNum = 0;
                object.taskNum = 0;
            }
            if (message.taskList && message.taskList.length) {
                object.taskList = [];
                for (var j = 0; j < message.taskList.length; ++j)
                    object.taskList[j] = $root.PB_DailyTaskInfo.toObject(message.taskList[j], options);
            }
            if (message.adNum != null && message.hasOwnProperty("adNum"))
                object.adNum = message.adNum;
            if (message.taskNum != null && message.hasOwnProperty("taskNum"))
                object.taskNum = message.taskNum;
            return object;
        };
    
        /**
         * Converts this PB_SCDailyTaskInfo to JSON.
         * @function toJSON
         * @memberof PB_SCDailyTaskInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCDailyTaskInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCDailyTaskInfo;
    })();
    
    $root.PB_SCServerBusy = (function() {
    
        /**
         * Properties of a PB_SCServerBusy.
         * @exports IPB_SCServerBusy
         * @interface IPB_SCServerBusy
         * @property {number|null} [reserve] PB_SCServerBusy reserve
         */
    
        /**
         * Constructs a new PB_SCServerBusy.
         * @exports PB_SCServerBusy
         * @classdesc Represents a PB_SCServerBusy.
         * @implements IPB_SCServerBusy
         * @constructor
         * @param {IPB_SCServerBusy=} [properties] Properties to set
         */
        function PB_SCServerBusy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCServerBusy reserve.
         * @member {number} reserve
         * @memberof PB_SCServerBusy
         * @instance
         */
        PB_SCServerBusy.prototype.reserve = 0;
    
        /**
         * Creates a new PB_SCServerBusy instance using the specified properties.
         * @function create
         * @memberof PB_SCServerBusy
         * @static
         * @param {IPB_SCServerBusy=} [properties] Properties to set
         * @returns {PB_SCServerBusy} PB_SCServerBusy instance
         */
        PB_SCServerBusy.create = function create(properties) {
            return new PB_SCServerBusy(properties);
        };
    
        /**
         * Encodes the specified PB_SCServerBusy message. Does not implicitly {@link PB_SCServerBusy.verify|verify} messages.
         * @function encode
         * @memberof PB_SCServerBusy
         * @static
         * @param {IPB_SCServerBusy} message PB_SCServerBusy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCServerBusy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reserve != null && Object.hasOwnProperty.call(message, "reserve"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reserve);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCServerBusy message, length delimited. Does not implicitly {@link PB_SCServerBusy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCServerBusy
         * @static
         * @param {IPB_SCServerBusy} message PB_SCServerBusy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCServerBusy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCServerBusy message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCServerBusy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCServerBusy} PB_SCServerBusy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCServerBusy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCServerBusy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reserve = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCServerBusy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCServerBusy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCServerBusy} PB_SCServerBusy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCServerBusy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCServerBusy message.
         * @function verify
         * @memberof PB_SCServerBusy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCServerBusy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                if (!$util.isInteger(message.reserve))
                    return "reserve: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCServerBusy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCServerBusy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCServerBusy} PB_SCServerBusy
         */
        PB_SCServerBusy.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCServerBusy)
                return object;
            var message = new $root.PB_SCServerBusy();
            if (object.reserve != null)
                message.reserve = object.reserve | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCServerBusy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCServerBusy
         * @static
         * @param {PB_SCServerBusy} message PB_SCServerBusy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCServerBusy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reserve = 0;
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                object.reserve = message.reserve;
            return object;
        };
    
        /**
         * Converts this PB_SCServerBusy to JSON.
         * @function toJSON
         * @memberof PB_SCServerBusy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCServerBusy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCServerBusy;
    })();
    
    $root.PB_SCUserEnterGSAck = (function() {
    
        /**
         * Properties of a PB_SCUserEnterGSAck.
         * @exports IPB_SCUserEnterGSAck
         * @interface IPB_SCUserEnterGSAck
         * @property {number|null} [result] PB_SCUserEnterGSAck result
         * @property {number|null} [isInCross] PB_SCUserEnterGSAck isInCross
         */
    
        /**
         * Constructs a new PB_SCUserEnterGSAck.
         * @exports PB_SCUserEnterGSAck
         * @classdesc Represents a PB_SCUserEnterGSAck.
         * @implements IPB_SCUserEnterGSAck
         * @constructor
         * @param {IPB_SCUserEnterGSAck=} [properties] Properties to set
         */
        function PB_SCUserEnterGSAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCUserEnterGSAck result.
         * @member {number} result
         * @memberof PB_SCUserEnterGSAck
         * @instance
         */
        PB_SCUserEnterGSAck.prototype.result = 0;
    
        /**
         * PB_SCUserEnterGSAck isInCross.
         * @member {number} isInCross
         * @memberof PB_SCUserEnterGSAck
         * @instance
         */
        PB_SCUserEnterGSAck.prototype.isInCross = 0;
    
        /**
         * Creates a new PB_SCUserEnterGSAck instance using the specified properties.
         * @function create
         * @memberof PB_SCUserEnterGSAck
         * @static
         * @param {IPB_SCUserEnterGSAck=} [properties] Properties to set
         * @returns {PB_SCUserEnterGSAck} PB_SCUserEnterGSAck instance
         */
        PB_SCUserEnterGSAck.create = function create(properties) {
            return new PB_SCUserEnterGSAck(properties);
        };
    
        /**
         * Encodes the specified PB_SCUserEnterGSAck message. Does not implicitly {@link PB_SCUserEnterGSAck.verify|verify} messages.
         * @function encode
         * @memberof PB_SCUserEnterGSAck
         * @static
         * @param {IPB_SCUserEnterGSAck} message PB_SCUserEnterGSAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCUserEnterGSAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.isInCross != null && Object.hasOwnProperty.call(message, "isInCross"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isInCross);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCUserEnterGSAck message, length delimited. Does not implicitly {@link PB_SCUserEnterGSAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCUserEnterGSAck
         * @static
         * @param {IPB_SCUserEnterGSAck} message PB_SCUserEnterGSAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCUserEnterGSAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCUserEnterGSAck message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCUserEnterGSAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCUserEnterGSAck} PB_SCUserEnterGSAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCUserEnterGSAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCUserEnterGSAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.isInCross = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCUserEnterGSAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCUserEnterGSAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCUserEnterGSAck} PB_SCUserEnterGSAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCUserEnterGSAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCUserEnterGSAck message.
         * @function verify
         * @memberof PB_SCUserEnterGSAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCUserEnterGSAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
            if (message.isInCross != null && message.hasOwnProperty("isInCross"))
                if (!$util.isInteger(message.isInCross))
                    return "isInCross: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCUserEnterGSAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCUserEnterGSAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCUserEnterGSAck} PB_SCUserEnterGSAck
         */
        PB_SCUserEnterGSAck.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCUserEnterGSAck)
                return object;
            var message = new $root.PB_SCUserEnterGSAck();
            if (object.result != null)
                message.result = object.result | 0;
            if (object.isInCross != null)
                message.isInCross = object.isInCross | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCUserEnterGSAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCUserEnterGSAck
         * @static
         * @param {PB_SCUserEnterGSAck} message PB_SCUserEnterGSAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCUserEnterGSAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = 0;
                object.isInCross = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.isInCross != null && message.hasOwnProperty("isInCross"))
                object.isInCross = message.isInCross;
            return object;
        };
    
        /**
         * Converts this PB_SCUserEnterGSAck to JSON.
         * @function toJSON
         * @memberof PB_SCUserEnterGSAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCUserEnterGSAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCUserEnterGSAck;
    })();
    
    $root.PB_CSUserLogout = (function() {
    
        /**
         * Properties of a PB_CSUserLogout.
         * @exports IPB_CSUserLogout
         * @interface IPB_CSUserLogout
         * @property {number|null} [reserve] PB_CSUserLogout reserve
         */
    
        /**
         * Constructs a new PB_CSUserLogout.
         * @exports PB_CSUserLogout
         * @classdesc Represents a PB_CSUserLogout.
         * @implements IPB_CSUserLogout
         * @constructor
         * @param {IPB_CSUserLogout=} [properties] Properties to set
         */
        function PB_CSUserLogout(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSUserLogout reserve.
         * @member {number} reserve
         * @memberof PB_CSUserLogout
         * @instance
         */
        PB_CSUserLogout.prototype.reserve = 0;
    
        /**
         * Creates a new PB_CSUserLogout instance using the specified properties.
         * @function create
         * @memberof PB_CSUserLogout
         * @static
         * @param {IPB_CSUserLogout=} [properties] Properties to set
         * @returns {PB_CSUserLogout} PB_CSUserLogout instance
         */
        PB_CSUserLogout.create = function create(properties) {
            return new PB_CSUserLogout(properties);
        };
    
        /**
         * Encodes the specified PB_CSUserLogout message. Does not implicitly {@link PB_CSUserLogout.verify|verify} messages.
         * @function encode
         * @memberof PB_CSUserLogout
         * @static
         * @param {IPB_CSUserLogout} message PB_CSUserLogout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSUserLogout.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reserve != null && Object.hasOwnProperty.call(message, "reserve"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reserve);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSUserLogout message, length delimited. Does not implicitly {@link PB_CSUserLogout.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSUserLogout
         * @static
         * @param {IPB_CSUserLogout} message PB_CSUserLogout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSUserLogout.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSUserLogout message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSUserLogout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSUserLogout} PB_CSUserLogout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSUserLogout.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSUserLogout();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reserve = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSUserLogout message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSUserLogout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSUserLogout} PB_CSUserLogout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSUserLogout.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSUserLogout message.
         * @function verify
         * @memberof PB_CSUserLogout
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSUserLogout.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                if (!$util.isInteger(message.reserve))
                    return "reserve: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSUserLogout message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSUserLogout
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSUserLogout} PB_CSUserLogout
         */
        PB_CSUserLogout.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSUserLogout)
                return object;
            var message = new $root.PB_CSUserLogout();
            if (object.reserve != null)
                message.reserve = object.reserve | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSUserLogout message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSUserLogout
         * @static
         * @param {PB_CSUserLogout} message PB_CSUserLogout
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSUserLogout.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reserve = 0;
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                object.reserve = message.reserve;
            return object;
        };
    
        /**
         * Converts this PB_CSUserLogout to JSON.
         * @function toJSON
         * @memberof PB_CSUserLogout
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSUserLogout.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSUserLogout;
    })();
    
    $root.PB_CSGMCommand = (function() {
    
        /**
         * Properties of a PB_CSGMCommand.
         * @exports IPB_CSGMCommand
         * @interface IPB_CSGMCommand
         * @property {Uint8Array|null} [type] PB_CSGMCommand type
         * @property {Uint8Array|null} [command] PB_CSGMCommand command
         */
    
        /**
         * Constructs a new PB_CSGMCommand.
         * @exports PB_CSGMCommand
         * @classdesc Represents a PB_CSGMCommand.
         * @implements IPB_CSGMCommand
         * @constructor
         * @param {IPB_CSGMCommand=} [properties] Properties to set
         */
        function PB_CSGMCommand(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSGMCommand type.
         * @member {Uint8Array} type
         * @memberof PB_CSGMCommand
         * @instance
         */
        PB_CSGMCommand.prototype.type = $util.newBuffer([]);
    
        /**
         * PB_CSGMCommand command.
         * @member {Uint8Array} command
         * @memberof PB_CSGMCommand
         * @instance
         */
        PB_CSGMCommand.prototype.command = $util.newBuffer([]);
    
        /**
         * Creates a new PB_CSGMCommand instance using the specified properties.
         * @function create
         * @memberof PB_CSGMCommand
         * @static
         * @param {IPB_CSGMCommand=} [properties] Properties to set
         * @returns {PB_CSGMCommand} PB_CSGMCommand instance
         */
        PB_CSGMCommand.create = function create(properties) {
            return new PB_CSGMCommand(properties);
        };
    
        /**
         * Encodes the specified PB_CSGMCommand message. Does not implicitly {@link PB_CSGMCommand.verify|verify} messages.
         * @function encode
         * @memberof PB_CSGMCommand
         * @static
         * @param {IPB_CSGMCommand} message PB_CSGMCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGMCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.type);
            if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.command);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSGMCommand message, length delimited. Does not implicitly {@link PB_CSGMCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSGMCommand
         * @static
         * @param {IPB_CSGMCommand} message PB_CSGMCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGMCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSGMCommand message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSGMCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSGMCommand} PB_CSGMCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGMCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSGMCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.bytes();
                    break;
                case 2:
                    message.command = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSGMCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSGMCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSGMCommand} PB_CSGMCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGMCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSGMCommand message.
         * @function verify
         * @memberof PB_CSGMCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSGMCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!(message.type && typeof message.type.length === "number" || $util.isString(message.type)))
                    return "type: buffer expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!(message.command && typeof message.command.length === "number" || $util.isString(message.command)))
                    return "command: buffer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSGMCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSGMCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSGMCommand} PB_CSGMCommand
         */
        PB_CSGMCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSGMCommand)
                return object;
            var message = new $root.PB_CSGMCommand();
            if (object.type != null)
                if (typeof object.type === "string")
                    $util.base64.decode(object.type, message.type = $util.newBuffer($util.base64.length(object.type)), 0);
                else if (object.type.length)
                    message.type = object.type;
            if (object.command != null)
                if (typeof object.command === "string")
                    $util.base64.decode(object.command, message.command = $util.newBuffer($util.base64.length(object.command)), 0);
                else if (object.command.length)
                    message.command = object.command;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSGMCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSGMCommand
         * @static
         * @param {PB_CSGMCommand} message PB_CSGMCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSGMCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.type = "";
                else {
                    object.type = [];
                    if (options.bytes !== Array)
                        object.type = $util.newBuffer(object.type);
                }
                if (options.bytes === String)
                    object.command = "";
                else {
                    object.command = [];
                    if (options.bytes !== Array)
                        object.command = $util.newBuffer(object.command);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.bytes === String ? $util.base64.encode(message.type, 0, message.type.length) : options.bytes === Array ? Array.prototype.slice.call(message.type) : message.type;
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = options.bytes === String ? $util.base64.encode(message.command, 0, message.command.length) : options.bytes === Array ? Array.prototype.slice.call(message.command) : message.command;
            return object;
        };
    
        /**
         * Converts this PB_CSGMCommand to JSON.
         * @function toJSON
         * @memberof PB_CSGMCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSGMCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSGMCommand;
    })();
    
    $root.PB_SCGMCommand = (function() {
    
        /**
         * Properties of a PB_SCGMCommand.
         * @exports IPB_SCGMCommand
         * @interface IPB_SCGMCommand
         * @property {Uint8Array|null} [type] PB_SCGMCommand type
         * @property {Uint8Array|null} [result] PB_SCGMCommand result
         */
    
        /**
         * Constructs a new PB_SCGMCommand.
         * @exports PB_SCGMCommand
         * @classdesc Represents a PB_SCGMCommand.
         * @implements IPB_SCGMCommand
         * @constructor
         * @param {IPB_SCGMCommand=} [properties] Properties to set
         */
        function PB_SCGMCommand(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCGMCommand type.
         * @member {Uint8Array} type
         * @memberof PB_SCGMCommand
         * @instance
         */
        PB_SCGMCommand.prototype.type = $util.newBuffer([]);
    
        /**
         * PB_SCGMCommand result.
         * @member {Uint8Array} result
         * @memberof PB_SCGMCommand
         * @instance
         */
        PB_SCGMCommand.prototype.result = $util.newBuffer([]);
    
        /**
         * Creates a new PB_SCGMCommand instance using the specified properties.
         * @function create
         * @memberof PB_SCGMCommand
         * @static
         * @param {IPB_SCGMCommand=} [properties] Properties to set
         * @returns {PB_SCGMCommand} PB_SCGMCommand instance
         */
        PB_SCGMCommand.create = function create(properties) {
            return new PB_SCGMCommand(properties);
        };
    
        /**
         * Encodes the specified PB_SCGMCommand message. Does not implicitly {@link PB_SCGMCommand.verify|verify} messages.
         * @function encode
         * @memberof PB_SCGMCommand
         * @static
         * @param {IPB_SCGMCommand} message PB_SCGMCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGMCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.type);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCGMCommand message, length delimited. Does not implicitly {@link PB_SCGMCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCGMCommand
         * @static
         * @param {IPB_SCGMCommand} message PB_SCGMCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGMCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCGMCommand message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCGMCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCGMCommand} PB_SCGMCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGMCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCGMCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.bytes();
                    break;
                case 2:
                    message.result = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCGMCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCGMCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCGMCommand} PB_SCGMCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGMCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCGMCommand message.
         * @function verify
         * @memberof PB_SCGMCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCGMCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!(message.type && typeof message.type.length === "number" || $util.isString(message.type)))
                    return "type: buffer expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!(message.result && typeof message.result.length === "number" || $util.isString(message.result)))
                    return "result: buffer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCGMCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCGMCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCGMCommand} PB_SCGMCommand
         */
        PB_SCGMCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCGMCommand)
                return object;
            var message = new $root.PB_SCGMCommand();
            if (object.type != null)
                if (typeof object.type === "string")
                    $util.base64.decode(object.type, message.type = $util.newBuffer($util.base64.length(object.type)), 0);
                else if (object.type.length)
                    message.type = object.type;
            if (object.result != null)
                if (typeof object.result === "string")
                    $util.base64.decode(object.result, message.result = $util.newBuffer($util.base64.length(object.result)), 0);
                else if (object.result.length)
                    message.result = object.result;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCGMCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCGMCommand
         * @static
         * @param {PB_SCGMCommand} message PB_SCGMCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCGMCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.type = "";
                else {
                    object.type = [];
                    if (options.bytes !== Array)
                        object.type = $util.newBuffer(object.type);
                }
                if (options.bytes === String)
                    object.result = "";
                else {
                    object.result = [];
                    if (options.bytes !== Array)
                        object.result = $util.newBuffer(object.result);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.bytes === String ? $util.base64.encode(message.type, 0, message.type.length) : options.bytes === Array ? Array.prototype.slice.call(message.type) : message.type;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.bytes === String ? $util.base64.encode(message.result, 0, message.result.length) : options.bytes === Array ? Array.prototype.slice.call(message.result) : message.result;
            return object;
        };
    
        /**
         * Converts this PB_SCGMCommand to JSON.
         * @function toJSON
         * @memberof PB_SCGMCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCGMCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCGMCommand;
    })();
    
    $root.PB_CSGrowthFundReq = (function() {
    
        /**
         * Properties of a PB_CSGrowthFundReq.
         * @exports IPB_CSGrowthFundReq
         * @interface IPB_CSGrowthFundReq
         * @property {number|null} [reqType] PB_CSGrowthFundReq reqType
         * @property {number|null} [p1] PB_CSGrowthFundReq p1
         * @property {number|null} [p2] PB_CSGrowthFundReq p2
         */
    
        /**
         * Constructs a new PB_CSGrowthFundReq.
         * @exports PB_CSGrowthFundReq
         * @classdesc Represents a PB_CSGrowthFundReq.
         * @implements IPB_CSGrowthFundReq
         * @constructor
         * @param {IPB_CSGrowthFundReq=} [properties] Properties to set
         */
        function PB_CSGrowthFundReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSGrowthFundReq reqType.
         * @member {number} reqType
         * @memberof PB_CSGrowthFundReq
         * @instance
         */
        PB_CSGrowthFundReq.prototype.reqType = 0;
    
        /**
         * PB_CSGrowthFundReq p1.
         * @member {number} p1
         * @memberof PB_CSGrowthFundReq
         * @instance
         */
        PB_CSGrowthFundReq.prototype.p1 = 0;
    
        /**
         * PB_CSGrowthFundReq p2.
         * @member {number} p2
         * @memberof PB_CSGrowthFundReq
         * @instance
         */
        PB_CSGrowthFundReq.prototype.p2 = 0;
    
        /**
         * Creates a new PB_CSGrowthFundReq instance using the specified properties.
         * @function create
         * @memberof PB_CSGrowthFundReq
         * @static
         * @param {IPB_CSGrowthFundReq=} [properties] Properties to set
         * @returns {PB_CSGrowthFundReq} PB_CSGrowthFundReq instance
         */
        PB_CSGrowthFundReq.create = function create(properties) {
            return new PB_CSGrowthFundReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSGrowthFundReq message. Does not implicitly {@link PB_CSGrowthFundReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSGrowthFundReq
         * @static
         * @param {IPB_CSGrowthFundReq} message PB_CSGrowthFundReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGrowthFundReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.p1);
            if (message.p2 != null && Object.hasOwnProperty.call(message, "p2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.p2);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSGrowthFundReq message, length delimited. Does not implicitly {@link PB_CSGrowthFundReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSGrowthFundReq
         * @static
         * @param {IPB_CSGrowthFundReq} message PB_CSGrowthFundReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGrowthFundReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSGrowthFundReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSGrowthFundReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSGrowthFundReq} PB_CSGrowthFundReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGrowthFundReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSGrowthFundReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    message.p1 = reader.int32();
                    break;
                case 3:
                    message.p2 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSGrowthFundReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSGrowthFundReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSGrowthFundReq} PB_CSGrowthFundReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGrowthFundReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSGrowthFundReq message.
         * @function verify
         * @memberof PB_CSGrowthFundReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSGrowthFundReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.p1 != null && message.hasOwnProperty("p1"))
                if (!$util.isInteger(message.p1))
                    return "p1: integer expected";
            if (message.p2 != null && message.hasOwnProperty("p2"))
                if (!$util.isInteger(message.p2))
                    return "p2: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSGrowthFundReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSGrowthFundReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSGrowthFundReq} PB_CSGrowthFundReq
         */
        PB_CSGrowthFundReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSGrowthFundReq)
                return object;
            var message = new $root.PB_CSGrowthFundReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.p1 != null)
                message.p1 = object.p1 | 0;
            if (object.p2 != null)
                message.p2 = object.p2 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSGrowthFundReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSGrowthFundReq
         * @static
         * @param {PB_CSGrowthFundReq} message PB_CSGrowthFundReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSGrowthFundReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reqType = 0;
                object.p1 = 0;
                object.p2 = 0;
            }
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = message.p1;
            if (message.p2 != null && message.hasOwnProperty("p2"))
                object.p2 = message.p2;
            return object;
        };
    
        /**
         * Converts this PB_CSGrowthFundReq to JSON.
         * @function toJSON
         * @memberof PB_CSGrowthFundReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSGrowthFundReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSGrowthFundReq;
    })();
    
    $root.PB_SCGrowthFundInfo = (function() {
    
        /**
         * Properties of a PB_SCGrowthFundInfo.
         * @exports IPB_SCGrowthFundInfo
         * @interface IPB_SCGrowthFundInfo
         * @property {number|null} [activeFlag] PB_SCGrowthFundInfo activeFlag
         * @property {Array.<number>|null} [fetchFlag] PB_SCGrowthFundInfo fetchFlag
         */
    
        /**
         * Constructs a new PB_SCGrowthFundInfo.
         * @exports PB_SCGrowthFundInfo
         * @classdesc Represents a PB_SCGrowthFundInfo.
         * @implements IPB_SCGrowthFundInfo
         * @constructor
         * @param {IPB_SCGrowthFundInfo=} [properties] Properties to set
         */
        function PB_SCGrowthFundInfo(properties) {
            this.fetchFlag = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCGrowthFundInfo activeFlag.
         * @member {number} activeFlag
         * @memberof PB_SCGrowthFundInfo
         * @instance
         */
        PB_SCGrowthFundInfo.prototype.activeFlag = 0;
    
        /**
         * PB_SCGrowthFundInfo fetchFlag.
         * @member {Array.<number>} fetchFlag
         * @memberof PB_SCGrowthFundInfo
         * @instance
         */
        PB_SCGrowthFundInfo.prototype.fetchFlag = $util.emptyArray;
    
        /**
         * Creates a new PB_SCGrowthFundInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCGrowthFundInfo
         * @static
         * @param {IPB_SCGrowthFundInfo=} [properties] Properties to set
         * @returns {PB_SCGrowthFundInfo} PB_SCGrowthFundInfo instance
         */
        PB_SCGrowthFundInfo.create = function create(properties) {
            return new PB_SCGrowthFundInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCGrowthFundInfo message. Does not implicitly {@link PB_SCGrowthFundInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCGrowthFundInfo
         * @static
         * @param {IPB_SCGrowthFundInfo} message PB_SCGrowthFundInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGrowthFundInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activeFlag != null && Object.hasOwnProperty.call(message, "activeFlag"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activeFlag);
            if (message.fetchFlag != null && message.fetchFlag.length)
                for (var i = 0; i < message.fetchFlag.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.fetchFlag[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCGrowthFundInfo message, length delimited. Does not implicitly {@link PB_SCGrowthFundInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCGrowthFundInfo
         * @static
         * @param {IPB_SCGrowthFundInfo} message PB_SCGrowthFundInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGrowthFundInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCGrowthFundInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCGrowthFundInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCGrowthFundInfo} PB_SCGrowthFundInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGrowthFundInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCGrowthFundInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activeFlag = reader.int32();
                    break;
                case 2:
                    if (!(message.fetchFlag && message.fetchFlag.length))
                        message.fetchFlag = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.fetchFlag.push(reader.uint32());
                    } else
                        message.fetchFlag.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCGrowthFundInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCGrowthFundInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCGrowthFundInfo} PB_SCGrowthFundInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGrowthFundInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCGrowthFundInfo message.
         * @function verify
         * @memberof PB_SCGrowthFundInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCGrowthFundInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activeFlag != null && message.hasOwnProperty("activeFlag"))
                if (!$util.isInteger(message.activeFlag))
                    return "activeFlag: integer expected";
            if (message.fetchFlag != null && message.hasOwnProperty("fetchFlag")) {
                if (!Array.isArray(message.fetchFlag))
                    return "fetchFlag: array expected";
                for (var i = 0; i < message.fetchFlag.length; ++i)
                    if (!$util.isInteger(message.fetchFlag[i]))
                        return "fetchFlag: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCGrowthFundInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCGrowthFundInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCGrowthFundInfo} PB_SCGrowthFundInfo
         */
        PB_SCGrowthFundInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCGrowthFundInfo)
                return object;
            var message = new $root.PB_SCGrowthFundInfo();
            if (object.activeFlag != null)
                message.activeFlag = object.activeFlag | 0;
            if (object.fetchFlag) {
                if (!Array.isArray(object.fetchFlag))
                    throw TypeError(".PB_SCGrowthFundInfo.fetchFlag: array expected");
                message.fetchFlag = [];
                for (var i = 0; i < object.fetchFlag.length; ++i)
                    message.fetchFlag[i] = object.fetchFlag[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCGrowthFundInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCGrowthFundInfo
         * @static
         * @param {PB_SCGrowthFundInfo} message PB_SCGrowthFundInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCGrowthFundInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fetchFlag = [];
            if (options.defaults)
                object.activeFlag = 0;
            if (message.activeFlag != null && message.hasOwnProperty("activeFlag"))
                object.activeFlag = message.activeFlag;
            if (message.fetchFlag && message.fetchFlag.length) {
                object.fetchFlag = [];
                for (var j = 0; j < message.fetchFlag.length; ++j)
                    object.fetchFlag[j] = message.fetchFlag[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCGrowthFundInfo to JSON.
         * @function toJSON
         * @memberof PB_SCGrowthFundInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCGrowthFundInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCGrowthFundInfo;
    })();
    
    $root.PB_CSHeroReq = (function() {
    
        /**
         * Properties of a PB_CSHeroReq.
         * @exports IPB_CSHeroReq
         * @interface IPB_CSHeroReq
         * @property {number|null} [reqType] PB_CSHeroReq reqType
         * @property {Array.<number>|null} [paramList] PB_CSHeroReq paramList
         */
    
        /**
         * Constructs a new PB_CSHeroReq.
         * @exports PB_CSHeroReq
         * @classdesc Represents a PB_CSHeroReq.
         * @implements IPB_CSHeroReq
         * @constructor
         * @param {IPB_CSHeroReq=} [properties] Properties to set
         */
        function PB_CSHeroReq(properties) {
            this.paramList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSHeroReq reqType.
         * @member {number} reqType
         * @memberof PB_CSHeroReq
         * @instance
         */
        PB_CSHeroReq.prototype.reqType = 0;
    
        /**
         * PB_CSHeroReq paramList.
         * @member {Array.<number>} paramList
         * @memberof PB_CSHeroReq
         * @instance
         */
        PB_CSHeroReq.prototype.paramList = $util.emptyArray;
    
        /**
         * Creates a new PB_CSHeroReq instance using the specified properties.
         * @function create
         * @memberof PB_CSHeroReq
         * @static
         * @param {IPB_CSHeroReq=} [properties] Properties to set
         * @returns {PB_CSHeroReq} PB_CSHeroReq instance
         */
        PB_CSHeroReq.create = function create(properties) {
            return new PB_CSHeroReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSHeroReq message. Does not implicitly {@link PB_CSHeroReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSHeroReq
         * @static
         * @param {IPB_CSHeroReq} message PB_CSHeroReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSHeroReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.paramList != null && message.paramList.length)
                for (var i = 0; i < message.paramList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.paramList[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSHeroReq message, length delimited. Does not implicitly {@link PB_CSHeroReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSHeroReq
         * @static
         * @param {IPB_CSHeroReq} message PB_CSHeroReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSHeroReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSHeroReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSHeroReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSHeroReq} PB_CSHeroReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSHeroReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSHeroReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    if (!(message.paramList && message.paramList.length))
                        message.paramList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.paramList.push(reader.int32());
                    } else
                        message.paramList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSHeroReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSHeroReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSHeroReq} PB_CSHeroReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSHeroReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSHeroReq message.
         * @function verify
         * @memberof PB_CSHeroReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSHeroReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.paramList != null && message.hasOwnProperty("paramList")) {
                if (!Array.isArray(message.paramList))
                    return "paramList: array expected";
                for (var i = 0; i < message.paramList.length; ++i)
                    if (!$util.isInteger(message.paramList[i]))
                        return "paramList: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSHeroReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSHeroReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSHeroReq} PB_CSHeroReq
         */
        PB_CSHeroReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSHeroReq)
                return object;
            var message = new $root.PB_CSHeroReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.paramList) {
                if (!Array.isArray(object.paramList))
                    throw TypeError(".PB_CSHeroReq.paramList: array expected");
                message.paramList = [];
                for (var i = 0; i < object.paramList.length; ++i)
                    message.paramList[i] = object.paramList[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSHeroReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSHeroReq
         * @static
         * @param {PB_CSHeroReq} message PB_CSHeroReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSHeroReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.paramList = [];
            if (options.defaults)
                object.reqType = 0;
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.paramList && message.paramList.length) {
                object.paramList = [];
                for (var j = 0; j < message.paramList.length; ++j)
                    object.paramList[j] = message.paramList[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSHeroReq to JSON.
         * @function toJSON
         * @memberof PB_CSHeroReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSHeroReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSHeroReq;
    })();
    
    $root.PB_HeroNode = (function() {
    
        /**
         * Properties of a PB_HeroNode.
         * @exports IPB_HeroNode
         * @interface IPB_HeroNode
         * @property {number|null} [heroId] PB_HeroNode heroId
         * @property {number|null} [heroLevel] PB_HeroNode heroLevel
         * @property {Array.<number>|null} [geneId] PB_HeroNode geneId
         * @property {number|null} [raLtEnergy] PB_HeroNode raLtEnergy
         * @property {number|null} [horcruxesLevel] PB_HeroNode horcruxesLevel
         * @property {number|null} [horcruxesSteps] PB_HeroNode horcruxesSteps
         */
    
        /**
         * Constructs a new PB_HeroNode.
         * @exports PB_HeroNode
         * @classdesc Represents a PB_HeroNode.
         * @implements IPB_HeroNode
         * @constructor
         * @param {IPB_HeroNode=} [properties] Properties to set
         */
        function PB_HeroNode(properties) {
            this.geneId = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_HeroNode heroId.
         * @member {number} heroId
         * @memberof PB_HeroNode
         * @instance
         */
        PB_HeroNode.prototype.heroId = 0;
    
        /**
         * PB_HeroNode heroLevel.
         * @member {number} heroLevel
         * @memberof PB_HeroNode
         * @instance
         */
        PB_HeroNode.prototype.heroLevel = 0;
    
        /**
         * PB_HeroNode geneId.
         * @member {Array.<number>} geneId
         * @memberof PB_HeroNode
         * @instance
         */
        PB_HeroNode.prototype.geneId = $util.emptyArray;
    
        /**
         * PB_HeroNode raLtEnergy.
         * @member {number} raLtEnergy
         * @memberof PB_HeroNode
         * @instance
         */
        PB_HeroNode.prototype.raLtEnergy = 0;
    
        /**
         * PB_HeroNode horcruxesLevel.
         * @member {number} horcruxesLevel
         * @memberof PB_HeroNode
         * @instance
         */
        PB_HeroNode.prototype.horcruxesLevel = 0;
    
        /**
         * PB_HeroNode horcruxesSteps.
         * @member {number} horcruxesSteps
         * @memberof PB_HeroNode
         * @instance
         */
        PB_HeroNode.prototype.horcruxesSteps = 0;
    
        /**
         * Creates a new PB_HeroNode instance using the specified properties.
         * @function create
         * @memberof PB_HeroNode
         * @static
         * @param {IPB_HeroNode=} [properties] Properties to set
         * @returns {PB_HeroNode} PB_HeroNode instance
         */
        PB_HeroNode.create = function create(properties) {
            return new PB_HeroNode(properties);
        };
    
        /**
         * Encodes the specified PB_HeroNode message. Does not implicitly {@link PB_HeroNode.verify|verify} messages.
         * @function encode
         * @memberof PB_HeroNode
         * @static
         * @param {IPB_HeroNode} message PB_HeroNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_HeroNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.heroId);
            if (message.heroLevel != null && Object.hasOwnProperty.call(message, "heroLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroLevel);
            if (message.geneId != null && message.geneId.length)
                for (var i = 0; i < message.geneId.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.geneId[i]);
            if (message.raLtEnergy != null && Object.hasOwnProperty.call(message, "raLtEnergy"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.raLtEnergy);
            if (message.horcruxesLevel != null && Object.hasOwnProperty.call(message, "horcruxesLevel"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.horcruxesLevel);
            if (message.horcruxesSteps != null && Object.hasOwnProperty.call(message, "horcruxesSteps"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.horcruxesSteps);
            return writer;
        };
    
        /**
         * Encodes the specified PB_HeroNode message, length delimited. Does not implicitly {@link PB_HeroNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_HeroNode
         * @static
         * @param {IPB_HeroNode} message PB_HeroNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_HeroNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_HeroNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_HeroNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_HeroNode} PB_HeroNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_HeroNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_HeroNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroId = reader.int32();
                    break;
                case 2:
                    message.heroLevel = reader.int32();
                    break;
                case 3:
                    if (!(message.geneId && message.geneId.length))
                        message.geneId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.geneId.push(reader.int32());
                    } else
                        message.geneId.push(reader.int32());
                    break;
                case 4:
                    message.raLtEnergy = reader.int32();
                    break;
                case 5:
                    message.horcruxesLevel = reader.int32();
                    break;
                case 6:
                    message.horcruxesSteps = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_HeroNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_HeroNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_HeroNode} PB_HeroNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_HeroNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_HeroNode message.
         * @function verify
         * @memberof PB_HeroNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_HeroNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                if (!$util.isInteger(message.heroLevel))
                    return "heroLevel: integer expected";
            if (message.geneId != null && message.hasOwnProperty("geneId")) {
                if (!Array.isArray(message.geneId))
                    return "geneId: array expected";
                for (var i = 0; i < message.geneId.length; ++i)
                    if (!$util.isInteger(message.geneId[i]))
                        return "geneId: integer[] expected";
            }
            if (message.raLtEnergy != null && message.hasOwnProperty("raLtEnergy"))
                if (!$util.isInteger(message.raLtEnergy))
                    return "raLtEnergy: integer expected";
            if (message.horcruxesLevel != null && message.hasOwnProperty("horcruxesLevel"))
                if (!$util.isInteger(message.horcruxesLevel))
                    return "horcruxesLevel: integer expected";
            if (message.horcruxesSteps != null && message.hasOwnProperty("horcruxesSteps"))
                if (!$util.isInteger(message.horcruxesSteps))
                    return "horcruxesSteps: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_HeroNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_HeroNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_HeroNode} PB_HeroNode
         */
        PB_HeroNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_HeroNode)
                return object;
            var message = new $root.PB_HeroNode();
            if (object.heroId != null)
                message.heroId = object.heroId | 0;
            if (object.heroLevel != null)
                message.heroLevel = object.heroLevel | 0;
            if (object.geneId) {
                if (!Array.isArray(object.geneId))
                    throw TypeError(".PB_HeroNode.geneId: array expected");
                message.geneId = [];
                for (var i = 0; i < object.geneId.length; ++i)
                    message.geneId[i] = object.geneId[i] | 0;
            }
            if (object.raLtEnergy != null)
                message.raLtEnergy = object.raLtEnergy | 0;
            if (object.horcruxesLevel != null)
                message.horcruxesLevel = object.horcruxesLevel | 0;
            if (object.horcruxesSteps != null)
                message.horcruxesSteps = object.horcruxesSteps | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_HeroNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_HeroNode
         * @static
         * @param {PB_HeroNode} message PB_HeroNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_HeroNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.geneId = [];
            if (options.defaults) {
                object.heroId = 0;
                object.heroLevel = 0;
                object.raLtEnergy = 0;
                object.horcruxesLevel = 0;
                object.horcruxesSteps = 0;
            }
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                object.heroLevel = message.heroLevel;
            if (message.geneId && message.geneId.length) {
                object.geneId = [];
                for (var j = 0; j < message.geneId.length; ++j)
                    object.geneId[j] = message.geneId[j];
            }
            if (message.raLtEnergy != null && message.hasOwnProperty("raLtEnergy"))
                object.raLtEnergy = message.raLtEnergy;
            if (message.horcruxesLevel != null && message.hasOwnProperty("horcruxesLevel"))
                object.horcruxesLevel = message.horcruxesLevel;
            if (message.horcruxesSteps != null && message.hasOwnProperty("horcruxesSteps"))
                object.horcruxesSteps = message.horcruxesSteps;
            return object;
        };
    
        /**
         * Converts this PB_HeroNode to JSON.
         * @function toJSON
         * @memberof PB_HeroNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_HeroNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_HeroNode;
    })();
    
    $root.PB_SCHeroInfo = (function() {
    
        /**
         * Properties of a PB_SCHeroInfo.
         * @exports IPB_SCHeroInfo
         * @interface IPB_SCHeroInfo
         * @property {number|null} [sendType] PB_SCHeroInfo sendType
         * @property {Array.<IPB_HeroNode>|null} [heroList] PB_SCHeroInfo heroList
         */
    
        /**
         * Constructs a new PB_SCHeroInfo.
         * @exports PB_SCHeroInfo
         * @classdesc Represents a PB_SCHeroInfo.
         * @implements IPB_SCHeroInfo
         * @constructor
         * @param {IPB_SCHeroInfo=} [properties] Properties to set
         */
        function PB_SCHeroInfo(properties) {
            this.heroList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCHeroInfo sendType.
         * @member {number} sendType
         * @memberof PB_SCHeroInfo
         * @instance
         */
        PB_SCHeroInfo.prototype.sendType = 0;
    
        /**
         * PB_SCHeroInfo heroList.
         * @member {Array.<IPB_HeroNode>} heroList
         * @memberof PB_SCHeroInfo
         * @instance
         */
        PB_SCHeroInfo.prototype.heroList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCHeroInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCHeroInfo
         * @static
         * @param {IPB_SCHeroInfo=} [properties] Properties to set
         * @returns {PB_SCHeroInfo} PB_SCHeroInfo instance
         */
        PB_SCHeroInfo.create = function create(properties) {
            return new PB_SCHeroInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCHeroInfo message. Does not implicitly {@link PB_SCHeroInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCHeroInfo
         * @static
         * @param {IPB_SCHeroInfo} message PB_SCHeroInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHeroInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sendType != null && Object.hasOwnProperty.call(message, "sendType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sendType);
            if (message.heroList != null && message.heroList.length)
                for (var i = 0; i < message.heroList.length; ++i)
                    $root.PB_HeroNode.encode(message.heroList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCHeroInfo message, length delimited. Does not implicitly {@link PB_SCHeroInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCHeroInfo
         * @static
         * @param {IPB_SCHeroInfo} message PB_SCHeroInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHeroInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCHeroInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCHeroInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCHeroInfo} PB_SCHeroInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHeroInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCHeroInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sendType = reader.int32();
                    break;
                case 2:
                    if (!(message.heroList && message.heroList.length))
                        message.heroList = [];
                    message.heroList.push($root.PB_HeroNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCHeroInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCHeroInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCHeroInfo} PB_SCHeroInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHeroInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCHeroInfo message.
         * @function verify
         * @memberof PB_SCHeroInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCHeroInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                if (!$util.isInteger(message.sendType))
                    return "sendType: integer expected";
            if (message.heroList != null && message.hasOwnProperty("heroList")) {
                if (!Array.isArray(message.heroList))
                    return "heroList: array expected";
                for (var i = 0; i < message.heroList.length; ++i) {
                    var error = $root.PB_HeroNode.verify(message.heroList[i]);
                    if (error)
                        return "heroList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCHeroInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCHeroInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCHeroInfo} PB_SCHeroInfo
         */
        PB_SCHeroInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCHeroInfo)
                return object;
            var message = new $root.PB_SCHeroInfo();
            if (object.sendType != null)
                message.sendType = object.sendType | 0;
            if (object.heroList) {
                if (!Array.isArray(object.heroList))
                    throw TypeError(".PB_SCHeroInfo.heroList: array expected");
                message.heroList = [];
                for (var i = 0; i < object.heroList.length; ++i) {
                    if (typeof object.heroList[i] !== "object")
                        throw TypeError(".PB_SCHeroInfo.heroList: object expected");
                    message.heroList[i] = $root.PB_HeroNode.fromObject(object.heroList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCHeroInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCHeroInfo
         * @static
         * @param {PB_SCHeroInfo} message PB_SCHeroInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCHeroInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.heroList = [];
            if (options.defaults)
                object.sendType = 0;
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                object.sendType = message.sendType;
            if (message.heroList && message.heroList.length) {
                object.heroList = [];
                for (var j = 0; j < message.heroList.length; ++j)
                    object.heroList[j] = $root.PB_HeroNode.toObject(message.heroList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCHeroInfo to JSON.
         * @function toJSON
         * @memberof PB_SCHeroInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCHeroInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCHeroInfo;
    })();
    
    $root.PB_GeneNode = (function() {
    
        /**
         * Properties of a PB_GeneNode.
         * @exports IPB_GeneNode
         * @interface IPB_GeneNode
         * @property {number|null} [geneIndex] PB_GeneNode geneIndex
         * @property {number|null} [geneId] PB_GeneNode geneId
         * @property {number|null} [randAttr] PB_GeneNode randAttr
         */
    
        /**
         * Constructs a new PB_GeneNode.
         * @exports PB_GeneNode
         * @classdesc Represents a PB_GeneNode.
         * @implements IPB_GeneNode
         * @constructor
         * @param {IPB_GeneNode=} [properties] Properties to set
         */
        function PB_GeneNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_GeneNode geneIndex.
         * @member {number} geneIndex
         * @memberof PB_GeneNode
         * @instance
         */
        PB_GeneNode.prototype.geneIndex = 0;
    
        /**
         * PB_GeneNode geneId.
         * @member {number} geneId
         * @memberof PB_GeneNode
         * @instance
         */
        PB_GeneNode.prototype.geneId = 0;
    
        /**
         * PB_GeneNode randAttr.
         * @member {number} randAttr
         * @memberof PB_GeneNode
         * @instance
         */
        PB_GeneNode.prototype.randAttr = 0;
    
        /**
         * Creates a new PB_GeneNode instance using the specified properties.
         * @function create
         * @memberof PB_GeneNode
         * @static
         * @param {IPB_GeneNode=} [properties] Properties to set
         * @returns {PB_GeneNode} PB_GeneNode instance
         */
        PB_GeneNode.create = function create(properties) {
            return new PB_GeneNode(properties);
        };
    
        /**
         * Encodes the specified PB_GeneNode message. Does not implicitly {@link PB_GeneNode.verify|verify} messages.
         * @function encode
         * @memberof PB_GeneNode
         * @static
         * @param {IPB_GeneNode} message PB_GeneNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_GeneNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.geneIndex != null && Object.hasOwnProperty.call(message, "geneIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.geneIndex);
            if (message.geneId != null && Object.hasOwnProperty.call(message, "geneId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.geneId);
            if (message.randAttr != null && Object.hasOwnProperty.call(message, "randAttr"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.randAttr);
            return writer;
        };
    
        /**
         * Encodes the specified PB_GeneNode message, length delimited. Does not implicitly {@link PB_GeneNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_GeneNode
         * @static
         * @param {IPB_GeneNode} message PB_GeneNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_GeneNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_GeneNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_GeneNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_GeneNode} PB_GeneNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_GeneNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_GeneNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.geneIndex = reader.int32();
                    break;
                case 2:
                    message.geneId = reader.int32();
                    break;
                case 3:
                    message.randAttr = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_GeneNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_GeneNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_GeneNode} PB_GeneNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_GeneNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_GeneNode message.
         * @function verify
         * @memberof PB_GeneNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_GeneNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.geneIndex != null && message.hasOwnProperty("geneIndex"))
                if (!$util.isInteger(message.geneIndex))
                    return "geneIndex: integer expected";
            if (message.geneId != null && message.hasOwnProperty("geneId"))
                if (!$util.isInteger(message.geneId))
                    return "geneId: integer expected";
            if (message.randAttr != null && message.hasOwnProperty("randAttr"))
                if (!$util.isInteger(message.randAttr))
                    return "randAttr: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_GeneNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_GeneNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_GeneNode} PB_GeneNode
         */
        PB_GeneNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_GeneNode)
                return object;
            var message = new $root.PB_GeneNode();
            if (object.geneIndex != null)
                message.geneIndex = object.geneIndex | 0;
            if (object.geneId != null)
                message.geneId = object.geneId | 0;
            if (object.randAttr != null)
                message.randAttr = object.randAttr | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_GeneNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_GeneNode
         * @static
         * @param {PB_GeneNode} message PB_GeneNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_GeneNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.geneIndex = 0;
                object.geneId = 0;
                object.randAttr = 0;
            }
            if (message.geneIndex != null && message.hasOwnProperty("geneIndex"))
                object.geneIndex = message.geneIndex;
            if (message.geneId != null && message.hasOwnProperty("geneId"))
                object.geneId = message.geneId;
            if (message.randAttr != null && message.hasOwnProperty("randAttr"))
                object.randAttr = message.randAttr;
            return object;
        };
    
        /**
         * Converts this PB_GeneNode to JSON.
         * @function toJSON
         * @memberof PB_GeneNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_GeneNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_GeneNode;
    })();
    
    $root.PB_SCGeneInfo = (function() {
    
        /**
         * Properties of a PB_SCGeneInfo.
         * @exports IPB_SCGeneInfo
         * @interface IPB_SCGeneInfo
         * @property {number|null} [sendType] PB_SCGeneInfo sendType
         * @property {Array.<IPB_GeneNode>|null} [geneList] PB_SCGeneInfo geneList
         */
    
        /**
         * Constructs a new PB_SCGeneInfo.
         * @exports PB_SCGeneInfo
         * @classdesc Represents a PB_SCGeneInfo.
         * @implements IPB_SCGeneInfo
         * @constructor
         * @param {IPB_SCGeneInfo=} [properties] Properties to set
         */
        function PB_SCGeneInfo(properties) {
            this.geneList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCGeneInfo sendType.
         * @member {number} sendType
         * @memberof PB_SCGeneInfo
         * @instance
         */
        PB_SCGeneInfo.prototype.sendType = 0;
    
        /**
         * PB_SCGeneInfo geneList.
         * @member {Array.<IPB_GeneNode>} geneList
         * @memberof PB_SCGeneInfo
         * @instance
         */
        PB_SCGeneInfo.prototype.geneList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCGeneInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCGeneInfo
         * @static
         * @param {IPB_SCGeneInfo=} [properties] Properties to set
         * @returns {PB_SCGeneInfo} PB_SCGeneInfo instance
         */
        PB_SCGeneInfo.create = function create(properties) {
            return new PB_SCGeneInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCGeneInfo message. Does not implicitly {@link PB_SCGeneInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCGeneInfo
         * @static
         * @param {IPB_SCGeneInfo} message PB_SCGeneInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGeneInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sendType != null && Object.hasOwnProperty.call(message, "sendType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sendType);
            if (message.geneList != null && message.geneList.length)
                for (var i = 0; i < message.geneList.length; ++i)
                    $root.PB_GeneNode.encode(message.geneList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCGeneInfo message, length delimited. Does not implicitly {@link PB_SCGeneInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCGeneInfo
         * @static
         * @param {IPB_SCGeneInfo} message PB_SCGeneInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGeneInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCGeneInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCGeneInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCGeneInfo} PB_SCGeneInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGeneInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCGeneInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sendType = reader.int32();
                    break;
                case 2:
                    if (!(message.geneList && message.geneList.length))
                        message.geneList = [];
                    message.geneList.push($root.PB_GeneNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCGeneInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCGeneInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCGeneInfo} PB_SCGeneInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGeneInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCGeneInfo message.
         * @function verify
         * @memberof PB_SCGeneInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCGeneInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                if (!$util.isInteger(message.sendType))
                    return "sendType: integer expected";
            if (message.geneList != null && message.hasOwnProperty("geneList")) {
                if (!Array.isArray(message.geneList))
                    return "geneList: array expected";
                for (var i = 0; i < message.geneList.length; ++i) {
                    var error = $root.PB_GeneNode.verify(message.geneList[i]);
                    if (error)
                        return "geneList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCGeneInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCGeneInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCGeneInfo} PB_SCGeneInfo
         */
        PB_SCGeneInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCGeneInfo)
                return object;
            var message = new $root.PB_SCGeneInfo();
            if (object.sendType != null)
                message.sendType = object.sendType | 0;
            if (object.geneList) {
                if (!Array.isArray(object.geneList))
                    throw TypeError(".PB_SCGeneInfo.geneList: array expected");
                message.geneList = [];
                for (var i = 0; i < object.geneList.length; ++i) {
                    if (typeof object.geneList[i] !== "object")
                        throw TypeError(".PB_SCGeneInfo.geneList: object expected");
                    message.geneList[i] = $root.PB_GeneNode.fromObject(object.geneList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCGeneInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCGeneInfo
         * @static
         * @param {PB_SCGeneInfo} message PB_SCGeneInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCGeneInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.geneList = [];
            if (options.defaults)
                object.sendType = 0;
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                object.sendType = message.sendType;
            if (message.geneList && message.geneList.length) {
                object.geneList = [];
                for (var j = 0; j < message.geneList.length; ++j)
                    object.geneList[j] = $root.PB_GeneNode.toObject(message.geneList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCGeneInfo to JSON.
         * @function toJSON
         * @memberof PB_SCGeneInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCGeneInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCGeneInfo;
    })();
    
    $root.PB_SCTodayGainInfo = (function() {
    
        /**
         * Properties of a PB_SCTodayGainInfo.
         * @exports IPB_SCTodayGainInfo
         * @interface IPB_SCTodayGainInfo
         * @property {number|null} [seq] PB_SCTodayGainInfo seq
         * @property {Array.<number>|null} [param] PB_SCTodayGainInfo param
         */
    
        /**
         * Constructs a new PB_SCTodayGainInfo.
         * @exports PB_SCTodayGainInfo
         * @classdesc Represents a PB_SCTodayGainInfo.
         * @implements IPB_SCTodayGainInfo
         * @constructor
         * @param {IPB_SCTodayGainInfo=} [properties] Properties to set
         */
        function PB_SCTodayGainInfo(properties) {
            this.param = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTodayGainInfo seq.
         * @member {number} seq
         * @memberof PB_SCTodayGainInfo
         * @instance
         */
        PB_SCTodayGainInfo.prototype.seq = 0;
    
        /**
         * PB_SCTodayGainInfo param.
         * @member {Array.<number>} param
         * @memberof PB_SCTodayGainInfo
         * @instance
         */
        PB_SCTodayGainInfo.prototype.param = $util.emptyArray;
    
        /**
         * Creates a new PB_SCTodayGainInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCTodayGainInfo
         * @static
         * @param {IPB_SCTodayGainInfo=} [properties] Properties to set
         * @returns {PB_SCTodayGainInfo} PB_SCTodayGainInfo instance
         */
        PB_SCTodayGainInfo.create = function create(properties) {
            return new PB_SCTodayGainInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCTodayGainInfo message. Does not implicitly {@link PB_SCTodayGainInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTodayGainInfo
         * @static
         * @param {IPB_SCTodayGainInfo} message PB_SCTodayGainInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTodayGainInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.param != null && message.param.length)
                for (var i = 0; i < message.param.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.param[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTodayGainInfo message, length delimited. Does not implicitly {@link PB_SCTodayGainInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTodayGainInfo
         * @static
         * @param {IPB_SCTodayGainInfo} message PB_SCTodayGainInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTodayGainInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTodayGainInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTodayGainInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTodayGainInfo} PB_SCTodayGainInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTodayGainInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTodayGainInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTodayGainInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTodayGainInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTodayGainInfo} PB_SCTodayGainInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTodayGainInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTodayGainInfo message.
         * @function verify
         * @memberof PB_SCTodayGainInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTodayGainInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (var i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCTodayGainInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTodayGainInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTodayGainInfo} PB_SCTodayGainInfo
         */
        PB_SCTodayGainInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTodayGainInfo)
                return object;
            var message = new $root.PB_SCTodayGainInfo();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".PB_SCTodayGainInfo.param: array expected");
                message.param = [];
                for (var i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTodayGainInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTodayGainInfo
         * @static
         * @param {PB_SCTodayGainInfo} message PB_SCTodayGainInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTodayGainInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.param = [];
            if (options.defaults)
                object.seq = 0;
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.param && message.param.length) {
                object.param = [];
                for (var j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCTodayGainInfo to JSON.
         * @function toJSON
         * @memberof PB_SCTodayGainInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTodayGainInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTodayGainInfo;
    })();
    
    $root.PB_SCGeneTaskInfo = (function() {
    
        /**
         * Properties of a PB_SCGeneTaskInfo.
         * @exports IPB_SCGeneTaskInfo
         * @interface IPB_SCGeneTaskInfo
         * @property {Array.<number>|null} [taskProgress] PB_SCGeneTaskInfo taskProgress
         * @property {Array.<boolean>|null} [isFetch] PB_SCGeneTaskInfo isFetch
         */
    
        /**
         * Constructs a new PB_SCGeneTaskInfo.
         * @exports PB_SCGeneTaskInfo
         * @classdesc Represents a PB_SCGeneTaskInfo.
         * @implements IPB_SCGeneTaskInfo
         * @constructor
         * @param {IPB_SCGeneTaskInfo=} [properties] Properties to set
         */
        function PB_SCGeneTaskInfo(properties) {
            this.taskProgress = [];
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCGeneTaskInfo taskProgress.
         * @member {Array.<number>} taskProgress
         * @memberof PB_SCGeneTaskInfo
         * @instance
         */
        PB_SCGeneTaskInfo.prototype.taskProgress = $util.emptyArray;
    
        /**
         * PB_SCGeneTaskInfo isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCGeneTaskInfo
         * @instance
         */
        PB_SCGeneTaskInfo.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCGeneTaskInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCGeneTaskInfo
         * @static
         * @param {IPB_SCGeneTaskInfo=} [properties] Properties to set
         * @returns {PB_SCGeneTaskInfo} PB_SCGeneTaskInfo instance
         */
        PB_SCGeneTaskInfo.create = function create(properties) {
            return new PB_SCGeneTaskInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCGeneTaskInfo message. Does not implicitly {@link PB_SCGeneTaskInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCGeneTaskInfo
         * @static
         * @param {IPB_SCGeneTaskInfo} message PB_SCGeneTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGeneTaskInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskProgress != null && message.taskProgress.length)
                for (var i = 0; i < message.taskProgress.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskProgress[i]);
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCGeneTaskInfo message, length delimited. Does not implicitly {@link PB_SCGeneTaskInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCGeneTaskInfo
         * @static
         * @param {IPB_SCGeneTaskInfo} message PB_SCGeneTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGeneTaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCGeneTaskInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCGeneTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCGeneTaskInfo} PB_SCGeneTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGeneTaskInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCGeneTaskInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.taskProgress && message.taskProgress.length))
                        message.taskProgress = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.taskProgress.push(reader.int32());
                    } else
                        message.taskProgress.push(reader.int32());
                    break;
                case 2:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCGeneTaskInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCGeneTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCGeneTaskInfo} PB_SCGeneTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGeneTaskInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCGeneTaskInfo message.
         * @function verify
         * @memberof PB_SCGeneTaskInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCGeneTaskInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskProgress != null && message.hasOwnProperty("taskProgress")) {
                if (!Array.isArray(message.taskProgress))
                    return "taskProgress: array expected";
                for (var i = 0; i < message.taskProgress.length; ++i)
                    if (!$util.isInteger(message.taskProgress[i]))
                        return "taskProgress: integer[] expected";
            }
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCGeneTaskInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCGeneTaskInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCGeneTaskInfo} PB_SCGeneTaskInfo
         */
        PB_SCGeneTaskInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCGeneTaskInfo)
                return object;
            var message = new $root.PB_SCGeneTaskInfo();
            if (object.taskProgress) {
                if (!Array.isArray(object.taskProgress))
                    throw TypeError(".PB_SCGeneTaskInfo.taskProgress: array expected");
                message.taskProgress = [];
                for (var i = 0; i < object.taskProgress.length; ++i)
                    message.taskProgress[i] = object.taskProgress[i] | 0;
            }
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCGeneTaskInfo.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCGeneTaskInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCGeneTaskInfo
         * @static
         * @param {PB_SCGeneTaskInfo} message PB_SCGeneTaskInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCGeneTaskInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.taskProgress = [];
                object.isFetch = [];
            }
            if (message.taskProgress && message.taskProgress.length) {
                object.taskProgress = [];
                for (var j = 0; j < message.taskProgress.length; ++j)
                    object.taskProgress[j] = message.taskProgress[j];
            }
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCGeneTaskInfo to JSON.
         * @function toJSON
         * @memberof PB_SCGeneTaskInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCGeneTaskInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCGeneTaskInfo;
    })();
    
    $root.PB_CSKnapsackReq = (function() {
    
        /**
         * Properties of a PB_CSKnapsackReq.
         * @exports IPB_CSKnapsackReq
         * @interface IPB_CSKnapsackReq
         * @property {number|null} [reqType] PB_CSKnapsackReq reqType
         * @property {Array.<number>|null} [param] PB_CSKnapsackReq param
         */
    
        /**
         * Constructs a new PB_CSKnapsackReq.
         * @exports PB_CSKnapsackReq
         * @classdesc Represents a PB_CSKnapsackReq.
         * @implements IPB_CSKnapsackReq
         * @constructor
         * @param {IPB_CSKnapsackReq=} [properties] Properties to set
         */
        function PB_CSKnapsackReq(properties) {
            this.param = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSKnapsackReq reqType.
         * @member {number} reqType
         * @memberof PB_CSKnapsackReq
         * @instance
         */
        PB_CSKnapsackReq.prototype.reqType = 0;
    
        /**
         * PB_CSKnapsackReq param.
         * @member {Array.<number>} param
         * @memberof PB_CSKnapsackReq
         * @instance
         */
        PB_CSKnapsackReq.prototype.param = $util.emptyArray;
    
        /**
         * Creates a new PB_CSKnapsackReq instance using the specified properties.
         * @function create
         * @memberof PB_CSKnapsackReq
         * @static
         * @param {IPB_CSKnapsackReq=} [properties] Properties to set
         * @returns {PB_CSKnapsackReq} PB_CSKnapsackReq instance
         */
        PB_CSKnapsackReq.create = function create(properties) {
            return new PB_CSKnapsackReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSKnapsackReq message. Does not implicitly {@link PB_CSKnapsackReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSKnapsackReq
         * @static
         * @param {IPB_CSKnapsackReq} message PB_CSKnapsackReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSKnapsackReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.param != null && message.param.length)
                for (var i = 0; i < message.param.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.param[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSKnapsackReq message, length delimited. Does not implicitly {@link PB_CSKnapsackReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSKnapsackReq
         * @static
         * @param {IPB_CSKnapsackReq} message PB_CSKnapsackReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSKnapsackReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSKnapsackReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSKnapsackReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSKnapsackReq} PB_CSKnapsackReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSKnapsackReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSKnapsackReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSKnapsackReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSKnapsackReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSKnapsackReq} PB_CSKnapsackReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSKnapsackReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSKnapsackReq message.
         * @function verify
         * @memberof PB_CSKnapsackReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSKnapsackReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (var i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSKnapsackReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSKnapsackReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSKnapsackReq} PB_CSKnapsackReq
         */
        PB_CSKnapsackReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSKnapsackReq)
                return object;
            var message = new $root.PB_CSKnapsackReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".PB_CSKnapsackReq.param: array expected");
                message.param = [];
                for (var i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSKnapsackReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSKnapsackReq
         * @static
         * @param {PB_CSKnapsackReq} message PB_CSKnapsackReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSKnapsackReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.param = [];
            if (options.defaults)
                object.reqType = 0;
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.param && message.param.length) {
                object.param = [];
                for (var j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSKnapsackReq to JSON.
         * @function toJSON
         * @memberof PB_CSKnapsackReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSKnapsackReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSKnapsackReq;
    })();
    
    $root.PB_ItemData = (function() {
    
        /**
         * Properties of a PB_ItemData.
         * @exports IPB_ItemData
         * @interface IPB_ItemData
         * @property {number|null} [itemId] PB_ItemData itemId
         * @property {number|Long|null} [num] PB_ItemData num
         */
    
        /**
         * Constructs a new PB_ItemData.
         * @exports PB_ItemData
         * @classdesc Represents a PB_ItemData.
         * @implements IPB_ItemData
         * @constructor
         * @param {IPB_ItemData=} [properties] Properties to set
         */
        function PB_ItemData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_ItemData itemId.
         * @member {number} itemId
         * @memberof PB_ItemData
         * @instance
         */
        PB_ItemData.prototype.itemId = 0;
    
        /**
         * PB_ItemData num.
         * @member {number|Long} num
         * @memberof PB_ItemData
         * @instance
         */
        PB_ItemData.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_ItemData instance using the specified properties.
         * @function create
         * @memberof PB_ItemData
         * @static
         * @param {IPB_ItemData=} [properties] Properties to set
         * @returns {PB_ItemData} PB_ItemData instance
         */
        PB_ItemData.create = function create(properties) {
            return new PB_ItemData(properties);
        };
    
        /**
         * Encodes the specified PB_ItemData message. Does not implicitly {@link PB_ItemData.verify|verify} messages.
         * @function encode
         * @memberof PB_ItemData
         * @static
         * @param {IPB_ItemData} message PB_ItemData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_ItemData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.num);
            return writer;
        };
    
        /**
         * Encodes the specified PB_ItemData message, length delimited. Does not implicitly {@link PB_ItemData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_ItemData
         * @static
         * @param {IPB_ItemData} message PB_ItemData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_ItemData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_ItemData message from the specified reader or buffer.
         * @function decode
         * @memberof PB_ItemData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_ItemData} PB_ItemData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_ItemData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_ItemData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                case 2:
                    message.num = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_ItemData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_ItemData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_ItemData} PB_ItemData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_ItemData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_ItemData message.
         * @function verify
         * @memberof PB_ItemData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_ItemData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                    return "num: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_ItemData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_ItemData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_ItemData} PB_ItemData
         */
        PB_ItemData.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_ItemData)
                return object;
            var message = new $root.PB_ItemData();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            if (object.num != null)
                if ($util.Long)
                    (message.num = $util.Long.fromValue(object.num)).unsigned = false;
                else if (typeof object.num === "string")
                    message.num = parseInt(object.num, 10);
                else if (typeof object.num === "number")
                    message.num = object.num;
                else if (typeof object.num === "object")
                    message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_ItemData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_ItemData
         * @static
         * @param {PB_ItemData} message PB_ItemData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_ItemData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.num = options.longs === String ? "0" : 0;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.num != null && message.hasOwnProperty("num"))
                if (typeof message.num === "number")
                    object.num = options.longs === String ? String(message.num) : message.num;
                else
                    object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
            return object;
        };
    
        /**
         * Converts this PB_ItemData to JSON.
         * @function toJSON
         * @memberof PB_ItemData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_ItemData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_ItemData;
    })();
    
    $root.PB_CSBuyCmdReq = (function() {
    
        /**
         * Properties of a PB_CSBuyCmdReq.
         * @exports IPB_CSBuyCmdReq
         * @interface IPB_CSBuyCmdReq
         * @property {number|null} [num] PB_CSBuyCmdReq num
         * @property {number|null} [buyMoney] PB_CSBuyCmdReq buyMoney
         * @property {number|null} [addPayGold] PB_CSBuyCmdReq addPayGold
         * @property {number|null} [buyType] PB_CSBuyCmdReq buyType
         * @property {number|null} [buyParam_1] PB_CSBuyCmdReq buyParam_1
         * @property {number|null} [buyParam_2] PB_CSBuyCmdReq buyParam_2
         */
    
        /**
         * Constructs a new PB_CSBuyCmdReq.
         * @exports PB_CSBuyCmdReq
         * @classdesc Represents a PB_CSBuyCmdReq.
         * @implements IPB_CSBuyCmdReq
         * @constructor
         * @param {IPB_CSBuyCmdReq=} [properties] Properties to set
         */
        function PB_CSBuyCmdReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSBuyCmdReq num.
         * @member {number} num
         * @memberof PB_CSBuyCmdReq
         * @instance
         */
        PB_CSBuyCmdReq.prototype.num = 0;
    
        /**
         * PB_CSBuyCmdReq buyMoney.
         * @member {number} buyMoney
         * @memberof PB_CSBuyCmdReq
         * @instance
         */
        PB_CSBuyCmdReq.prototype.buyMoney = 0;
    
        /**
         * PB_CSBuyCmdReq addPayGold.
         * @member {number} addPayGold
         * @memberof PB_CSBuyCmdReq
         * @instance
         */
        PB_CSBuyCmdReq.prototype.addPayGold = 0;
    
        /**
         * PB_CSBuyCmdReq buyType.
         * @member {number} buyType
         * @memberof PB_CSBuyCmdReq
         * @instance
         */
        PB_CSBuyCmdReq.prototype.buyType = 0;
    
        /**
         * PB_CSBuyCmdReq buyParam_1.
         * @member {number} buyParam_1
         * @memberof PB_CSBuyCmdReq
         * @instance
         */
        PB_CSBuyCmdReq.prototype.buyParam_1 = 0;
    
        /**
         * PB_CSBuyCmdReq buyParam_2.
         * @member {number} buyParam_2
         * @memberof PB_CSBuyCmdReq
         * @instance
         */
        PB_CSBuyCmdReq.prototype.buyParam_2 = 0;
    
        /**
         * Creates a new PB_CSBuyCmdReq instance using the specified properties.
         * @function create
         * @memberof PB_CSBuyCmdReq
         * @static
         * @param {IPB_CSBuyCmdReq=} [properties] Properties to set
         * @returns {PB_CSBuyCmdReq} PB_CSBuyCmdReq instance
         */
        PB_CSBuyCmdReq.create = function create(properties) {
            return new PB_CSBuyCmdReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSBuyCmdReq message. Does not implicitly {@link PB_CSBuyCmdReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSBuyCmdReq
         * @static
         * @param {IPB_CSBuyCmdReq} message PB_CSBuyCmdReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSBuyCmdReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
            if (message.buyMoney != null && Object.hasOwnProperty.call(message, "buyMoney"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buyMoney);
            if (message.addPayGold != null && Object.hasOwnProperty.call(message, "addPayGold"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.addPayGold);
            if (message.buyType != null && Object.hasOwnProperty.call(message, "buyType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.buyType);
            if (message.buyParam_1 != null && Object.hasOwnProperty.call(message, "buyParam_1"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.buyParam_1);
            if (message.buyParam_2 != null && Object.hasOwnProperty.call(message, "buyParam_2"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.buyParam_2);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSBuyCmdReq message, length delimited. Does not implicitly {@link PB_CSBuyCmdReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSBuyCmdReq
         * @static
         * @param {IPB_CSBuyCmdReq} message PB_CSBuyCmdReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSBuyCmdReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSBuyCmdReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSBuyCmdReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSBuyCmdReq} PB_CSBuyCmdReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSBuyCmdReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSBuyCmdReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.num = reader.int32();
                    break;
                case 2:
                    message.buyMoney = reader.int32();
                    break;
                case 3:
                    message.addPayGold = reader.int32();
                    break;
                case 4:
                    message.buyType = reader.int32();
                    break;
                case 5:
                    message.buyParam_1 = reader.int32();
                    break;
                case 6:
                    message.buyParam_2 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSBuyCmdReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSBuyCmdReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSBuyCmdReq} PB_CSBuyCmdReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSBuyCmdReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSBuyCmdReq message.
         * @function verify
         * @memberof PB_CSBuyCmdReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSBuyCmdReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.buyMoney != null && message.hasOwnProperty("buyMoney"))
                if (!$util.isInteger(message.buyMoney))
                    return "buyMoney: integer expected";
            if (message.addPayGold != null && message.hasOwnProperty("addPayGold"))
                if (!$util.isInteger(message.addPayGold))
                    return "addPayGold: integer expected";
            if (message.buyType != null && message.hasOwnProperty("buyType"))
                if (!$util.isInteger(message.buyType))
                    return "buyType: integer expected";
            if (message.buyParam_1 != null && message.hasOwnProperty("buyParam_1"))
                if (!$util.isInteger(message.buyParam_1))
                    return "buyParam_1: integer expected";
            if (message.buyParam_2 != null && message.hasOwnProperty("buyParam_2"))
                if (!$util.isInteger(message.buyParam_2))
                    return "buyParam_2: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSBuyCmdReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSBuyCmdReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSBuyCmdReq} PB_CSBuyCmdReq
         */
        PB_CSBuyCmdReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSBuyCmdReq)
                return object;
            var message = new $root.PB_CSBuyCmdReq();
            if (object.num != null)
                message.num = object.num | 0;
            if (object.buyMoney != null)
                message.buyMoney = object.buyMoney | 0;
            if (object.addPayGold != null)
                message.addPayGold = object.addPayGold | 0;
            if (object.buyType != null)
                message.buyType = object.buyType | 0;
            if (object.buyParam_1 != null)
                message.buyParam_1 = object.buyParam_1 | 0;
            if (object.buyParam_2 != null)
                message.buyParam_2 = object.buyParam_2 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSBuyCmdReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSBuyCmdReq
         * @static
         * @param {PB_CSBuyCmdReq} message PB_CSBuyCmdReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSBuyCmdReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.num = 0;
                object.buyMoney = 0;
                object.addPayGold = 0;
                object.buyType = 0;
                object.buyParam_1 = 0;
                object.buyParam_2 = 0;
            }
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.buyMoney != null && message.hasOwnProperty("buyMoney"))
                object.buyMoney = message.buyMoney;
            if (message.addPayGold != null && message.hasOwnProperty("addPayGold"))
                object.addPayGold = message.addPayGold;
            if (message.buyType != null && message.hasOwnProperty("buyType"))
                object.buyType = message.buyType;
            if (message.buyParam_1 != null && message.hasOwnProperty("buyParam_1"))
                object.buyParam_1 = message.buyParam_1;
            if (message.buyParam_2 != null && message.hasOwnProperty("buyParam_2"))
                object.buyParam_2 = message.buyParam_2;
            return object;
        };
    
        /**
         * Converts this PB_CSBuyCmdReq to JSON.
         * @function toJSON
         * @memberof PB_CSBuyCmdReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSBuyCmdReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSBuyCmdReq;
    })();
    
    $root.PB_SCItemNotEnoughNotice = (function() {
    
        /**
         * Properties of a PB_SCItemNotEnoughNotice.
         * @exports IPB_SCItemNotEnoughNotice
         * @interface IPB_SCItemNotEnoughNotice
         * @property {number|null} [itemId] PB_SCItemNotEnoughNotice itemId
         */
    
        /**
         * Constructs a new PB_SCItemNotEnoughNotice.
         * @exports PB_SCItemNotEnoughNotice
         * @classdesc Represents a PB_SCItemNotEnoughNotice.
         * @implements IPB_SCItemNotEnoughNotice
         * @constructor
         * @param {IPB_SCItemNotEnoughNotice=} [properties] Properties to set
         */
        function PB_SCItemNotEnoughNotice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCItemNotEnoughNotice itemId.
         * @member {number} itemId
         * @memberof PB_SCItemNotEnoughNotice
         * @instance
         */
        PB_SCItemNotEnoughNotice.prototype.itemId = 0;
    
        /**
         * Creates a new PB_SCItemNotEnoughNotice instance using the specified properties.
         * @function create
         * @memberof PB_SCItemNotEnoughNotice
         * @static
         * @param {IPB_SCItemNotEnoughNotice=} [properties] Properties to set
         * @returns {PB_SCItemNotEnoughNotice} PB_SCItemNotEnoughNotice instance
         */
        PB_SCItemNotEnoughNotice.create = function create(properties) {
            return new PB_SCItemNotEnoughNotice(properties);
        };
    
        /**
         * Encodes the specified PB_SCItemNotEnoughNotice message. Does not implicitly {@link PB_SCItemNotEnoughNotice.verify|verify} messages.
         * @function encode
         * @memberof PB_SCItemNotEnoughNotice
         * @static
         * @param {IPB_SCItemNotEnoughNotice} message PB_SCItemNotEnoughNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCItemNotEnoughNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCItemNotEnoughNotice message, length delimited. Does not implicitly {@link PB_SCItemNotEnoughNotice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCItemNotEnoughNotice
         * @static
         * @param {IPB_SCItemNotEnoughNotice} message PB_SCItemNotEnoughNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCItemNotEnoughNotice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCItemNotEnoughNotice message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCItemNotEnoughNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCItemNotEnoughNotice} PB_SCItemNotEnoughNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCItemNotEnoughNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCItemNotEnoughNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCItemNotEnoughNotice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCItemNotEnoughNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCItemNotEnoughNotice} PB_SCItemNotEnoughNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCItemNotEnoughNotice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCItemNotEnoughNotice message.
         * @function verify
         * @memberof PB_SCItemNotEnoughNotice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCItemNotEnoughNotice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCItemNotEnoughNotice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCItemNotEnoughNotice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCItemNotEnoughNotice} PB_SCItemNotEnoughNotice
         */
        PB_SCItemNotEnoughNotice.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCItemNotEnoughNotice)
                return object;
            var message = new $root.PB_SCItemNotEnoughNotice();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCItemNotEnoughNotice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCItemNotEnoughNotice
         * @static
         * @param {PB_SCItemNotEnoughNotice} message PB_SCItemNotEnoughNotice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCItemNotEnoughNotice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.itemId = 0;
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            return object;
        };
    
        /**
         * Converts this PB_SCItemNotEnoughNotice to JSON.
         * @function toJSON
         * @memberof PB_SCItemNotEnoughNotice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCItemNotEnoughNotice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCItemNotEnoughNotice;
    })();
    
    $root.PB_SCKnapsackAllInfo = (function() {
    
        /**
         * Properties of a PB_SCKnapsackAllInfo.
         * @exports IPB_SCKnapsackAllInfo
         * @interface IPB_SCKnapsackAllInfo
         * @property {Array.<IPB_ItemData>|null} [itemList] PB_SCKnapsackAllInfo itemList
         */
    
        /**
         * Constructs a new PB_SCKnapsackAllInfo.
         * @exports PB_SCKnapsackAllInfo
         * @classdesc Represents a PB_SCKnapsackAllInfo.
         * @implements IPB_SCKnapsackAllInfo
         * @constructor
         * @param {IPB_SCKnapsackAllInfo=} [properties] Properties to set
         */
        function PB_SCKnapsackAllInfo(properties) {
            this.itemList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCKnapsackAllInfo itemList.
         * @member {Array.<IPB_ItemData>} itemList
         * @memberof PB_SCKnapsackAllInfo
         * @instance
         */
        PB_SCKnapsackAllInfo.prototype.itemList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCKnapsackAllInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCKnapsackAllInfo
         * @static
         * @param {IPB_SCKnapsackAllInfo=} [properties] Properties to set
         * @returns {PB_SCKnapsackAllInfo} PB_SCKnapsackAllInfo instance
         */
        PB_SCKnapsackAllInfo.create = function create(properties) {
            return new PB_SCKnapsackAllInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCKnapsackAllInfo message. Does not implicitly {@link PB_SCKnapsackAllInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCKnapsackAllInfo
         * @static
         * @param {IPB_SCKnapsackAllInfo} message PB_SCKnapsackAllInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCKnapsackAllInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemList != null && message.itemList.length)
                for (var i = 0; i < message.itemList.length; ++i)
                    $root.PB_ItemData.encode(message.itemList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCKnapsackAllInfo message, length delimited. Does not implicitly {@link PB_SCKnapsackAllInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCKnapsackAllInfo
         * @static
         * @param {IPB_SCKnapsackAllInfo} message PB_SCKnapsackAllInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCKnapsackAllInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCKnapsackAllInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCKnapsackAllInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCKnapsackAllInfo} PB_SCKnapsackAllInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCKnapsackAllInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCKnapsackAllInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.itemList && message.itemList.length))
                        message.itemList = [];
                    message.itemList.push($root.PB_ItemData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCKnapsackAllInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCKnapsackAllInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCKnapsackAllInfo} PB_SCKnapsackAllInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCKnapsackAllInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCKnapsackAllInfo message.
         * @function verify
         * @memberof PB_SCKnapsackAllInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCKnapsackAllInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemList != null && message.hasOwnProperty("itemList")) {
                if (!Array.isArray(message.itemList))
                    return "itemList: array expected";
                for (var i = 0; i < message.itemList.length; ++i) {
                    var error = $root.PB_ItemData.verify(message.itemList[i]);
                    if (error)
                        return "itemList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCKnapsackAllInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCKnapsackAllInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCKnapsackAllInfo} PB_SCKnapsackAllInfo
         */
        PB_SCKnapsackAllInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCKnapsackAllInfo)
                return object;
            var message = new $root.PB_SCKnapsackAllInfo();
            if (object.itemList) {
                if (!Array.isArray(object.itemList))
                    throw TypeError(".PB_SCKnapsackAllInfo.itemList: array expected");
                message.itemList = [];
                for (var i = 0; i < object.itemList.length; ++i) {
                    if (typeof object.itemList[i] !== "object")
                        throw TypeError(".PB_SCKnapsackAllInfo.itemList: object expected");
                    message.itemList[i] = $root.PB_ItemData.fromObject(object.itemList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCKnapsackAllInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCKnapsackAllInfo
         * @static
         * @param {PB_SCKnapsackAllInfo} message PB_SCKnapsackAllInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCKnapsackAllInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemList = [];
            if (message.itemList && message.itemList.length) {
                object.itemList = [];
                for (var j = 0; j < message.itemList.length; ++j)
                    object.itemList[j] = $root.PB_ItemData.toObject(message.itemList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCKnapsackAllInfo to JSON.
         * @function toJSON
         * @memberof PB_SCKnapsackAllInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCKnapsackAllInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCKnapsackAllInfo;
    })();
    
    $root.PB_SCKnapsackSingleInfo = (function() {
    
        /**
         * Properties of a PB_SCKnapsackSingleInfo.
         * @exports IPB_SCKnapsackSingleInfo
         * @interface IPB_SCKnapsackSingleInfo
         * @property {IPB_ItemData|null} [item] PB_SCKnapsackSingleInfo item
         */
    
        /**
         * Constructs a new PB_SCKnapsackSingleInfo.
         * @exports PB_SCKnapsackSingleInfo
         * @classdesc Represents a PB_SCKnapsackSingleInfo.
         * @implements IPB_SCKnapsackSingleInfo
         * @constructor
         * @param {IPB_SCKnapsackSingleInfo=} [properties] Properties to set
         */
        function PB_SCKnapsackSingleInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCKnapsackSingleInfo item.
         * @member {IPB_ItemData|null|undefined} item
         * @memberof PB_SCKnapsackSingleInfo
         * @instance
         */
        PB_SCKnapsackSingleInfo.prototype.item = null;
    
        /**
         * Creates a new PB_SCKnapsackSingleInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCKnapsackSingleInfo
         * @static
         * @param {IPB_SCKnapsackSingleInfo=} [properties] Properties to set
         * @returns {PB_SCKnapsackSingleInfo} PB_SCKnapsackSingleInfo instance
         */
        PB_SCKnapsackSingleInfo.create = function create(properties) {
            return new PB_SCKnapsackSingleInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCKnapsackSingleInfo message. Does not implicitly {@link PB_SCKnapsackSingleInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCKnapsackSingleInfo
         * @static
         * @param {IPB_SCKnapsackSingleInfo} message PB_SCKnapsackSingleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCKnapsackSingleInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.PB_ItemData.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCKnapsackSingleInfo message, length delimited. Does not implicitly {@link PB_SCKnapsackSingleInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCKnapsackSingleInfo
         * @static
         * @param {IPB_SCKnapsackSingleInfo} message PB_SCKnapsackSingleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCKnapsackSingleInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCKnapsackSingleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCKnapsackSingleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCKnapsackSingleInfo} PB_SCKnapsackSingleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCKnapsackSingleInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCKnapsackSingleInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.PB_ItemData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCKnapsackSingleInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCKnapsackSingleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCKnapsackSingleInfo} PB_SCKnapsackSingleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCKnapsackSingleInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCKnapsackSingleInfo message.
         * @function verify
         * @memberof PB_SCKnapsackSingleInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCKnapsackSingleInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.PB_ItemData.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };
    
        /**
         * Creates a PB_SCKnapsackSingleInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCKnapsackSingleInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCKnapsackSingleInfo} PB_SCKnapsackSingleInfo
         */
        PB_SCKnapsackSingleInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCKnapsackSingleInfo)
                return object;
            var message = new $root.PB_SCKnapsackSingleInfo();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".PB_SCKnapsackSingleInfo.item: object expected");
                message.item = $root.PB_ItemData.fromObject(object.item);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCKnapsackSingleInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCKnapsackSingleInfo
         * @static
         * @param {PB_SCKnapsackSingleInfo} message PB_SCKnapsackSingleInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCKnapsackSingleInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.PB_ItemData.toObject(message.item, options);
            return object;
        };
    
        /**
         * Converts this PB_SCKnapsackSingleInfo to JSON.
         * @function toJSON
         * @memberof PB_SCKnapsackSingleInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCKnapsackSingleInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCKnapsackSingleInfo;
    })();
    
    $root.PB_SCGetItemNotice = (function() {
    
        /**
         * Properties of a PB_SCGetItemNotice.
         * @exports IPB_SCGetItemNotice
         * @interface IPB_SCGetItemNotice
         * @property {number|null} [getType] PB_SCGetItemNotice getType
         * @property {Array.<IPB_ItemData>|null} [itemList] PB_SCGetItemNotice itemList
         */
    
        /**
         * Constructs a new PB_SCGetItemNotice.
         * @exports PB_SCGetItemNotice
         * @classdesc Represents a PB_SCGetItemNotice.
         * @implements IPB_SCGetItemNotice
         * @constructor
         * @param {IPB_SCGetItemNotice=} [properties] Properties to set
         */
        function PB_SCGetItemNotice(properties) {
            this.itemList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCGetItemNotice getType.
         * @member {number} getType
         * @memberof PB_SCGetItemNotice
         * @instance
         */
        PB_SCGetItemNotice.prototype.getType = 0;
    
        /**
         * PB_SCGetItemNotice itemList.
         * @member {Array.<IPB_ItemData>} itemList
         * @memberof PB_SCGetItemNotice
         * @instance
         */
        PB_SCGetItemNotice.prototype.itemList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCGetItemNotice instance using the specified properties.
         * @function create
         * @memberof PB_SCGetItemNotice
         * @static
         * @param {IPB_SCGetItemNotice=} [properties] Properties to set
         * @returns {PB_SCGetItemNotice} PB_SCGetItemNotice instance
         */
        PB_SCGetItemNotice.create = function create(properties) {
            return new PB_SCGetItemNotice(properties);
        };
    
        /**
         * Encodes the specified PB_SCGetItemNotice message. Does not implicitly {@link PB_SCGetItemNotice.verify|verify} messages.
         * @function encode
         * @memberof PB_SCGetItemNotice
         * @static
         * @param {IPB_SCGetItemNotice} message PB_SCGetItemNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGetItemNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.getType != null && Object.hasOwnProperty.call(message, "getType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.getType);
            if (message.itemList != null && message.itemList.length)
                for (var i = 0; i < message.itemList.length; ++i)
                    $root.PB_ItemData.encode(message.itemList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCGetItemNotice message, length delimited. Does not implicitly {@link PB_SCGetItemNotice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCGetItemNotice
         * @static
         * @param {IPB_SCGetItemNotice} message PB_SCGetItemNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGetItemNotice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCGetItemNotice message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCGetItemNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCGetItemNotice} PB_SCGetItemNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGetItemNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCGetItemNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.getType = reader.int32();
                    break;
                case 2:
                    if (!(message.itemList && message.itemList.length))
                        message.itemList = [];
                    message.itemList.push($root.PB_ItemData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCGetItemNotice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCGetItemNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCGetItemNotice} PB_SCGetItemNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGetItemNotice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCGetItemNotice message.
         * @function verify
         * @memberof PB_SCGetItemNotice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCGetItemNotice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.getType != null && message.hasOwnProperty("getType"))
                if (!$util.isInteger(message.getType))
                    return "getType: integer expected";
            if (message.itemList != null && message.hasOwnProperty("itemList")) {
                if (!Array.isArray(message.itemList))
                    return "itemList: array expected";
                for (var i = 0; i < message.itemList.length; ++i) {
                    var error = $root.PB_ItemData.verify(message.itemList[i]);
                    if (error)
                        return "itemList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCGetItemNotice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCGetItemNotice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCGetItemNotice} PB_SCGetItemNotice
         */
        PB_SCGetItemNotice.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCGetItemNotice)
                return object;
            var message = new $root.PB_SCGetItemNotice();
            if (object.getType != null)
                message.getType = object.getType | 0;
            if (object.itemList) {
                if (!Array.isArray(object.itemList))
                    throw TypeError(".PB_SCGetItemNotice.itemList: array expected");
                message.itemList = [];
                for (var i = 0; i < object.itemList.length; ++i) {
                    if (typeof object.itemList[i] !== "object")
                        throw TypeError(".PB_SCGetItemNotice.itemList: object expected");
                    message.itemList[i] = $root.PB_ItemData.fromObject(object.itemList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCGetItemNotice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCGetItemNotice
         * @static
         * @param {PB_SCGetItemNotice} message PB_SCGetItemNotice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCGetItemNotice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemList = [];
            if (options.defaults)
                object.getType = 0;
            if (message.getType != null && message.hasOwnProperty("getType"))
                object.getType = message.getType;
            if (message.itemList && message.itemList.length) {
                object.itemList = [];
                for (var j = 0; j < message.itemList.length; ++j)
                    object.itemList[j] = $root.PB_ItemData.toObject(message.itemList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCGetItemNotice to JSON.
         * @function toJSON
         * @memberof PB_SCGetItemNotice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCGetItemNotice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCGetItemNotice;
    })();
    
    $root.PB_SCGetOneItemNotice = (function() {
    
        /**
         * Properties of a PB_SCGetOneItemNotice.
         * @exports IPB_SCGetOneItemNotice
         * @interface IPB_SCGetOneItemNotice
         * @property {IPB_ItemData|null} [item] PB_SCGetOneItemNotice item
         */
    
        /**
         * Constructs a new PB_SCGetOneItemNotice.
         * @exports PB_SCGetOneItemNotice
         * @classdesc Represents a PB_SCGetOneItemNotice.
         * @implements IPB_SCGetOneItemNotice
         * @constructor
         * @param {IPB_SCGetOneItemNotice=} [properties] Properties to set
         */
        function PB_SCGetOneItemNotice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCGetOneItemNotice item.
         * @member {IPB_ItemData|null|undefined} item
         * @memberof PB_SCGetOneItemNotice
         * @instance
         */
        PB_SCGetOneItemNotice.prototype.item = null;
    
        /**
         * Creates a new PB_SCGetOneItemNotice instance using the specified properties.
         * @function create
         * @memberof PB_SCGetOneItemNotice
         * @static
         * @param {IPB_SCGetOneItemNotice=} [properties] Properties to set
         * @returns {PB_SCGetOneItemNotice} PB_SCGetOneItemNotice instance
         */
        PB_SCGetOneItemNotice.create = function create(properties) {
            return new PB_SCGetOneItemNotice(properties);
        };
    
        /**
         * Encodes the specified PB_SCGetOneItemNotice message. Does not implicitly {@link PB_SCGetOneItemNotice.verify|verify} messages.
         * @function encode
         * @memberof PB_SCGetOneItemNotice
         * @static
         * @param {IPB_SCGetOneItemNotice} message PB_SCGetOneItemNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGetOneItemNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.PB_ItemData.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCGetOneItemNotice message, length delimited. Does not implicitly {@link PB_SCGetOneItemNotice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCGetOneItemNotice
         * @static
         * @param {IPB_SCGetOneItemNotice} message PB_SCGetOneItemNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGetOneItemNotice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCGetOneItemNotice message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCGetOneItemNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCGetOneItemNotice} PB_SCGetOneItemNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGetOneItemNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCGetOneItemNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.PB_ItemData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCGetOneItemNotice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCGetOneItemNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCGetOneItemNotice} PB_SCGetOneItemNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGetOneItemNotice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCGetOneItemNotice message.
         * @function verify
         * @memberof PB_SCGetOneItemNotice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCGetOneItemNotice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.PB_ItemData.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };
    
        /**
         * Creates a PB_SCGetOneItemNotice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCGetOneItemNotice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCGetOneItemNotice} PB_SCGetOneItemNotice
         */
        PB_SCGetOneItemNotice.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCGetOneItemNotice)
                return object;
            var message = new $root.PB_SCGetOneItemNotice();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".PB_SCGetOneItemNotice.item: object expected");
                message.item = $root.PB_ItemData.fromObject(object.item);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCGetOneItemNotice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCGetOneItemNotice
         * @static
         * @param {PB_SCGetOneItemNotice} message PB_SCGetOneItemNotice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCGetOneItemNotice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.PB_ItemData.toObject(message.item, options);
            return object;
        };
    
        /**
         * Converts this PB_SCGetOneItemNotice to JSON.
         * @function toJSON
         * @memberof PB_SCGetOneItemNotice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCGetOneItemNotice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCGetOneItemNotice;
    })();
    
    $root.PB_ShiZhuangData = (function() {
    
        /**
         * Properties of a PB_ShiZhuangData.
         * @exports IPB_ShiZhuangData
         * @interface IPB_ShiZhuangData
         * @property {number|null} [id] PB_ShiZhuangData id
         * @property {number|null} [level] PB_ShiZhuangData level
         */
    
        /**
         * Constructs a new PB_ShiZhuangData.
         * @exports PB_ShiZhuangData
         * @classdesc Represents a PB_ShiZhuangData.
         * @implements IPB_ShiZhuangData
         * @constructor
         * @param {IPB_ShiZhuangData=} [properties] Properties to set
         */
        function PB_ShiZhuangData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_ShiZhuangData id.
         * @member {number} id
         * @memberof PB_ShiZhuangData
         * @instance
         */
        PB_ShiZhuangData.prototype.id = 0;
    
        /**
         * PB_ShiZhuangData level.
         * @member {number} level
         * @memberof PB_ShiZhuangData
         * @instance
         */
        PB_ShiZhuangData.prototype.level = 0;
    
        /**
         * Creates a new PB_ShiZhuangData instance using the specified properties.
         * @function create
         * @memberof PB_ShiZhuangData
         * @static
         * @param {IPB_ShiZhuangData=} [properties] Properties to set
         * @returns {PB_ShiZhuangData} PB_ShiZhuangData instance
         */
        PB_ShiZhuangData.create = function create(properties) {
            return new PB_ShiZhuangData(properties);
        };
    
        /**
         * Encodes the specified PB_ShiZhuangData message. Does not implicitly {@link PB_ShiZhuangData.verify|verify} messages.
         * @function encode
         * @memberof PB_ShiZhuangData
         * @static
         * @param {IPB_ShiZhuangData} message PB_ShiZhuangData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_ShiZhuangData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
            return writer;
        };
    
        /**
         * Encodes the specified PB_ShiZhuangData message, length delimited. Does not implicitly {@link PB_ShiZhuangData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_ShiZhuangData
         * @static
         * @param {IPB_ShiZhuangData} message PB_ShiZhuangData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_ShiZhuangData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_ShiZhuangData message from the specified reader or buffer.
         * @function decode
         * @memberof PB_ShiZhuangData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_ShiZhuangData} PB_ShiZhuangData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_ShiZhuangData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_ShiZhuangData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.level = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_ShiZhuangData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_ShiZhuangData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_ShiZhuangData} PB_ShiZhuangData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_ShiZhuangData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_ShiZhuangData message.
         * @function verify
         * @memberof PB_ShiZhuangData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_ShiZhuangData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_ShiZhuangData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_ShiZhuangData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_ShiZhuangData} PB_ShiZhuangData
         */
        PB_ShiZhuangData.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_ShiZhuangData)
                return object;
            var message = new $root.PB_ShiZhuangData();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.level != null)
                message.level = object.level | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_ShiZhuangData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_ShiZhuangData
         * @static
         * @param {PB_ShiZhuangData} message PB_ShiZhuangData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_ShiZhuangData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.level = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            return object;
        };
    
        /**
         * Converts this PB_ShiZhuangData to JSON.
         * @function toJSON
         * @memberof PB_ShiZhuangData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_ShiZhuangData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_ShiZhuangData;
    })();
    
    $root.PB_SCAllShiZhuangInfo = (function() {
    
        /**
         * Properties of a PB_SCAllShiZhuangInfo.
         * @exports IPB_SCAllShiZhuangInfo
         * @interface IPB_SCAllShiZhuangInfo
         * @property {Array.<IPB_ShiZhuangData>|null} [shizhuangList] PB_SCAllShiZhuangInfo shizhuangList
         */
    
        /**
         * Constructs a new PB_SCAllShiZhuangInfo.
         * @exports PB_SCAllShiZhuangInfo
         * @classdesc Represents a PB_SCAllShiZhuangInfo.
         * @implements IPB_SCAllShiZhuangInfo
         * @constructor
         * @param {IPB_SCAllShiZhuangInfo=} [properties] Properties to set
         */
        function PB_SCAllShiZhuangInfo(properties) {
            this.shizhuangList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCAllShiZhuangInfo shizhuangList.
         * @member {Array.<IPB_ShiZhuangData>} shizhuangList
         * @memberof PB_SCAllShiZhuangInfo
         * @instance
         */
        PB_SCAllShiZhuangInfo.prototype.shizhuangList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCAllShiZhuangInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCAllShiZhuangInfo
         * @static
         * @param {IPB_SCAllShiZhuangInfo=} [properties] Properties to set
         * @returns {PB_SCAllShiZhuangInfo} PB_SCAllShiZhuangInfo instance
         */
        PB_SCAllShiZhuangInfo.create = function create(properties) {
            return new PB_SCAllShiZhuangInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCAllShiZhuangInfo message. Does not implicitly {@link PB_SCAllShiZhuangInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCAllShiZhuangInfo
         * @static
         * @param {IPB_SCAllShiZhuangInfo} message PB_SCAllShiZhuangInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAllShiZhuangInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shizhuangList != null && message.shizhuangList.length)
                for (var i = 0; i < message.shizhuangList.length; ++i)
                    $root.PB_ShiZhuangData.encode(message.shizhuangList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCAllShiZhuangInfo message, length delimited. Does not implicitly {@link PB_SCAllShiZhuangInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCAllShiZhuangInfo
         * @static
         * @param {IPB_SCAllShiZhuangInfo} message PB_SCAllShiZhuangInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAllShiZhuangInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCAllShiZhuangInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCAllShiZhuangInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCAllShiZhuangInfo} PB_SCAllShiZhuangInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAllShiZhuangInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCAllShiZhuangInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.shizhuangList && message.shizhuangList.length))
                        message.shizhuangList = [];
                    message.shizhuangList.push($root.PB_ShiZhuangData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCAllShiZhuangInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCAllShiZhuangInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCAllShiZhuangInfo} PB_SCAllShiZhuangInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAllShiZhuangInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCAllShiZhuangInfo message.
         * @function verify
         * @memberof PB_SCAllShiZhuangInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCAllShiZhuangInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shizhuangList != null && message.hasOwnProperty("shizhuangList")) {
                if (!Array.isArray(message.shizhuangList))
                    return "shizhuangList: array expected";
                for (var i = 0; i < message.shizhuangList.length; ++i) {
                    var error = $root.PB_ShiZhuangData.verify(message.shizhuangList[i]);
                    if (error)
                        return "shizhuangList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCAllShiZhuangInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCAllShiZhuangInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCAllShiZhuangInfo} PB_SCAllShiZhuangInfo
         */
        PB_SCAllShiZhuangInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCAllShiZhuangInfo)
                return object;
            var message = new $root.PB_SCAllShiZhuangInfo();
            if (object.shizhuangList) {
                if (!Array.isArray(object.shizhuangList))
                    throw TypeError(".PB_SCAllShiZhuangInfo.shizhuangList: array expected");
                message.shizhuangList = [];
                for (var i = 0; i < object.shizhuangList.length; ++i) {
                    if (typeof object.shizhuangList[i] !== "object")
                        throw TypeError(".PB_SCAllShiZhuangInfo.shizhuangList: object expected");
                    message.shizhuangList[i] = $root.PB_ShiZhuangData.fromObject(object.shizhuangList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCAllShiZhuangInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCAllShiZhuangInfo
         * @static
         * @param {PB_SCAllShiZhuangInfo} message PB_SCAllShiZhuangInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCAllShiZhuangInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shizhuangList = [];
            if (message.shizhuangList && message.shizhuangList.length) {
                object.shizhuangList = [];
                for (var j = 0; j < message.shizhuangList.length; ++j)
                    object.shizhuangList[j] = $root.PB_ShiZhuangData.toObject(message.shizhuangList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCAllShiZhuangInfo to JSON.
         * @function toJSON
         * @memberof PB_SCAllShiZhuangInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCAllShiZhuangInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCAllShiZhuangInfo;
    })();
    
    $root.PB_SCShiZhuangInfo = (function() {
    
        /**
         * Properties of a PB_SCShiZhuangInfo.
         * @exports IPB_SCShiZhuangInfo
         * @interface IPB_SCShiZhuangInfo
         * @property {IPB_ShiZhuangData|null} [shizhuang] PB_SCShiZhuangInfo shizhuang
         */
    
        /**
         * Constructs a new PB_SCShiZhuangInfo.
         * @exports PB_SCShiZhuangInfo
         * @classdesc Represents a PB_SCShiZhuangInfo.
         * @implements IPB_SCShiZhuangInfo
         * @constructor
         * @param {IPB_SCShiZhuangInfo=} [properties] Properties to set
         */
        function PB_SCShiZhuangInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCShiZhuangInfo shizhuang.
         * @member {IPB_ShiZhuangData|null|undefined} shizhuang
         * @memberof PB_SCShiZhuangInfo
         * @instance
         */
        PB_SCShiZhuangInfo.prototype.shizhuang = null;
    
        /**
         * Creates a new PB_SCShiZhuangInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCShiZhuangInfo
         * @static
         * @param {IPB_SCShiZhuangInfo=} [properties] Properties to set
         * @returns {PB_SCShiZhuangInfo} PB_SCShiZhuangInfo instance
         */
        PB_SCShiZhuangInfo.create = function create(properties) {
            return new PB_SCShiZhuangInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCShiZhuangInfo message. Does not implicitly {@link PB_SCShiZhuangInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCShiZhuangInfo
         * @static
         * @param {IPB_SCShiZhuangInfo} message PB_SCShiZhuangInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCShiZhuangInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shizhuang != null && Object.hasOwnProperty.call(message, "shizhuang"))
                $root.PB_ShiZhuangData.encode(message.shizhuang, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCShiZhuangInfo message, length delimited. Does not implicitly {@link PB_SCShiZhuangInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCShiZhuangInfo
         * @static
         * @param {IPB_SCShiZhuangInfo} message PB_SCShiZhuangInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCShiZhuangInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCShiZhuangInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCShiZhuangInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCShiZhuangInfo} PB_SCShiZhuangInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCShiZhuangInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCShiZhuangInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shizhuang = $root.PB_ShiZhuangData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCShiZhuangInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCShiZhuangInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCShiZhuangInfo} PB_SCShiZhuangInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCShiZhuangInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCShiZhuangInfo message.
         * @function verify
         * @memberof PB_SCShiZhuangInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCShiZhuangInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shizhuang != null && message.hasOwnProperty("shizhuang")) {
                var error = $root.PB_ShiZhuangData.verify(message.shizhuang);
                if (error)
                    return "shizhuang." + error;
            }
            return null;
        };
    
        /**
         * Creates a PB_SCShiZhuangInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCShiZhuangInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCShiZhuangInfo} PB_SCShiZhuangInfo
         */
        PB_SCShiZhuangInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCShiZhuangInfo)
                return object;
            var message = new $root.PB_SCShiZhuangInfo();
            if (object.shizhuang != null) {
                if (typeof object.shizhuang !== "object")
                    throw TypeError(".PB_SCShiZhuangInfo.shizhuang: object expected");
                message.shizhuang = $root.PB_ShiZhuangData.fromObject(object.shizhuang);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCShiZhuangInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCShiZhuangInfo
         * @static
         * @param {PB_SCShiZhuangInfo} message PB_SCShiZhuangInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCShiZhuangInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.shizhuang = null;
            if (message.shizhuang != null && message.hasOwnProperty("shizhuang"))
                object.shizhuang = $root.PB_ShiZhuangData.toObject(message.shizhuang, options);
            return object;
        };
    
        /**
         * Converts this PB_SCShiZhuangInfo to JSON.
         * @function toJSON
         * @memberof PB_SCShiZhuangInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCShiZhuangInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCShiZhuangInfo;
    })();
    
    $root.PB_CSLoginToAccount = (function() {
    
        /**
         * Properties of a PB_CSLoginToAccount.
         * @exports IPB_CSLoginToAccount
         * @interface IPB_CSLoginToAccount
         * @property {number|null} [loginTime] PB_CSLoginToAccount loginTime
         * @property {string|null} [loginStr] PB_CSLoginToAccount loginStr
         * @property {string|null} [pname] PB_CSLoginToAccount pname
         * @property {number|null} [server] PB_CSLoginToAccount server
         * @property {number|null} [platSpid] PB_CSLoginToAccount platSpid
         */
    
        /**
         * Constructs a new PB_CSLoginToAccount.
         * @exports PB_CSLoginToAccount
         * @classdesc Represents a PB_CSLoginToAccount.
         * @implements IPB_CSLoginToAccount
         * @constructor
         * @param {IPB_CSLoginToAccount=} [properties] Properties to set
         */
        function PB_CSLoginToAccount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSLoginToAccount loginTime.
         * @member {number} loginTime
         * @memberof PB_CSLoginToAccount
         * @instance
         */
        PB_CSLoginToAccount.prototype.loginTime = 0;
    
        /**
         * PB_CSLoginToAccount loginStr.
         * @member {string} loginStr
         * @memberof PB_CSLoginToAccount
         * @instance
         */
        PB_CSLoginToAccount.prototype.loginStr = "";
    
        /**
         * PB_CSLoginToAccount pname.
         * @member {string} pname
         * @memberof PB_CSLoginToAccount
         * @instance
         */
        PB_CSLoginToAccount.prototype.pname = "";
    
        /**
         * PB_CSLoginToAccount server.
         * @member {number} server
         * @memberof PB_CSLoginToAccount
         * @instance
         */
        PB_CSLoginToAccount.prototype.server = 0;
    
        /**
         * PB_CSLoginToAccount platSpid.
         * @member {number} platSpid
         * @memberof PB_CSLoginToAccount
         * @instance
         */
        PB_CSLoginToAccount.prototype.platSpid = 0;
    
        /**
         * Creates a new PB_CSLoginToAccount instance using the specified properties.
         * @function create
         * @memberof PB_CSLoginToAccount
         * @static
         * @param {IPB_CSLoginToAccount=} [properties] Properties to set
         * @returns {PB_CSLoginToAccount} PB_CSLoginToAccount instance
         */
        PB_CSLoginToAccount.create = function create(properties) {
            return new PB_CSLoginToAccount(properties);
        };
    
        /**
         * Encodes the specified PB_CSLoginToAccount message. Does not implicitly {@link PB_CSLoginToAccount.verify|verify} messages.
         * @function encode
         * @memberof PB_CSLoginToAccount
         * @static
         * @param {IPB_CSLoginToAccount} message PB_CSLoginToAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSLoginToAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.loginTime != null && Object.hasOwnProperty.call(message, "loginTime"))
                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.loginTime);
            if (message.loginStr != null && Object.hasOwnProperty.call(message, "loginStr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.loginStr);
            if (message.pname != null && Object.hasOwnProperty.call(message, "pname"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.pname);
            if (message.server != null && Object.hasOwnProperty.call(message, "server"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.server);
            if (message.platSpid != null && Object.hasOwnProperty.call(message, "platSpid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.platSpid);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSLoginToAccount message, length delimited. Does not implicitly {@link PB_CSLoginToAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSLoginToAccount
         * @static
         * @param {IPB_CSLoginToAccount} message PB_CSLoginToAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSLoginToAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSLoginToAccount message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSLoginToAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSLoginToAccount} PB_CSLoginToAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSLoginToAccount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSLoginToAccount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.loginTime = reader.fixed32();
                    break;
                case 2:
                    message.loginStr = reader.string();
                    break;
                case 3:
                    message.pname = reader.string();
                    break;
                case 4:
                    message.server = reader.int32();
                    break;
                case 5:
                    message.platSpid = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSLoginToAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSLoginToAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSLoginToAccount} PB_CSLoginToAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSLoginToAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSLoginToAccount message.
         * @function verify
         * @memberof PB_CSLoginToAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSLoginToAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.loginTime != null && message.hasOwnProperty("loginTime"))
                if (!$util.isInteger(message.loginTime))
                    return "loginTime: integer expected";
            if (message.loginStr != null && message.hasOwnProperty("loginStr"))
                if (!$util.isString(message.loginStr))
                    return "loginStr: string expected";
            if (message.pname != null && message.hasOwnProperty("pname"))
                if (!$util.isString(message.pname))
                    return "pname: string expected";
            if (message.server != null && message.hasOwnProperty("server"))
                if (!$util.isInteger(message.server))
                    return "server: integer expected";
            if (message.platSpid != null && message.hasOwnProperty("platSpid"))
                if (!$util.isInteger(message.platSpid))
                    return "platSpid: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSLoginToAccount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSLoginToAccount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSLoginToAccount} PB_CSLoginToAccount
         */
        PB_CSLoginToAccount.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSLoginToAccount)
                return object;
            var message = new $root.PB_CSLoginToAccount();
            if (object.loginTime != null)
                message.loginTime = object.loginTime >>> 0;
            if (object.loginStr != null)
                message.loginStr = String(object.loginStr);
            if (object.pname != null)
                message.pname = String(object.pname);
            if (object.server != null)
                message.server = object.server | 0;
            if (object.platSpid != null)
                message.platSpid = object.platSpid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSLoginToAccount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSLoginToAccount
         * @static
         * @param {PB_CSLoginToAccount} message PB_CSLoginToAccount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSLoginToAccount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.loginTime = 0;
                object.loginStr = "";
                object.pname = "";
                object.server = 0;
                object.platSpid = 0;
            }
            if (message.loginTime != null && message.hasOwnProperty("loginTime"))
                object.loginTime = message.loginTime;
            if (message.loginStr != null && message.hasOwnProperty("loginStr"))
                object.loginStr = message.loginStr;
            if (message.pname != null && message.hasOwnProperty("pname"))
                object.pname = message.pname;
            if (message.server != null && message.hasOwnProperty("server"))
                object.server = message.server;
            if (message.platSpid != null && message.hasOwnProperty("platSpid"))
                object.platSpid = message.platSpid;
            return object;
        };
    
        /**
         * Converts this PB_CSLoginToAccount to JSON.
         * @function toJSON
         * @memberof PB_CSLoginToAccount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSLoginToAccount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSLoginToAccount;
    })();
    
    $root.PB_SCLoginToAccount = (function() {
    
        /**
         * Properties of a PB_SCLoginToAccount.
         * @exports IPB_SCLoginToAccount
         * @interface IPB_SCLoginToAccount
         * @property {number|null} [result] PB_SCLoginToAccount result
         * @property {number|null} [forbidTime] PB_SCLoginToAccount forbidTime
         */
    
        /**
         * Constructs a new PB_SCLoginToAccount.
         * @exports PB_SCLoginToAccount
         * @classdesc Represents a PB_SCLoginToAccount.
         * @implements IPB_SCLoginToAccount
         * @constructor
         * @param {IPB_SCLoginToAccount=} [properties] Properties to set
         */
        function PB_SCLoginToAccount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCLoginToAccount result.
         * @member {number} result
         * @memberof PB_SCLoginToAccount
         * @instance
         */
        PB_SCLoginToAccount.prototype.result = 0;
    
        /**
         * PB_SCLoginToAccount forbidTime.
         * @member {number} forbidTime
         * @memberof PB_SCLoginToAccount
         * @instance
         */
        PB_SCLoginToAccount.prototype.forbidTime = 0;
    
        /**
         * Creates a new PB_SCLoginToAccount instance using the specified properties.
         * @function create
         * @memberof PB_SCLoginToAccount
         * @static
         * @param {IPB_SCLoginToAccount=} [properties] Properties to set
         * @returns {PB_SCLoginToAccount} PB_SCLoginToAccount instance
         */
        PB_SCLoginToAccount.create = function create(properties) {
            return new PB_SCLoginToAccount(properties);
        };
    
        /**
         * Encodes the specified PB_SCLoginToAccount message. Does not implicitly {@link PB_SCLoginToAccount.verify|verify} messages.
         * @function encode
         * @memberof PB_SCLoginToAccount
         * @static
         * @param {IPB_SCLoginToAccount} message PB_SCLoginToAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLoginToAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.forbidTime != null && Object.hasOwnProperty.call(message, "forbidTime"))
                writer.uint32(/* id 2, wireType 5 =*/21).fixed32(message.forbidTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCLoginToAccount message, length delimited. Does not implicitly {@link PB_SCLoginToAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCLoginToAccount
         * @static
         * @param {IPB_SCLoginToAccount} message PB_SCLoginToAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLoginToAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCLoginToAccount message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCLoginToAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCLoginToAccount} PB_SCLoginToAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLoginToAccount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCLoginToAccount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.forbidTime = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCLoginToAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCLoginToAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCLoginToAccount} PB_SCLoginToAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLoginToAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCLoginToAccount message.
         * @function verify
         * @memberof PB_SCLoginToAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCLoginToAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
            if (message.forbidTime != null && message.hasOwnProperty("forbidTime"))
                if (!$util.isInteger(message.forbidTime))
                    return "forbidTime: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCLoginToAccount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCLoginToAccount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCLoginToAccount} PB_SCLoginToAccount
         */
        PB_SCLoginToAccount.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCLoginToAccount)
                return object;
            var message = new $root.PB_SCLoginToAccount();
            if (object.result != null)
                message.result = object.result | 0;
            if (object.forbidTime != null)
                message.forbidTime = object.forbidTime >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCLoginToAccount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCLoginToAccount
         * @static
         * @param {PB_SCLoginToAccount} message PB_SCLoginToAccount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCLoginToAccount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.result = 0;
                object.forbidTime = 0;
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            if (message.forbidTime != null && message.hasOwnProperty("forbidTime"))
                object.forbidTime = message.forbidTime;
            return object;
        };
    
        /**
         * Converts this PB_SCLoginToAccount to JSON.
         * @function toJSON
         * @memberof PB_SCLoginToAccount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCLoginToAccount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCLoginToAccount;
    })();
    
    $root.PB_SCAccountKeyError = (function() {
    
        /**
         * Properties of a PB_SCAccountKeyError.
         * @exports IPB_SCAccountKeyError
         * @interface IPB_SCAccountKeyError
         */
    
        /**
         * Constructs a new PB_SCAccountKeyError.
         * @exports PB_SCAccountKeyError
         * @classdesc Represents a PB_SCAccountKeyError.
         * @implements IPB_SCAccountKeyError
         * @constructor
         * @param {IPB_SCAccountKeyError=} [properties] Properties to set
         */
        function PB_SCAccountKeyError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new PB_SCAccountKeyError instance using the specified properties.
         * @function create
         * @memberof PB_SCAccountKeyError
         * @static
         * @param {IPB_SCAccountKeyError=} [properties] Properties to set
         * @returns {PB_SCAccountKeyError} PB_SCAccountKeyError instance
         */
        PB_SCAccountKeyError.create = function create(properties) {
            return new PB_SCAccountKeyError(properties);
        };
    
        /**
         * Encodes the specified PB_SCAccountKeyError message. Does not implicitly {@link PB_SCAccountKeyError.verify|verify} messages.
         * @function encode
         * @memberof PB_SCAccountKeyError
         * @static
         * @param {IPB_SCAccountKeyError} message PB_SCAccountKeyError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAccountKeyError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCAccountKeyError message, length delimited. Does not implicitly {@link PB_SCAccountKeyError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCAccountKeyError
         * @static
         * @param {IPB_SCAccountKeyError} message PB_SCAccountKeyError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAccountKeyError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCAccountKeyError message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCAccountKeyError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCAccountKeyError} PB_SCAccountKeyError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAccountKeyError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCAccountKeyError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCAccountKeyError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCAccountKeyError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCAccountKeyError} PB_SCAccountKeyError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAccountKeyError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCAccountKeyError message.
         * @function verify
         * @memberof PB_SCAccountKeyError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCAccountKeyError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a PB_SCAccountKeyError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCAccountKeyError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCAccountKeyError} PB_SCAccountKeyError
         */
        PB_SCAccountKeyError.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCAccountKeyError)
                return object;
            return new $root.PB_SCAccountKeyError();
        };
    
        /**
         * Creates a plain object from a PB_SCAccountKeyError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCAccountKeyError
         * @static
         * @param {PB_SCAccountKeyError} message PB_SCAccountKeyError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCAccountKeyError.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this PB_SCAccountKeyError to JSON.
         * @function toJSON
         * @memberof PB_SCAccountKeyError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCAccountKeyError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCAccountKeyError;
    })();
    
    $root.PB_MailAckInfo = (function() {
    
        /**
         * Properties of a PB_MailAckInfo.
         * @exports IPB_MailAckInfo
         * @interface IPB_MailAckInfo
         * @property {number|null} [mailType] PB_MailAckInfo mailType
         * @property {number|null} [mailIndex] PB_MailAckInfo mailIndex
         * @property {number|null} [ret] PB_MailAckInfo ret
         */
    
        /**
         * Constructs a new PB_MailAckInfo.
         * @exports PB_MailAckInfo
         * @classdesc Represents a PB_MailAckInfo.
         * @implements IPB_MailAckInfo
         * @constructor
         * @param {IPB_MailAckInfo=} [properties] Properties to set
         */
        function PB_MailAckInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MailAckInfo mailType.
         * @member {number} mailType
         * @memberof PB_MailAckInfo
         * @instance
         */
        PB_MailAckInfo.prototype.mailType = 0;
    
        /**
         * PB_MailAckInfo mailIndex.
         * @member {number} mailIndex
         * @memberof PB_MailAckInfo
         * @instance
         */
        PB_MailAckInfo.prototype.mailIndex = 0;
    
        /**
         * PB_MailAckInfo ret.
         * @member {number} ret
         * @memberof PB_MailAckInfo
         * @instance
         */
        PB_MailAckInfo.prototype.ret = 0;
    
        /**
         * Creates a new PB_MailAckInfo instance using the specified properties.
         * @function create
         * @memberof PB_MailAckInfo
         * @static
         * @param {IPB_MailAckInfo=} [properties] Properties to set
         * @returns {PB_MailAckInfo} PB_MailAckInfo instance
         */
        PB_MailAckInfo.create = function create(properties) {
            return new PB_MailAckInfo(properties);
        };
    
        /**
         * Encodes the specified PB_MailAckInfo message. Does not implicitly {@link PB_MailAckInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_MailAckInfo
         * @static
         * @param {IPB_MailAckInfo} message PB_MailAckInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MailAckInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailType != null && Object.hasOwnProperty.call(message, "mailType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailType);
            if (message.mailIndex != null && Object.hasOwnProperty.call(message, "mailIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mailIndex);
            if (message.ret != null && Object.hasOwnProperty.call(message, "ret"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ret);
            return writer;
        };
    
        /**
         * Encodes the specified PB_MailAckInfo message, length delimited. Does not implicitly {@link PB_MailAckInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MailAckInfo
         * @static
         * @param {IPB_MailAckInfo} message PB_MailAckInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MailAckInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MailAckInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MailAckInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MailAckInfo} PB_MailAckInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MailAckInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MailAckInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailType = reader.int32();
                    break;
                case 2:
                    message.mailIndex = reader.int32();
                    break;
                case 3:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MailAckInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MailAckInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MailAckInfo} PB_MailAckInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MailAckInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MailAckInfo message.
         * @function verify
         * @memberof PB_MailAckInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MailAckInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailType != null && message.hasOwnProperty("mailType"))
                if (!$util.isInteger(message.mailType))
                    return "mailType: integer expected";
            if (message.mailIndex != null && message.hasOwnProperty("mailIndex"))
                if (!$util.isInteger(message.mailIndex))
                    return "mailIndex: integer expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_MailAckInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MailAckInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MailAckInfo} PB_MailAckInfo
         */
        PB_MailAckInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MailAckInfo)
                return object;
            var message = new $root.PB_MailAckInfo();
            if (object.mailType != null)
                message.mailType = object.mailType | 0;
            if (object.mailIndex != null)
                message.mailIndex = object.mailIndex | 0;
            if (object.ret != null)
                message.ret = object.ret | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MailAckInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MailAckInfo
         * @static
         * @param {PB_MailAckInfo} message PB_MailAckInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MailAckInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mailType = 0;
                object.mailIndex = 0;
                object.ret = 0;
            }
            if (message.mailType != null && message.hasOwnProperty("mailType"))
                object.mailType = message.mailType;
            if (message.mailIndex != null && message.hasOwnProperty("mailIndex"))
                object.mailIndex = message.mailIndex;
            if (message.ret != null && message.hasOwnProperty("ret"))
                object.ret = message.ret;
            return object;
        };
    
        /**
         * Converts this PB_MailAckInfo to JSON.
         * @function toJSON
         * @memberof PB_MailAckInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MailAckInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MailAckInfo;
    })();
    
    $root.PB_SCMailDeleteAck = (function() {
    
        /**
         * Properties of a PB_SCMailDeleteAck.
         * @exports IPB_SCMailDeleteAck
         * @interface IPB_SCMailDeleteAck
         * @property {Array.<IPB_MailAckInfo>|null} [askInfo] PB_SCMailDeleteAck askInfo
         */
    
        /**
         * Constructs a new PB_SCMailDeleteAck.
         * @exports PB_SCMailDeleteAck
         * @classdesc Represents a PB_SCMailDeleteAck.
         * @implements IPB_SCMailDeleteAck
         * @constructor
         * @param {IPB_SCMailDeleteAck=} [properties] Properties to set
         */
        function PB_SCMailDeleteAck(properties) {
            this.askInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCMailDeleteAck askInfo.
         * @member {Array.<IPB_MailAckInfo>} askInfo
         * @memberof PB_SCMailDeleteAck
         * @instance
         */
        PB_SCMailDeleteAck.prototype.askInfo = $util.emptyArray;
    
        /**
         * Creates a new PB_SCMailDeleteAck instance using the specified properties.
         * @function create
         * @memberof PB_SCMailDeleteAck
         * @static
         * @param {IPB_SCMailDeleteAck=} [properties] Properties to set
         * @returns {PB_SCMailDeleteAck} PB_SCMailDeleteAck instance
         */
        PB_SCMailDeleteAck.create = function create(properties) {
            return new PB_SCMailDeleteAck(properties);
        };
    
        /**
         * Encodes the specified PB_SCMailDeleteAck message. Does not implicitly {@link PB_SCMailDeleteAck.verify|verify} messages.
         * @function encode
         * @memberof PB_SCMailDeleteAck
         * @static
         * @param {IPB_SCMailDeleteAck} message PB_SCMailDeleteAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMailDeleteAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.askInfo != null && message.askInfo.length)
                for (var i = 0; i < message.askInfo.length; ++i)
                    $root.PB_MailAckInfo.encode(message.askInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCMailDeleteAck message, length delimited. Does not implicitly {@link PB_SCMailDeleteAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCMailDeleteAck
         * @static
         * @param {IPB_SCMailDeleteAck} message PB_SCMailDeleteAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMailDeleteAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCMailDeleteAck message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCMailDeleteAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCMailDeleteAck} PB_SCMailDeleteAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMailDeleteAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCMailDeleteAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.askInfo && message.askInfo.length))
                        message.askInfo = [];
                    message.askInfo.push($root.PB_MailAckInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCMailDeleteAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCMailDeleteAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCMailDeleteAck} PB_SCMailDeleteAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMailDeleteAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCMailDeleteAck message.
         * @function verify
         * @memberof PB_SCMailDeleteAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCMailDeleteAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.askInfo != null && message.hasOwnProperty("askInfo")) {
                if (!Array.isArray(message.askInfo))
                    return "askInfo: array expected";
                for (var i = 0; i < message.askInfo.length; ++i) {
                    var error = $root.PB_MailAckInfo.verify(message.askInfo[i]);
                    if (error)
                        return "askInfo." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCMailDeleteAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCMailDeleteAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCMailDeleteAck} PB_SCMailDeleteAck
         */
        PB_SCMailDeleteAck.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCMailDeleteAck)
                return object;
            var message = new $root.PB_SCMailDeleteAck();
            if (object.askInfo) {
                if (!Array.isArray(object.askInfo))
                    throw TypeError(".PB_SCMailDeleteAck.askInfo: array expected");
                message.askInfo = [];
                for (var i = 0; i < object.askInfo.length; ++i) {
                    if (typeof object.askInfo[i] !== "object")
                        throw TypeError(".PB_SCMailDeleteAck.askInfo: object expected");
                    message.askInfo[i] = $root.PB_MailAckInfo.fromObject(object.askInfo[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCMailDeleteAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCMailDeleteAck
         * @static
         * @param {PB_SCMailDeleteAck} message PB_SCMailDeleteAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCMailDeleteAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.askInfo = [];
            if (message.askInfo && message.askInfo.length) {
                object.askInfo = [];
                for (var j = 0; j < message.askInfo.length; ++j)
                    object.askInfo[j] = $root.PB_MailAckInfo.toObject(message.askInfo[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCMailDeleteAck to JSON.
         * @function toJSON
         * @memberof PB_SCMailDeleteAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCMailDeleteAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCMailDeleteAck;
    })();
    
    $root.PB_MailBriefData = (function() {
    
        /**
         * Properties of a PB_MailBriefData.
         * @exports IPB_MailBriefData
         * @interface IPB_MailBriefData
         * @property {number|null} [mailType] PB_MailBriefData mailType
         * @property {number|null} [mailIndex] PB_MailBriefData mailIndex
         * @property {number|null} [recvTime] PB_MailBriefData recvTime
         * @property {number|null} [isRead] PB_MailBriefData isRead
         * @property {number|null} [isFetch] PB_MailBriefData isFetch
         * @property {Uint8Array|null} [subject] PB_MailBriefData subject
         * @property {Array.<IPB_ItemData>|null} [itemData] PB_MailBriefData itemData
         * @property {number|null} [expirationTime] PB_MailBriefData expirationTime
         * @property {boolean|null} [isAdMail] PB_MailBriefData isAdMail
         */
    
        /**
         * Constructs a new PB_MailBriefData.
         * @exports PB_MailBriefData
         * @classdesc Represents a PB_MailBriefData.
         * @implements IPB_MailBriefData
         * @constructor
         * @param {IPB_MailBriefData=} [properties] Properties to set
         */
        function PB_MailBriefData(properties) {
            this.itemData = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MailBriefData mailType.
         * @member {number} mailType
         * @memberof PB_MailBriefData
         * @instance
         */
        PB_MailBriefData.prototype.mailType = 0;
    
        /**
         * PB_MailBriefData mailIndex.
         * @member {number} mailIndex
         * @memberof PB_MailBriefData
         * @instance
         */
        PB_MailBriefData.prototype.mailIndex = 0;
    
        /**
         * PB_MailBriefData recvTime.
         * @member {number} recvTime
         * @memberof PB_MailBriefData
         * @instance
         */
        PB_MailBriefData.prototype.recvTime = 0;
    
        /**
         * PB_MailBriefData isRead.
         * @member {number} isRead
         * @memberof PB_MailBriefData
         * @instance
         */
        PB_MailBriefData.prototype.isRead = 0;
    
        /**
         * PB_MailBriefData isFetch.
         * @member {number} isFetch
         * @memberof PB_MailBriefData
         * @instance
         */
        PB_MailBriefData.prototype.isFetch = 0;
    
        /**
         * PB_MailBriefData subject.
         * @member {Uint8Array} subject
         * @memberof PB_MailBriefData
         * @instance
         */
        PB_MailBriefData.prototype.subject = $util.newBuffer([]);
    
        /**
         * PB_MailBriefData itemData.
         * @member {Array.<IPB_ItemData>} itemData
         * @memberof PB_MailBriefData
         * @instance
         */
        PB_MailBriefData.prototype.itemData = $util.emptyArray;
    
        /**
         * PB_MailBriefData expirationTime.
         * @member {number} expirationTime
         * @memberof PB_MailBriefData
         * @instance
         */
        PB_MailBriefData.prototype.expirationTime = 0;
    
        /**
         * PB_MailBriefData isAdMail.
         * @member {boolean} isAdMail
         * @memberof PB_MailBriefData
         * @instance
         */
        PB_MailBriefData.prototype.isAdMail = false;
    
        /**
         * Creates a new PB_MailBriefData instance using the specified properties.
         * @function create
         * @memberof PB_MailBriefData
         * @static
         * @param {IPB_MailBriefData=} [properties] Properties to set
         * @returns {PB_MailBriefData} PB_MailBriefData instance
         */
        PB_MailBriefData.create = function create(properties) {
            return new PB_MailBriefData(properties);
        };
    
        /**
         * Encodes the specified PB_MailBriefData message. Does not implicitly {@link PB_MailBriefData.verify|verify} messages.
         * @function encode
         * @memberof PB_MailBriefData
         * @static
         * @param {IPB_MailBriefData} message PB_MailBriefData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MailBriefData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailType != null && Object.hasOwnProperty.call(message, "mailType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailType);
            if (message.mailIndex != null && Object.hasOwnProperty.call(message, "mailIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mailIndex);
            if (message.recvTime != null && Object.hasOwnProperty.call(message, "recvTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.recvTime);
            if (message.isRead != null && Object.hasOwnProperty.call(message, "isRead"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.isRead);
            if (message.isFetch != null && Object.hasOwnProperty.call(message, "isFetch"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.isFetch);
            if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.subject);
            if (message.itemData != null && message.itemData.length)
                for (var i = 0; i < message.itemData.length; ++i)
                    $root.PB_ItemData.encode(message.itemData[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.expirationTime != null && Object.hasOwnProperty.call(message, "expirationTime"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.expirationTime);
            if (message.isAdMail != null && Object.hasOwnProperty.call(message, "isAdMail"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isAdMail);
            return writer;
        };
    
        /**
         * Encodes the specified PB_MailBriefData message, length delimited. Does not implicitly {@link PB_MailBriefData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MailBriefData
         * @static
         * @param {IPB_MailBriefData} message PB_MailBriefData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MailBriefData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MailBriefData message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MailBriefData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MailBriefData} PB_MailBriefData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MailBriefData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MailBriefData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailType = reader.int32();
                    break;
                case 2:
                    message.mailIndex = reader.int32();
                    break;
                case 3:
                    message.recvTime = reader.uint32();
                    break;
                case 4:
                    message.isRead = reader.int32();
                    break;
                case 5:
                    message.isFetch = reader.int32();
                    break;
                case 6:
                    message.subject = reader.bytes();
                    break;
                case 7:
                    if (!(message.itemData && message.itemData.length))
                        message.itemData = [];
                    message.itemData.push($root.PB_ItemData.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.expirationTime = reader.uint32();
                    break;
                case 9:
                    message.isAdMail = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MailBriefData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MailBriefData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MailBriefData} PB_MailBriefData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MailBriefData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MailBriefData message.
         * @function verify
         * @memberof PB_MailBriefData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MailBriefData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailType != null && message.hasOwnProperty("mailType"))
                if (!$util.isInteger(message.mailType))
                    return "mailType: integer expected";
            if (message.mailIndex != null && message.hasOwnProperty("mailIndex"))
                if (!$util.isInteger(message.mailIndex))
                    return "mailIndex: integer expected";
            if (message.recvTime != null && message.hasOwnProperty("recvTime"))
                if (!$util.isInteger(message.recvTime))
                    return "recvTime: integer expected";
            if (message.isRead != null && message.hasOwnProperty("isRead"))
                if (!$util.isInteger(message.isRead))
                    return "isRead: integer expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                if (!$util.isInteger(message.isFetch))
                    return "isFetch: integer expected";
            if (message.subject != null && message.hasOwnProperty("subject"))
                if (!(message.subject && typeof message.subject.length === "number" || $util.isString(message.subject)))
                    return "subject: buffer expected";
            if (message.itemData != null && message.hasOwnProperty("itemData")) {
                if (!Array.isArray(message.itemData))
                    return "itemData: array expected";
                for (var i = 0; i < message.itemData.length; ++i) {
                    var error = $root.PB_ItemData.verify(message.itemData[i]);
                    if (error)
                        return "itemData." + error;
                }
            }
            if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                if (!$util.isInteger(message.expirationTime))
                    return "expirationTime: integer expected";
            if (message.isAdMail != null && message.hasOwnProperty("isAdMail"))
                if (typeof message.isAdMail !== "boolean")
                    return "isAdMail: boolean expected";
            return null;
        };
    
        /**
         * Creates a PB_MailBriefData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MailBriefData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MailBriefData} PB_MailBriefData
         */
        PB_MailBriefData.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MailBriefData)
                return object;
            var message = new $root.PB_MailBriefData();
            if (object.mailType != null)
                message.mailType = object.mailType | 0;
            if (object.mailIndex != null)
                message.mailIndex = object.mailIndex | 0;
            if (object.recvTime != null)
                message.recvTime = object.recvTime >>> 0;
            if (object.isRead != null)
                message.isRead = object.isRead | 0;
            if (object.isFetch != null)
                message.isFetch = object.isFetch | 0;
            if (object.subject != null)
                if (typeof object.subject === "string")
                    $util.base64.decode(object.subject, message.subject = $util.newBuffer($util.base64.length(object.subject)), 0);
                else if (object.subject.length)
                    message.subject = object.subject;
            if (object.itemData) {
                if (!Array.isArray(object.itemData))
                    throw TypeError(".PB_MailBriefData.itemData: array expected");
                message.itemData = [];
                for (var i = 0; i < object.itemData.length; ++i) {
                    if (typeof object.itemData[i] !== "object")
                        throw TypeError(".PB_MailBriefData.itemData: object expected");
                    message.itemData[i] = $root.PB_ItemData.fromObject(object.itemData[i]);
                }
            }
            if (object.expirationTime != null)
                message.expirationTime = object.expirationTime >>> 0;
            if (object.isAdMail != null)
                message.isAdMail = Boolean(object.isAdMail);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MailBriefData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MailBriefData
         * @static
         * @param {PB_MailBriefData} message PB_MailBriefData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MailBriefData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemData = [];
            if (options.defaults) {
                object.mailType = 0;
                object.mailIndex = 0;
                object.recvTime = 0;
                object.isRead = 0;
                object.isFetch = 0;
                if (options.bytes === String)
                    object.subject = "";
                else {
                    object.subject = [];
                    if (options.bytes !== Array)
                        object.subject = $util.newBuffer(object.subject);
                }
                object.expirationTime = 0;
                object.isAdMail = false;
            }
            if (message.mailType != null && message.hasOwnProperty("mailType"))
                object.mailType = message.mailType;
            if (message.mailIndex != null && message.hasOwnProperty("mailIndex"))
                object.mailIndex = message.mailIndex;
            if (message.recvTime != null && message.hasOwnProperty("recvTime"))
                object.recvTime = message.recvTime;
            if (message.isRead != null && message.hasOwnProperty("isRead"))
                object.isRead = message.isRead;
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                object.isFetch = message.isFetch;
            if (message.subject != null && message.hasOwnProperty("subject"))
                object.subject = options.bytes === String ? $util.base64.encode(message.subject, 0, message.subject.length) : options.bytes === Array ? Array.prototype.slice.call(message.subject) : message.subject;
            if (message.itemData && message.itemData.length) {
                object.itemData = [];
                for (var j = 0; j < message.itemData.length; ++j)
                    object.itemData[j] = $root.PB_ItemData.toObject(message.itemData[j], options);
            }
            if (message.expirationTime != null && message.hasOwnProperty("expirationTime"))
                object.expirationTime = message.expirationTime;
            if (message.isAdMail != null && message.hasOwnProperty("isAdMail"))
                object.isAdMail = message.isAdMail;
            return object;
        };
    
        /**
         * Converts this PB_MailBriefData to JSON.
         * @function toJSON
         * @memberof PB_MailBriefData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MailBriefData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MailBriefData;
    })();
    
    $root.PB_SCMailListAck = (function() {
    
        /**
         * Properties of a PB_SCMailListAck.
         * @exports IPB_SCMailListAck
         * @interface IPB_SCMailListAck
         * @property {Array.<IPB_MailBriefData>|null} [mailBriefData] PB_SCMailListAck mailBriefData
         * @property {number|null} [sendType] PB_SCMailListAck sendType
         */
    
        /**
         * Constructs a new PB_SCMailListAck.
         * @exports PB_SCMailListAck
         * @classdesc Represents a PB_SCMailListAck.
         * @implements IPB_SCMailListAck
         * @constructor
         * @param {IPB_SCMailListAck=} [properties] Properties to set
         */
        function PB_SCMailListAck(properties) {
            this.mailBriefData = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCMailListAck mailBriefData.
         * @member {Array.<IPB_MailBriefData>} mailBriefData
         * @memberof PB_SCMailListAck
         * @instance
         */
        PB_SCMailListAck.prototype.mailBriefData = $util.emptyArray;
    
        /**
         * PB_SCMailListAck sendType.
         * @member {number} sendType
         * @memberof PB_SCMailListAck
         * @instance
         */
        PB_SCMailListAck.prototype.sendType = 0;
    
        /**
         * Creates a new PB_SCMailListAck instance using the specified properties.
         * @function create
         * @memberof PB_SCMailListAck
         * @static
         * @param {IPB_SCMailListAck=} [properties] Properties to set
         * @returns {PB_SCMailListAck} PB_SCMailListAck instance
         */
        PB_SCMailListAck.create = function create(properties) {
            return new PB_SCMailListAck(properties);
        };
    
        /**
         * Encodes the specified PB_SCMailListAck message. Does not implicitly {@link PB_SCMailListAck.verify|verify} messages.
         * @function encode
         * @memberof PB_SCMailListAck
         * @static
         * @param {IPB_SCMailListAck} message PB_SCMailListAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMailListAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailBriefData != null && message.mailBriefData.length)
                for (var i = 0; i < message.mailBriefData.length; ++i)
                    $root.PB_MailBriefData.encode(message.mailBriefData[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sendType != null && Object.hasOwnProperty.call(message, "sendType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sendType);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCMailListAck message, length delimited. Does not implicitly {@link PB_SCMailListAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCMailListAck
         * @static
         * @param {IPB_SCMailListAck} message PB_SCMailListAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMailListAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCMailListAck message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCMailListAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCMailListAck} PB_SCMailListAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMailListAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCMailListAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.mailBriefData && message.mailBriefData.length))
                        message.mailBriefData = [];
                    message.mailBriefData.push($root.PB_MailBriefData.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.sendType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCMailListAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCMailListAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCMailListAck} PB_SCMailListAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMailListAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCMailListAck message.
         * @function verify
         * @memberof PB_SCMailListAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCMailListAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailBriefData != null && message.hasOwnProperty("mailBriefData")) {
                if (!Array.isArray(message.mailBriefData))
                    return "mailBriefData: array expected";
                for (var i = 0; i < message.mailBriefData.length; ++i) {
                    var error = $root.PB_MailBriefData.verify(message.mailBriefData[i]);
                    if (error)
                        return "mailBriefData." + error;
                }
            }
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                if (!$util.isInteger(message.sendType))
                    return "sendType: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCMailListAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCMailListAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCMailListAck} PB_SCMailListAck
         */
        PB_SCMailListAck.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCMailListAck)
                return object;
            var message = new $root.PB_SCMailListAck();
            if (object.mailBriefData) {
                if (!Array.isArray(object.mailBriefData))
                    throw TypeError(".PB_SCMailListAck.mailBriefData: array expected");
                message.mailBriefData = [];
                for (var i = 0; i < object.mailBriefData.length; ++i) {
                    if (typeof object.mailBriefData[i] !== "object")
                        throw TypeError(".PB_SCMailListAck.mailBriefData: object expected");
                    message.mailBriefData[i] = $root.PB_MailBriefData.fromObject(object.mailBriefData[i]);
                }
            }
            if (object.sendType != null)
                message.sendType = object.sendType | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCMailListAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCMailListAck
         * @static
         * @param {PB_SCMailListAck} message PB_SCMailListAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCMailListAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mailBriefData = [];
            if (options.defaults)
                object.sendType = 0;
            if (message.mailBriefData && message.mailBriefData.length) {
                object.mailBriefData = [];
                for (var j = 0; j < message.mailBriefData.length; ++j)
                    object.mailBriefData[j] = $root.PB_MailBriefData.toObject(message.mailBriefData[j], options);
            }
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                object.sendType = message.sendType;
            return object;
        };
    
        /**
         * Converts this PB_SCMailListAck to JSON.
         * @function toJSON
         * @memberof PB_SCMailListAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCMailListAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCMailListAck;
    })();
    
    $root.PB_SCMailDetail = (function() {
    
        /**
         * Properties of a PB_SCMailDetail.
         * @exports IPB_SCMailDetail
         * @interface IPB_SCMailDetail
         * @property {number|null} [mailType] PB_SCMailDetail mailType
         * @property {number|null} [mailIndex] PB_SCMailDetail mailIndex
         * @property {Uint8Array|null} [subject] PB_SCMailDetail subject
         * @property {Uint8Array|null} [contenttxt] PB_SCMailDetail contenttxt
         * @property {Array.<IPB_ItemData>|null} [itemData] PB_SCMailDetail itemData
         */
    
        /**
         * Constructs a new PB_SCMailDetail.
         * @exports PB_SCMailDetail
         * @classdesc Represents a PB_SCMailDetail.
         * @implements IPB_SCMailDetail
         * @constructor
         * @param {IPB_SCMailDetail=} [properties] Properties to set
         */
        function PB_SCMailDetail(properties) {
            this.itemData = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCMailDetail mailType.
         * @member {number} mailType
         * @memberof PB_SCMailDetail
         * @instance
         */
        PB_SCMailDetail.prototype.mailType = 0;
    
        /**
         * PB_SCMailDetail mailIndex.
         * @member {number} mailIndex
         * @memberof PB_SCMailDetail
         * @instance
         */
        PB_SCMailDetail.prototype.mailIndex = 0;
    
        /**
         * PB_SCMailDetail subject.
         * @member {Uint8Array} subject
         * @memberof PB_SCMailDetail
         * @instance
         */
        PB_SCMailDetail.prototype.subject = $util.newBuffer([]);
    
        /**
         * PB_SCMailDetail contenttxt.
         * @member {Uint8Array} contenttxt
         * @memberof PB_SCMailDetail
         * @instance
         */
        PB_SCMailDetail.prototype.contenttxt = $util.newBuffer([]);
    
        /**
         * PB_SCMailDetail itemData.
         * @member {Array.<IPB_ItemData>} itemData
         * @memberof PB_SCMailDetail
         * @instance
         */
        PB_SCMailDetail.prototype.itemData = $util.emptyArray;
    
        /**
         * Creates a new PB_SCMailDetail instance using the specified properties.
         * @function create
         * @memberof PB_SCMailDetail
         * @static
         * @param {IPB_SCMailDetail=} [properties] Properties to set
         * @returns {PB_SCMailDetail} PB_SCMailDetail instance
         */
        PB_SCMailDetail.create = function create(properties) {
            return new PB_SCMailDetail(properties);
        };
    
        /**
         * Encodes the specified PB_SCMailDetail message. Does not implicitly {@link PB_SCMailDetail.verify|verify} messages.
         * @function encode
         * @memberof PB_SCMailDetail
         * @static
         * @param {IPB_SCMailDetail} message PB_SCMailDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMailDetail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mailType != null && Object.hasOwnProperty.call(message, "mailType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mailType);
            if (message.mailIndex != null && Object.hasOwnProperty.call(message, "mailIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mailIndex);
            if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.subject);
            if (message.contenttxt != null && Object.hasOwnProperty.call(message, "contenttxt"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.contenttxt);
            if (message.itemData != null && message.itemData.length)
                for (var i = 0; i < message.itemData.length; ++i)
                    $root.PB_ItemData.encode(message.itemData[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCMailDetail message, length delimited. Does not implicitly {@link PB_SCMailDetail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCMailDetail
         * @static
         * @param {IPB_SCMailDetail} message PB_SCMailDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMailDetail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCMailDetail message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCMailDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCMailDetail} PB_SCMailDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMailDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCMailDetail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mailType = reader.int32();
                    break;
                case 2:
                    message.mailIndex = reader.int32();
                    break;
                case 3:
                    message.subject = reader.bytes();
                    break;
                case 4:
                    message.contenttxt = reader.bytes();
                    break;
                case 5:
                    if (!(message.itemData && message.itemData.length))
                        message.itemData = [];
                    message.itemData.push($root.PB_ItemData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCMailDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCMailDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCMailDetail} PB_SCMailDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMailDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCMailDetail message.
         * @function verify
         * @memberof PB_SCMailDetail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCMailDetail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mailType != null && message.hasOwnProperty("mailType"))
                if (!$util.isInteger(message.mailType))
                    return "mailType: integer expected";
            if (message.mailIndex != null && message.hasOwnProperty("mailIndex"))
                if (!$util.isInteger(message.mailIndex))
                    return "mailIndex: integer expected";
            if (message.subject != null && message.hasOwnProperty("subject"))
                if (!(message.subject && typeof message.subject.length === "number" || $util.isString(message.subject)))
                    return "subject: buffer expected";
            if (message.contenttxt != null && message.hasOwnProperty("contenttxt"))
                if (!(message.contenttxt && typeof message.contenttxt.length === "number" || $util.isString(message.contenttxt)))
                    return "contenttxt: buffer expected";
            if (message.itemData != null && message.hasOwnProperty("itemData")) {
                if (!Array.isArray(message.itemData))
                    return "itemData: array expected";
                for (var i = 0; i < message.itemData.length; ++i) {
                    var error = $root.PB_ItemData.verify(message.itemData[i]);
                    if (error)
                        return "itemData." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCMailDetail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCMailDetail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCMailDetail} PB_SCMailDetail
         */
        PB_SCMailDetail.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCMailDetail)
                return object;
            var message = new $root.PB_SCMailDetail();
            if (object.mailType != null)
                message.mailType = object.mailType | 0;
            if (object.mailIndex != null)
                message.mailIndex = object.mailIndex | 0;
            if (object.subject != null)
                if (typeof object.subject === "string")
                    $util.base64.decode(object.subject, message.subject = $util.newBuffer($util.base64.length(object.subject)), 0);
                else if (object.subject.length)
                    message.subject = object.subject;
            if (object.contenttxt != null)
                if (typeof object.contenttxt === "string")
                    $util.base64.decode(object.contenttxt, message.contenttxt = $util.newBuffer($util.base64.length(object.contenttxt)), 0);
                else if (object.contenttxt.length)
                    message.contenttxt = object.contenttxt;
            if (object.itemData) {
                if (!Array.isArray(object.itemData))
                    throw TypeError(".PB_SCMailDetail.itemData: array expected");
                message.itemData = [];
                for (var i = 0; i < object.itemData.length; ++i) {
                    if (typeof object.itemData[i] !== "object")
                        throw TypeError(".PB_SCMailDetail.itemData: object expected");
                    message.itemData[i] = $root.PB_ItemData.fromObject(object.itemData[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCMailDetail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCMailDetail
         * @static
         * @param {PB_SCMailDetail} message PB_SCMailDetail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCMailDetail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemData = [];
            if (options.defaults) {
                object.mailType = 0;
                object.mailIndex = 0;
                if (options.bytes === String)
                    object.subject = "";
                else {
                    object.subject = [];
                    if (options.bytes !== Array)
                        object.subject = $util.newBuffer(object.subject);
                }
                if (options.bytes === String)
                    object.contenttxt = "";
                else {
                    object.contenttxt = [];
                    if (options.bytes !== Array)
                        object.contenttxt = $util.newBuffer(object.contenttxt);
                }
            }
            if (message.mailType != null && message.hasOwnProperty("mailType"))
                object.mailType = message.mailType;
            if (message.mailIndex != null && message.hasOwnProperty("mailIndex"))
                object.mailIndex = message.mailIndex;
            if (message.subject != null && message.hasOwnProperty("subject"))
                object.subject = options.bytes === String ? $util.base64.encode(message.subject, 0, message.subject.length) : options.bytes === Array ? Array.prototype.slice.call(message.subject) : message.subject;
            if (message.contenttxt != null && message.hasOwnProperty("contenttxt"))
                object.contenttxt = options.bytes === String ? $util.base64.encode(message.contenttxt, 0, message.contenttxt.length) : options.bytes === Array ? Array.prototype.slice.call(message.contenttxt) : message.contenttxt;
            if (message.itemData && message.itemData.length) {
                object.itemData = [];
                for (var j = 0; j < message.itemData.length; ++j)
                    object.itemData[j] = $root.PB_ItemData.toObject(message.itemData[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCMailDetail to JSON.
         * @function toJSON
         * @memberof PB_SCMailDetail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCMailDetail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCMailDetail;
    })();
    
    $root.PB_SCFetchMailAck = (function() {
    
        /**
         * Properties of a PB_SCFetchMailAck.
         * @exports IPB_SCFetchMailAck
         * @interface IPB_SCFetchMailAck
         * @property {Array.<IPB_MailAckInfo>|null} [askInfo] PB_SCFetchMailAck askInfo
         */
    
        /**
         * Constructs a new PB_SCFetchMailAck.
         * @exports PB_SCFetchMailAck
         * @classdesc Represents a PB_SCFetchMailAck.
         * @implements IPB_SCFetchMailAck
         * @constructor
         * @param {IPB_SCFetchMailAck=} [properties] Properties to set
         */
        function PB_SCFetchMailAck(properties) {
            this.askInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCFetchMailAck askInfo.
         * @member {Array.<IPB_MailAckInfo>} askInfo
         * @memberof PB_SCFetchMailAck
         * @instance
         */
        PB_SCFetchMailAck.prototype.askInfo = $util.emptyArray;
    
        /**
         * Creates a new PB_SCFetchMailAck instance using the specified properties.
         * @function create
         * @memberof PB_SCFetchMailAck
         * @static
         * @param {IPB_SCFetchMailAck=} [properties] Properties to set
         * @returns {PB_SCFetchMailAck} PB_SCFetchMailAck instance
         */
        PB_SCFetchMailAck.create = function create(properties) {
            return new PB_SCFetchMailAck(properties);
        };
    
        /**
         * Encodes the specified PB_SCFetchMailAck message. Does not implicitly {@link PB_SCFetchMailAck.verify|verify} messages.
         * @function encode
         * @memberof PB_SCFetchMailAck
         * @static
         * @param {IPB_SCFetchMailAck} message PB_SCFetchMailAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCFetchMailAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.askInfo != null && message.askInfo.length)
                for (var i = 0; i < message.askInfo.length; ++i)
                    $root.PB_MailAckInfo.encode(message.askInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCFetchMailAck message, length delimited. Does not implicitly {@link PB_SCFetchMailAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCFetchMailAck
         * @static
         * @param {IPB_SCFetchMailAck} message PB_SCFetchMailAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCFetchMailAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCFetchMailAck message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCFetchMailAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCFetchMailAck} PB_SCFetchMailAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCFetchMailAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCFetchMailAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.askInfo && message.askInfo.length))
                        message.askInfo = [];
                    message.askInfo.push($root.PB_MailAckInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCFetchMailAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCFetchMailAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCFetchMailAck} PB_SCFetchMailAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCFetchMailAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCFetchMailAck message.
         * @function verify
         * @memberof PB_SCFetchMailAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCFetchMailAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.askInfo != null && message.hasOwnProperty("askInfo")) {
                if (!Array.isArray(message.askInfo))
                    return "askInfo: array expected";
                for (var i = 0; i < message.askInfo.length; ++i) {
                    var error = $root.PB_MailAckInfo.verify(message.askInfo[i]);
                    if (error)
                        return "askInfo." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCFetchMailAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCFetchMailAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCFetchMailAck} PB_SCFetchMailAck
         */
        PB_SCFetchMailAck.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCFetchMailAck)
                return object;
            var message = new $root.PB_SCFetchMailAck();
            if (object.askInfo) {
                if (!Array.isArray(object.askInfo))
                    throw TypeError(".PB_SCFetchMailAck.askInfo: array expected");
                message.askInfo = [];
                for (var i = 0; i < object.askInfo.length; ++i) {
                    if (typeof object.askInfo[i] !== "object")
                        throw TypeError(".PB_SCFetchMailAck.askInfo: object expected");
                    message.askInfo[i] = $root.PB_MailAckInfo.fromObject(object.askInfo[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCFetchMailAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCFetchMailAck
         * @static
         * @param {PB_SCFetchMailAck} message PB_SCFetchMailAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCFetchMailAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.askInfo = [];
            if (message.askInfo && message.askInfo.length) {
                object.askInfo = [];
                for (var j = 0; j < message.askInfo.length; ++j)
                    object.askInfo[j] = $root.PB_MailAckInfo.toObject(message.askInfo[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCFetchMailAck to JSON.
         * @function toJSON
         * @memberof PB_SCFetchMailAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCFetchMailAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCFetchMailAck;
    })();
    
    $root.PB_CSMailReq = (function() {
    
        /**
         * Properties of a PB_CSMailReq.
         * @exports IPB_CSMailReq
         * @interface IPB_CSMailReq
         * @property {number|null} [type] PB_CSMailReq type
         * @property {number|null} [p_1] PB_CSMailReq p_1
         * @property {number|null} [p_2] PB_CSMailReq p_2
         */
    
        /**
         * Constructs a new PB_CSMailReq.
         * @exports PB_CSMailReq
         * @classdesc Represents a PB_CSMailReq.
         * @implements IPB_CSMailReq
         * @constructor
         * @param {IPB_CSMailReq=} [properties] Properties to set
         */
        function PB_CSMailReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSMailReq type.
         * @member {number} type
         * @memberof PB_CSMailReq
         * @instance
         */
        PB_CSMailReq.prototype.type = 0;
    
        /**
         * PB_CSMailReq p_1.
         * @member {number} p_1
         * @memberof PB_CSMailReq
         * @instance
         */
        PB_CSMailReq.prototype.p_1 = 0;
    
        /**
         * PB_CSMailReq p_2.
         * @member {number} p_2
         * @memberof PB_CSMailReq
         * @instance
         */
        PB_CSMailReq.prototype.p_2 = 0;
    
        /**
         * Creates a new PB_CSMailReq instance using the specified properties.
         * @function create
         * @memberof PB_CSMailReq
         * @static
         * @param {IPB_CSMailReq=} [properties] Properties to set
         * @returns {PB_CSMailReq} PB_CSMailReq instance
         */
        PB_CSMailReq.create = function create(properties) {
            return new PB_CSMailReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSMailReq message. Does not implicitly {@link PB_CSMailReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSMailReq
         * @static
         * @param {IPB_CSMailReq} message PB_CSMailReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSMailReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.p_1 != null && Object.hasOwnProperty.call(message, "p_1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.p_1);
            if (message.p_2 != null && Object.hasOwnProperty.call(message, "p_2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.p_2);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSMailReq message, length delimited. Does not implicitly {@link PB_CSMailReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSMailReq
         * @static
         * @param {IPB_CSMailReq} message PB_CSMailReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSMailReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSMailReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSMailReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSMailReq} PB_CSMailReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSMailReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSMailReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.p_1 = reader.int32();
                    break;
                case 3:
                    message.p_2 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSMailReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSMailReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSMailReq} PB_CSMailReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSMailReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSMailReq message.
         * @function verify
         * @memberof PB_CSMailReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSMailReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.p_1 != null && message.hasOwnProperty("p_1"))
                if (!$util.isInteger(message.p_1))
                    return "p_1: integer expected";
            if (message.p_2 != null && message.hasOwnProperty("p_2"))
                if (!$util.isInteger(message.p_2))
                    return "p_2: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSMailReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSMailReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSMailReq} PB_CSMailReq
         */
        PB_CSMailReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSMailReq)
                return object;
            var message = new $root.PB_CSMailReq();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.p_1 != null)
                message.p_1 = object.p_1 | 0;
            if (object.p_2 != null)
                message.p_2 = object.p_2 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSMailReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSMailReq
         * @static
         * @param {PB_CSMailReq} message PB_CSMailReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSMailReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.p_1 = 0;
                object.p_2 = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.p_1 != null && message.hasOwnProperty("p_1"))
                object.p_1 = message.p_1;
            if (message.p_2 != null && message.hasOwnProperty("p_2"))
                object.p_2 = message.p_2;
            return object;
        };
    
        /**
         * Converts this PB_CSMailReq to JSON.
         * @function toJSON
         * @memberof PB_CSMailReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSMailReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSMailReq;
    })();
    
    $root.PB_SCMoneyBoxInfo = (function() {
    
        /**
         * Properties of a PB_SCMoneyBoxInfo.
         * @exports IPB_SCMoneyBoxInfo
         * @interface IPB_SCMoneyBoxInfo
         * @property {number|null} [seq] PB_SCMoneyBoxInfo seq
         * @property {number|null} [value] PB_SCMoneyBoxInfo value
         */
    
        /**
         * Constructs a new PB_SCMoneyBoxInfo.
         * @exports PB_SCMoneyBoxInfo
         * @classdesc Represents a PB_SCMoneyBoxInfo.
         * @implements IPB_SCMoneyBoxInfo
         * @constructor
         * @param {IPB_SCMoneyBoxInfo=} [properties] Properties to set
         */
        function PB_SCMoneyBoxInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCMoneyBoxInfo seq.
         * @member {number} seq
         * @memberof PB_SCMoneyBoxInfo
         * @instance
         */
        PB_SCMoneyBoxInfo.prototype.seq = 0;
    
        /**
         * PB_SCMoneyBoxInfo value.
         * @member {number} value
         * @memberof PB_SCMoneyBoxInfo
         * @instance
         */
        PB_SCMoneyBoxInfo.prototype.value = 0;
    
        /**
         * Creates a new PB_SCMoneyBoxInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCMoneyBoxInfo
         * @static
         * @param {IPB_SCMoneyBoxInfo=} [properties] Properties to set
         * @returns {PB_SCMoneyBoxInfo} PB_SCMoneyBoxInfo instance
         */
        PB_SCMoneyBoxInfo.create = function create(properties) {
            return new PB_SCMoneyBoxInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCMoneyBoxInfo message. Does not implicitly {@link PB_SCMoneyBoxInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCMoneyBoxInfo
         * @static
         * @param {IPB_SCMoneyBoxInfo} message PB_SCMoneyBoxInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMoneyBoxInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCMoneyBoxInfo message, length delimited. Does not implicitly {@link PB_SCMoneyBoxInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCMoneyBoxInfo
         * @static
         * @param {IPB_SCMoneyBoxInfo} message PB_SCMoneyBoxInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMoneyBoxInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCMoneyBoxInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCMoneyBoxInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCMoneyBoxInfo} PB_SCMoneyBoxInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMoneyBoxInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCMoneyBoxInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCMoneyBoxInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCMoneyBoxInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCMoneyBoxInfo} PB_SCMoneyBoxInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMoneyBoxInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCMoneyBoxInfo message.
         * @function verify
         * @memberof PB_SCMoneyBoxInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCMoneyBoxInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCMoneyBoxInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCMoneyBoxInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCMoneyBoxInfo} PB_SCMoneyBoxInfo
         */
        PB_SCMoneyBoxInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCMoneyBoxInfo)
                return object;
            var message = new $root.PB_SCMoneyBoxInfo();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.value != null)
                message.value = object.value | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCMoneyBoxInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCMoneyBoxInfo
         * @static
         * @param {PB_SCMoneyBoxInfo} message PB_SCMoneyBoxInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCMoneyBoxInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.seq = 0;
                object.value = 0;
            }
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };
    
        /**
         * Converts this PB_SCMoneyBoxInfo to JSON.
         * @function toJSON
         * @memberof PB_SCMoneyBoxInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCMoneyBoxInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCMoneyBoxInfo;
    })();
    
    $root.PB_CSNoticeTimeReq = (function() {
    
        /**
         * Properties of a PB_CSNoticeTimeReq.
         * @exports IPB_CSNoticeTimeReq
         * @interface IPB_CSNoticeTimeReq
         * @property {number|null} [type] PB_CSNoticeTimeReq type
         * @property {number|Long|null} [param] PB_CSNoticeTimeReq param
         */
    
        /**
         * Constructs a new PB_CSNoticeTimeReq.
         * @exports PB_CSNoticeTimeReq
         * @classdesc Represents a PB_CSNoticeTimeReq.
         * @implements IPB_CSNoticeTimeReq
         * @constructor
         * @param {IPB_CSNoticeTimeReq=} [properties] Properties to set
         */
        function PB_CSNoticeTimeReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSNoticeTimeReq type.
         * @member {number} type
         * @memberof PB_CSNoticeTimeReq
         * @instance
         */
        PB_CSNoticeTimeReq.prototype.type = 0;
    
        /**
         * PB_CSNoticeTimeReq param.
         * @member {number|Long} param
         * @memberof PB_CSNoticeTimeReq
         * @instance
         */
        PB_CSNoticeTimeReq.prototype.param = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_CSNoticeTimeReq instance using the specified properties.
         * @function create
         * @memberof PB_CSNoticeTimeReq
         * @static
         * @param {IPB_CSNoticeTimeReq=} [properties] Properties to set
         * @returns {PB_CSNoticeTimeReq} PB_CSNoticeTimeReq instance
         */
        PB_CSNoticeTimeReq.create = function create(properties) {
            return new PB_CSNoticeTimeReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSNoticeTimeReq message. Does not implicitly {@link PB_CSNoticeTimeReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSNoticeTimeReq
         * @static
         * @param {IPB_CSNoticeTimeReq} message PB_CSNoticeTimeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSNoticeTimeReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.param != null && Object.hasOwnProperty.call(message, "param"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.param);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSNoticeTimeReq message, length delimited. Does not implicitly {@link PB_CSNoticeTimeReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSNoticeTimeReq
         * @static
         * @param {IPB_CSNoticeTimeReq} message PB_CSNoticeTimeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSNoticeTimeReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSNoticeTimeReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSNoticeTimeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSNoticeTimeReq} PB_CSNoticeTimeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSNoticeTimeReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSNoticeTimeReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.param = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSNoticeTimeReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSNoticeTimeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSNoticeTimeReq} PB_CSNoticeTimeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSNoticeTimeReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSNoticeTimeReq message.
         * @function verify
         * @memberof PB_CSNoticeTimeReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSNoticeTimeReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.param != null && message.hasOwnProperty("param"))
                if (!$util.isInteger(message.param) && !(message.param && $util.isInteger(message.param.low) && $util.isInteger(message.param.high)))
                    return "param: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_CSNoticeTimeReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSNoticeTimeReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSNoticeTimeReq} PB_CSNoticeTimeReq
         */
        PB_CSNoticeTimeReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSNoticeTimeReq)
                return object;
            var message = new $root.PB_CSNoticeTimeReq();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.param != null)
                if ($util.Long)
                    (message.param = $util.Long.fromValue(object.param)).unsigned = false;
                else if (typeof object.param === "string")
                    message.param = parseInt(object.param, 10);
                else if (typeof object.param === "number")
                    message.param = object.param;
                else if (typeof object.param === "object")
                    message.param = new $util.LongBits(object.param.low >>> 0, object.param.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSNoticeTimeReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSNoticeTimeReq
         * @static
         * @param {PB_CSNoticeTimeReq} message PB_CSNoticeTimeReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSNoticeTimeReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.param = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.param = options.longs === String ? "0" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.param != null && message.hasOwnProperty("param"))
                if (typeof message.param === "number")
                    object.param = options.longs === String ? String(message.param) : message.param;
                else
                    object.param = options.longs === String ? $util.Long.prototype.toString.call(message.param) : options.longs === Number ? new $util.LongBits(message.param.low >>> 0, message.param.high >>> 0).toNumber() : message.param;
            return object;
        };
    
        /**
         * Converts this PB_CSNoticeTimeReq to JSON.
         * @function toJSON
         * @memberof PB_CSNoticeTimeReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSNoticeTimeReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSNoticeTimeReq;
    })();
    
    $root.PB_SCNoticeTimeRet = (function() {
    
        /**
         * Properties of a PB_SCNoticeTimeRet.
         * @exports IPB_SCNoticeTimeRet
         * @interface IPB_SCNoticeTimeRet
         * @property {number|Long|null} [noticeTime] PB_SCNoticeTimeRet noticeTime
         */
    
        /**
         * Constructs a new PB_SCNoticeTimeRet.
         * @exports PB_SCNoticeTimeRet
         * @classdesc Represents a PB_SCNoticeTimeRet.
         * @implements IPB_SCNoticeTimeRet
         * @constructor
         * @param {IPB_SCNoticeTimeRet=} [properties] Properties to set
         */
        function PB_SCNoticeTimeRet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCNoticeTimeRet noticeTime.
         * @member {number|Long} noticeTime
         * @memberof PB_SCNoticeTimeRet
         * @instance
         */
        PB_SCNoticeTimeRet.prototype.noticeTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCNoticeTimeRet instance using the specified properties.
         * @function create
         * @memberof PB_SCNoticeTimeRet
         * @static
         * @param {IPB_SCNoticeTimeRet=} [properties] Properties to set
         * @returns {PB_SCNoticeTimeRet} PB_SCNoticeTimeRet instance
         */
        PB_SCNoticeTimeRet.create = function create(properties) {
            return new PB_SCNoticeTimeRet(properties);
        };
    
        /**
         * Encodes the specified PB_SCNoticeTimeRet message. Does not implicitly {@link PB_SCNoticeTimeRet.verify|verify} messages.
         * @function encode
         * @memberof PB_SCNoticeTimeRet
         * @static
         * @param {IPB_SCNoticeTimeRet} message PB_SCNoticeTimeRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCNoticeTimeRet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.noticeTime != null && Object.hasOwnProperty.call(message, "noticeTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.noticeTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCNoticeTimeRet message, length delimited. Does not implicitly {@link PB_SCNoticeTimeRet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCNoticeTimeRet
         * @static
         * @param {IPB_SCNoticeTimeRet} message PB_SCNoticeTimeRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCNoticeTimeRet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCNoticeTimeRet message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCNoticeTimeRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCNoticeTimeRet} PB_SCNoticeTimeRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCNoticeTimeRet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCNoticeTimeRet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.noticeTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCNoticeTimeRet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCNoticeTimeRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCNoticeTimeRet} PB_SCNoticeTimeRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCNoticeTimeRet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCNoticeTimeRet message.
         * @function verify
         * @memberof PB_SCNoticeTimeRet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCNoticeTimeRet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.noticeTime != null && message.hasOwnProperty("noticeTime"))
                if (!$util.isInteger(message.noticeTime) && !(message.noticeTime && $util.isInteger(message.noticeTime.low) && $util.isInteger(message.noticeTime.high)))
                    return "noticeTime: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCNoticeTimeRet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCNoticeTimeRet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCNoticeTimeRet} PB_SCNoticeTimeRet
         */
        PB_SCNoticeTimeRet.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCNoticeTimeRet)
                return object;
            var message = new $root.PB_SCNoticeTimeRet();
            if (object.noticeTime != null)
                if ($util.Long)
                    (message.noticeTime = $util.Long.fromValue(object.noticeTime)).unsigned = false;
                else if (typeof object.noticeTime === "string")
                    message.noticeTime = parseInt(object.noticeTime, 10);
                else if (typeof object.noticeTime === "number")
                    message.noticeTime = object.noticeTime;
                else if (typeof object.noticeTime === "object")
                    message.noticeTime = new $util.LongBits(object.noticeTime.low >>> 0, object.noticeTime.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCNoticeTimeRet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCNoticeTimeRet
         * @static
         * @param {PB_SCNoticeTimeRet} message PB_SCNoticeTimeRet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCNoticeTimeRet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.noticeTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.noticeTime = options.longs === String ? "0" : 0;
            if (message.noticeTime != null && message.hasOwnProperty("noticeTime"))
                if (typeof message.noticeTime === "number")
                    object.noticeTime = options.longs === String ? String(message.noticeTime) : message.noticeTime;
                else
                    object.noticeTime = options.longs === String ? $util.Long.prototype.toString.call(message.noticeTime) : options.longs === Number ? new $util.LongBits(message.noticeTime.low >>> 0, message.noticeTime.high >>> 0).toNumber() : message.noticeTime;
            return object;
        };
    
        /**
         * Converts this PB_SCNoticeTimeRet to JSON.
         * @function toJSON
         * @memberof PB_SCNoticeTimeRet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCNoticeTimeRet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCNoticeTimeRet;
    })();
    
    $root.PB_SCCmdToClientCmd = (function() {
    
        /**
         * Properties of a PB_SCCmdToClientCmd.
         * @exports IPB_SCCmdToClientCmd
         * @interface IPB_SCCmdToClientCmd
         * @property {number|null} [id] PB_SCCmdToClientCmd id
         * @property {Uint8Array|null} [str] PB_SCCmdToClientCmd str
         */
    
        /**
         * Constructs a new PB_SCCmdToClientCmd.
         * @exports PB_SCCmdToClientCmd
         * @classdesc Represents a PB_SCCmdToClientCmd.
         * @implements IPB_SCCmdToClientCmd
         * @constructor
         * @param {IPB_SCCmdToClientCmd=} [properties] Properties to set
         */
        function PB_SCCmdToClientCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCCmdToClientCmd id.
         * @member {number} id
         * @memberof PB_SCCmdToClientCmd
         * @instance
         */
        PB_SCCmdToClientCmd.prototype.id = 0;
    
        /**
         * PB_SCCmdToClientCmd str.
         * @member {Uint8Array} str
         * @memberof PB_SCCmdToClientCmd
         * @instance
         */
        PB_SCCmdToClientCmd.prototype.str = $util.newBuffer([]);
    
        /**
         * Creates a new PB_SCCmdToClientCmd instance using the specified properties.
         * @function create
         * @memberof PB_SCCmdToClientCmd
         * @static
         * @param {IPB_SCCmdToClientCmd=} [properties] Properties to set
         * @returns {PB_SCCmdToClientCmd} PB_SCCmdToClientCmd instance
         */
        PB_SCCmdToClientCmd.create = function create(properties) {
            return new PB_SCCmdToClientCmd(properties);
        };
    
        /**
         * Encodes the specified PB_SCCmdToClientCmd message. Does not implicitly {@link PB_SCCmdToClientCmd.verify|verify} messages.
         * @function encode
         * @memberof PB_SCCmdToClientCmd
         * @static
         * @param {IPB_SCCmdToClientCmd} message PB_SCCmdToClientCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCCmdToClientCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.str != null && Object.hasOwnProperty.call(message, "str"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.str);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCCmdToClientCmd message, length delimited. Does not implicitly {@link PB_SCCmdToClientCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCCmdToClientCmd
         * @static
         * @param {IPB_SCCmdToClientCmd} message PB_SCCmdToClientCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCCmdToClientCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCCmdToClientCmd message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCCmdToClientCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCCmdToClientCmd} PB_SCCmdToClientCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCCmdToClientCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCCmdToClientCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int32();
                    break;
                case 2:
                    message.str = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCCmdToClientCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCCmdToClientCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCCmdToClientCmd} PB_SCCmdToClientCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCCmdToClientCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCCmdToClientCmd message.
         * @function verify
         * @memberof PB_SCCmdToClientCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCCmdToClientCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.str != null && message.hasOwnProperty("str"))
                if (!(message.str && typeof message.str.length === "number" || $util.isString(message.str)))
                    return "str: buffer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCCmdToClientCmd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCCmdToClientCmd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCCmdToClientCmd} PB_SCCmdToClientCmd
         */
        PB_SCCmdToClientCmd.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCCmdToClientCmd)
                return object;
            var message = new $root.PB_SCCmdToClientCmd();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.str != null)
                if (typeof object.str === "string")
                    $util.base64.decode(object.str, message.str = $util.newBuffer($util.base64.length(object.str)), 0);
                else if (object.str.length)
                    message.str = object.str;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCCmdToClientCmd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCCmdToClientCmd
         * @static
         * @param {PB_SCCmdToClientCmd} message PB_SCCmdToClientCmd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCCmdToClientCmd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                if (options.bytes === String)
                    object.str = "";
                else {
                    object.str = [];
                    if (options.bytes !== Array)
                        object.str = $util.newBuffer(object.str);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.str != null && message.hasOwnProperty("str"))
                object.str = options.bytes === String ? $util.base64.encode(message.str, 0, message.str.length) : options.bytes === Array ? Array.prototype.slice.call(message.str) : message.str;
            return object;
        };
    
        /**
         * Converts this PB_SCCmdToClientCmd to JSON.
         * @function toJSON
         * @memberof PB_SCCmdToClientCmd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCCmdToClientCmd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCCmdToClientCmd;
    })();
    
    $root.PB_DailyChallengeFetch = (function() {
    
        /**
         * Properties of a PB_DailyChallengeFetch.
         * @exports IPB_DailyChallengeFetch
         * @interface IPB_DailyChallengeFetch
         * @property {number|null} [missionIndex] PB_DailyChallengeFetch missionIndex
         */
    
        /**
         * Constructs a new PB_DailyChallengeFetch.
         * @exports PB_DailyChallengeFetch
         * @classdesc Represents a PB_DailyChallengeFetch.
         * @implements IPB_DailyChallengeFetch
         * @constructor
         * @param {IPB_DailyChallengeFetch=} [properties] Properties to set
         */
        function PB_DailyChallengeFetch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_DailyChallengeFetch missionIndex.
         * @member {number} missionIndex
         * @memberof PB_DailyChallengeFetch
         * @instance
         */
        PB_DailyChallengeFetch.prototype.missionIndex = 0;
    
        /**
         * Creates a new PB_DailyChallengeFetch instance using the specified properties.
         * @function create
         * @memberof PB_DailyChallengeFetch
         * @static
         * @param {IPB_DailyChallengeFetch=} [properties] Properties to set
         * @returns {PB_DailyChallengeFetch} PB_DailyChallengeFetch instance
         */
        PB_DailyChallengeFetch.create = function create(properties) {
            return new PB_DailyChallengeFetch(properties);
        };
    
        /**
         * Encodes the specified PB_DailyChallengeFetch message. Does not implicitly {@link PB_DailyChallengeFetch.verify|verify} messages.
         * @function encode
         * @memberof PB_DailyChallengeFetch
         * @static
         * @param {IPB_DailyChallengeFetch} message PB_DailyChallengeFetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyChallengeFetch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.missionIndex != null && Object.hasOwnProperty.call(message, "missionIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.missionIndex);
            return writer;
        };
    
        /**
         * Encodes the specified PB_DailyChallengeFetch message, length delimited. Does not implicitly {@link PB_DailyChallengeFetch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_DailyChallengeFetch
         * @static
         * @param {IPB_DailyChallengeFetch} message PB_DailyChallengeFetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyChallengeFetch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_DailyChallengeFetch message from the specified reader or buffer.
         * @function decode
         * @memberof PB_DailyChallengeFetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_DailyChallengeFetch} PB_DailyChallengeFetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyChallengeFetch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_DailyChallengeFetch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.missionIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_DailyChallengeFetch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_DailyChallengeFetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_DailyChallengeFetch} PB_DailyChallengeFetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyChallengeFetch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_DailyChallengeFetch message.
         * @function verify
         * @memberof PB_DailyChallengeFetch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_DailyChallengeFetch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.missionIndex != null && message.hasOwnProperty("missionIndex"))
                if (!$util.isInteger(message.missionIndex))
                    return "missionIndex: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_DailyChallengeFetch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_DailyChallengeFetch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_DailyChallengeFetch} PB_DailyChallengeFetch
         */
        PB_DailyChallengeFetch.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_DailyChallengeFetch)
                return object;
            var message = new $root.PB_DailyChallengeFetch();
            if (object.missionIndex != null)
                message.missionIndex = object.missionIndex | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_DailyChallengeFetch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_DailyChallengeFetch
         * @static
         * @param {PB_DailyChallengeFetch} message PB_DailyChallengeFetch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_DailyChallengeFetch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.missionIndex = 0;
            if (message.missionIndex != null && message.hasOwnProperty("missionIndex"))
                object.missionIndex = message.missionIndex;
            return object;
        };
    
        /**
         * Converts this PB_DailyChallengeFetch to JSON.
         * @function toJSON
         * @memberof PB_DailyChallengeFetch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_DailyChallengeFetch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_DailyChallengeFetch;
    })();
    
    $root.PB_DailyChallengeInfo = (function() {
    
        /**
         * Properties of a PB_DailyChallengeInfo.
         * @exports IPB_DailyChallengeInfo
         * @interface IPB_DailyChallengeInfo
         * @property {number|null} [bossSeq] PB_DailyChallengeInfo bossSeq
         * @property {number|null} [isPass] PB_DailyChallengeInfo isPass
         * @property {Array.<number>|null} [missionProgress] PB_DailyChallengeInfo missionProgress
         * @property {number|null} [fetchFlag] PB_DailyChallengeInfo fetchFlag
         * @property {number|null} [battleRound] PB_DailyChallengeInfo battleRound
         */
    
        /**
         * Constructs a new PB_DailyChallengeInfo.
         * @exports PB_DailyChallengeInfo
         * @classdesc Represents a PB_DailyChallengeInfo.
         * @implements IPB_DailyChallengeInfo
         * @constructor
         * @param {IPB_DailyChallengeInfo=} [properties] Properties to set
         */
        function PB_DailyChallengeInfo(properties) {
            this.missionProgress = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_DailyChallengeInfo bossSeq.
         * @member {number} bossSeq
         * @memberof PB_DailyChallengeInfo
         * @instance
         */
        PB_DailyChallengeInfo.prototype.bossSeq = 0;
    
        /**
         * PB_DailyChallengeInfo isPass.
         * @member {number} isPass
         * @memberof PB_DailyChallengeInfo
         * @instance
         */
        PB_DailyChallengeInfo.prototype.isPass = 0;
    
        /**
         * PB_DailyChallengeInfo missionProgress.
         * @member {Array.<number>} missionProgress
         * @memberof PB_DailyChallengeInfo
         * @instance
         */
        PB_DailyChallengeInfo.prototype.missionProgress = $util.emptyArray;
    
        /**
         * PB_DailyChallengeInfo fetchFlag.
         * @member {number} fetchFlag
         * @memberof PB_DailyChallengeInfo
         * @instance
         */
        PB_DailyChallengeInfo.prototype.fetchFlag = 0;
    
        /**
         * PB_DailyChallengeInfo battleRound.
         * @member {number} battleRound
         * @memberof PB_DailyChallengeInfo
         * @instance
         */
        PB_DailyChallengeInfo.prototype.battleRound = 0;
    
        /**
         * Creates a new PB_DailyChallengeInfo instance using the specified properties.
         * @function create
         * @memberof PB_DailyChallengeInfo
         * @static
         * @param {IPB_DailyChallengeInfo=} [properties] Properties to set
         * @returns {PB_DailyChallengeInfo} PB_DailyChallengeInfo instance
         */
        PB_DailyChallengeInfo.create = function create(properties) {
            return new PB_DailyChallengeInfo(properties);
        };
    
        /**
         * Encodes the specified PB_DailyChallengeInfo message. Does not implicitly {@link PB_DailyChallengeInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_DailyChallengeInfo
         * @static
         * @param {IPB_DailyChallengeInfo} message PB_DailyChallengeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyChallengeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bossSeq != null && Object.hasOwnProperty.call(message, "bossSeq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bossSeq);
            if (message.isPass != null && Object.hasOwnProperty.call(message, "isPass"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isPass);
            if (message.missionProgress != null && message.missionProgress.length)
                for (var i = 0; i < message.missionProgress.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.missionProgress[i]);
            if (message.fetchFlag != null && Object.hasOwnProperty.call(message, "fetchFlag"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.fetchFlag);
            if (message.battleRound != null && Object.hasOwnProperty.call(message, "battleRound"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.battleRound);
            return writer;
        };
    
        /**
         * Encodes the specified PB_DailyChallengeInfo message, length delimited. Does not implicitly {@link PB_DailyChallengeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_DailyChallengeInfo
         * @static
         * @param {IPB_DailyChallengeInfo} message PB_DailyChallengeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyChallengeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_DailyChallengeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_DailyChallengeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_DailyChallengeInfo} PB_DailyChallengeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyChallengeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_DailyChallengeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bossSeq = reader.int32();
                    break;
                case 2:
                    message.isPass = reader.int32();
                    break;
                case 3:
                    if (!(message.missionProgress && message.missionProgress.length))
                        message.missionProgress = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.missionProgress.push(reader.int32());
                    } else
                        message.missionProgress.push(reader.int32());
                    break;
                case 4:
                    message.fetchFlag = reader.int32();
                    break;
                case 5:
                    message.battleRound = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_DailyChallengeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_DailyChallengeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_DailyChallengeInfo} PB_DailyChallengeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyChallengeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_DailyChallengeInfo message.
         * @function verify
         * @memberof PB_DailyChallengeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_DailyChallengeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bossSeq != null && message.hasOwnProperty("bossSeq"))
                if (!$util.isInteger(message.bossSeq))
                    return "bossSeq: integer expected";
            if (message.isPass != null && message.hasOwnProperty("isPass"))
                if (!$util.isInteger(message.isPass))
                    return "isPass: integer expected";
            if (message.missionProgress != null && message.hasOwnProperty("missionProgress")) {
                if (!Array.isArray(message.missionProgress))
                    return "missionProgress: array expected";
                for (var i = 0; i < message.missionProgress.length; ++i)
                    if (!$util.isInteger(message.missionProgress[i]))
                        return "missionProgress: integer[] expected";
            }
            if (message.fetchFlag != null && message.hasOwnProperty("fetchFlag"))
                if (!$util.isInteger(message.fetchFlag))
                    return "fetchFlag: integer expected";
            if (message.battleRound != null && message.hasOwnProperty("battleRound"))
                if (!$util.isInteger(message.battleRound))
                    return "battleRound: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_DailyChallengeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_DailyChallengeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_DailyChallengeInfo} PB_DailyChallengeInfo
         */
        PB_DailyChallengeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_DailyChallengeInfo)
                return object;
            var message = new $root.PB_DailyChallengeInfo();
            if (object.bossSeq != null)
                message.bossSeq = object.bossSeq | 0;
            if (object.isPass != null)
                message.isPass = object.isPass | 0;
            if (object.missionProgress) {
                if (!Array.isArray(object.missionProgress))
                    throw TypeError(".PB_DailyChallengeInfo.missionProgress: array expected");
                message.missionProgress = [];
                for (var i = 0; i < object.missionProgress.length; ++i)
                    message.missionProgress[i] = object.missionProgress[i] | 0;
            }
            if (object.fetchFlag != null)
                message.fetchFlag = object.fetchFlag | 0;
            if (object.battleRound != null)
                message.battleRound = object.battleRound | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_DailyChallengeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_DailyChallengeInfo
         * @static
         * @param {PB_DailyChallengeInfo} message PB_DailyChallengeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_DailyChallengeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.missionProgress = [];
            if (options.defaults) {
                object.bossSeq = 0;
                object.isPass = 0;
                object.fetchFlag = 0;
                object.battleRound = 0;
            }
            if (message.bossSeq != null && message.hasOwnProperty("bossSeq"))
                object.bossSeq = message.bossSeq;
            if (message.isPass != null && message.hasOwnProperty("isPass"))
                object.isPass = message.isPass;
            if (message.missionProgress && message.missionProgress.length) {
                object.missionProgress = [];
                for (var j = 0; j < message.missionProgress.length; ++j)
                    object.missionProgress[j] = message.missionProgress[j];
            }
            if (message.fetchFlag != null && message.hasOwnProperty("fetchFlag"))
                object.fetchFlag = message.fetchFlag;
            if (message.battleRound != null && message.hasOwnProperty("battleRound"))
                object.battleRound = message.battleRound;
            return object;
        };
    
        /**
         * Converts this PB_DailyChallengeInfo to JSON.
         * @function toJSON
         * @memberof PB_DailyChallengeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_DailyChallengeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_DailyChallengeInfo;
    })();
    
    $root.PB_MainFBOper = (function() {
    
        /**
         * Properties of a PB_MainFBOper.
         * @exports IPB_MainFBOper
         * @interface IPB_MainFBOper
         * @property {number|null} [operType] PB_MainFBOper operType
         * @property {Array.<number>|null} [operParam] PB_MainFBOper operParam
         */
    
        /**
         * Constructs a new PB_MainFBOper.
         * @exports PB_MainFBOper
         * @classdesc Represents a PB_MainFBOper.
         * @implements IPB_MainFBOper
         * @constructor
         * @param {IPB_MainFBOper=} [properties] Properties to set
         */
        function PB_MainFBOper(properties) {
            this.operParam = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MainFBOper operType.
         * @member {number} operType
         * @memberof PB_MainFBOper
         * @instance
         */
        PB_MainFBOper.prototype.operType = 0;
    
        /**
         * PB_MainFBOper operParam.
         * @member {Array.<number>} operParam
         * @memberof PB_MainFBOper
         * @instance
         */
        PB_MainFBOper.prototype.operParam = $util.emptyArray;
    
        /**
         * Creates a new PB_MainFBOper instance using the specified properties.
         * @function create
         * @memberof PB_MainFBOper
         * @static
         * @param {IPB_MainFBOper=} [properties] Properties to set
         * @returns {PB_MainFBOper} PB_MainFBOper instance
         */
        PB_MainFBOper.create = function create(properties) {
            return new PB_MainFBOper(properties);
        };
    
        /**
         * Encodes the specified PB_MainFBOper message. Does not implicitly {@link PB_MainFBOper.verify|verify} messages.
         * @function encode
         * @memberof PB_MainFBOper
         * @static
         * @param {IPB_MainFBOper} message PB_MainFBOper message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBOper.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.operType != null && Object.hasOwnProperty.call(message, "operType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operType);
            if (message.operParam != null && message.operParam.length)
                for (var i = 0; i < message.operParam.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.operParam[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_MainFBOper message, length delimited. Does not implicitly {@link PB_MainFBOper.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MainFBOper
         * @static
         * @param {IPB_MainFBOper} message PB_MainFBOper message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBOper.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MainFBOper message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MainFBOper
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MainFBOper} PB_MainFBOper
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBOper.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MainFBOper();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.operType = reader.int32();
                    break;
                case 2:
                    if (!(message.operParam && message.operParam.length))
                        message.operParam = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.operParam.push(reader.int32());
                    } else
                        message.operParam.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MainFBOper message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MainFBOper
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MainFBOper} PB_MainFBOper
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBOper.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MainFBOper message.
         * @function verify
         * @memberof PB_MainFBOper
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MainFBOper.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.operType != null && message.hasOwnProperty("operType"))
                if (!$util.isInteger(message.operType))
                    return "operType: integer expected";
            if (message.operParam != null && message.hasOwnProperty("operParam")) {
                if (!Array.isArray(message.operParam))
                    return "operParam: array expected";
                for (var i = 0; i < message.operParam.length; ++i)
                    if (!$util.isInteger(message.operParam[i]))
                        return "operParam: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_MainFBOper message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MainFBOper
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MainFBOper} PB_MainFBOper
         */
        PB_MainFBOper.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MainFBOper)
                return object;
            var message = new $root.PB_MainFBOper();
            if (object.operType != null)
                message.operType = object.operType | 0;
            if (object.operParam) {
                if (!Array.isArray(object.operParam))
                    throw TypeError(".PB_MainFBOper.operParam: array expected");
                message.operParam = [];
                for (var i = 0; i < object.operParam.length; ++i)
                    message.operParam[i] = object.operParam[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MainFBOper message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MainFBOper
         * @static
         * @param {PB_MainFBOper} message PB_MainFBOper
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MainFBOper.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.operParam = [];
            if (options.defaults)
                object.operType = 0;
            if (message.operType != null && message.hasOwnProperty("operType"))
                object.operType = message.operType;
            if (message.operParam && message.operParam.length) {
                object.operParam = [];
                for (var j = 0; j < message.operParam.length; ++j)
                    object.operParam[j] = message.operParam[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_MainFBOper to JSON.
         * @function toJSON
         * @memberof PB_MainFBOper
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MainFBOper.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MainFBOper;
    })();
    
    $root.PB_MainFBNode = (function() {
    
        /**
         * Properties of a PB_MainFBNode.
         * @exports IPB_MainFBNode
         * @interface IPB_MainFBNode
         * @property {number|null} [level] PB_MainFBNode level
         * @property {number|null} [round] PB_MainFBNode round
         * @property {Array.<boolean>|null} [rewardFlag] PB_MainFBNode rewardFlag
         */
    
        /**
         * Constructs a new PB_MainFBNode.
         * @exports PB_MainFBNode
         * @classdesc Represents a PB_MainFBNode.
         * @implements IPB_MainFBNode
         * @constructor
         * @param {IPB_MainFBNode=} [properties] Properties to set
         */
        function PB_MainFBNode(properties) {
            this.rewardFlag = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MainFBNode level.
         * @member {number} level
         * @memberof PB_MainFBNode
         * @instance
         */
        PB_MainFBNode.prototype.level = 0;
    
        /**
         * PB_MainFBNode round.
         * @member {number} round
         * @memberof PB_MainFBNode
         * @instance
         */
        PB_MainFBNode.prototype.round = 0;
    
        /**
         * PB_MainFBNode rewardFlag.
         * @member {Array.<boolean>} rewardFlag
         * @memberof PB_MainFBNode
         * @instance
         */
        PB_MainFBNode.prototype.rewardFlag = $util.emptyArray;
    
        /**
         * Creates a new PB_MainFBNode instance using the specified properties.
         * @function create
         * @memberof PB_MainFBNode
         * @static
         * @param {IPB_MainFBNode=} [properties] Properties to set
         * @returns {PB_MainFBNode} PB_MainFBNode instance
         */
        PB_MainFBNode.create = function create(properties) {
            return new PB_MainFBNode(properties);
        };
    
        /**
         * Encodes the specified PB_MainFBNode message. Does not implicitly {@link PB_MainFBNode.verify|verify} messages.
         * @function encode
         * @memberof PB_MainFBNode
         * @static
         * @param {IPB_MainFBNode} message PB_MainFBNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
            if (message.round != null && Object.hasOwnProperty.call(message, "round"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.round);
            if (message.rewardFlag != null && message.rewardFlag.length)
                for (var i = 0; i < message.rewardFlag.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.rewardFlag[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_MainFBNode message, length delimited. Does not implicitly {@link PB_MainFBNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MainFBNode
         * @static
         * @param {IPB_MainFBNode} message PB_MainFBNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MainFBNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MainFBNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MainFBNode} PB_MainFBNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MainFBNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.level = reader.int32();
                    break;
                case 2:
                    message.round = reader.int32();
                    break;
                case 3:
                    if (!(message.rewardFlag && message.rewardFlag.length))
                        message.rewardFlag = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rewardFlag.push(reader.bool());
                    } else
                        message.rewardFlag.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MainFBNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MainFBNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MainFBNode} PB_MainFBNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MainFBNode message.
         * @function verify
         * @memberof PB_MainFBNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MainFBNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.round != null && message.hasOwnProperty("round"))
                if (!$util.isInteger(message.round))
                    return "round: integer expected";
            if (message.rewardFlag != null && message.hasOwnProperty("rewardFlag")) {
                if (!Array.isArray(message.rewardFlag))
                    return "rewardFlag: array expected";
                for (var i = 0; i < message.rewardFlag.length; ++i)
                    if (typeof message.rewardFlag[i] !== "boolean")
                        return "rewardFlag: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_MainFBNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MainFBNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MainFBNode} PB_MainFBNode
         */
        PB_MainFBNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MainFBNode)
                return object;
            var message = new $root.PB_MainFBNode();
            if (object.level != null)
                message.level = object.level | 0;
            if (object.round != null)
                message.round = object.round | 0;
            if (object.rewardFlag) {
                if (!Array.isArray(object.rewardFlag))
                    throw TypeError(".PB_MainFBNode.rewardFlag: array expected");
                message.rewardFlag = [];
                for (var i = 0; i < object.rewardFlag.length; ++i)
                    message.rewardFlag[i] = Boolean(object.rewardFlag[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MainFBNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MainFBNode
         * @static
         * @param {PB_MainFBNode} message PB_MainFBNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MainFBNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rewardFlag = [];
            if (options.defaults) {
                object.level = 0;
                object.round = 0;
            }
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.round != null && message.hasOwnProperty("round"))
                object.round = message.round;
            if (message.rewardFlag && message.rewardFlag.length) {
                object.rewardFlag = [];
                for (var j = 0; j < message.rewardFlag.length; ++j)
                    object.rewardFlag[j] = message.rewardFlag[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_MainFBNode to JSON.
         * @function toJSON
         * @memberof PB_MainFBNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MainFBNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MainFBNode;
    })();
    
    $root.PB_MainFBInfo = (function() {
    
        /**
         * Properties of a PB_MainFBInfo.
         * @exports IPB_MainFBInfo
         * @interface IPB_MainFBInfo
         * @property {number|null} [energyBuyCount] PB_MainFBInfo energyBuyCount
         * @property {Array.<IPB_MainFBNode>|null} [fbList] PB_MainFBInfo fbList
         * @property {boolean|null} [adReward] PB_MainFBInfo adReward
         */
    
        /**
         * Constructs a new PB_MainFBInfo.
         * @exports PB_MainFBInfo
         * @classdesc Represents a PB_MainFBInfo.
         * @implements IPB_MainFBInfo
         * @constructor
         * @param {IPB_MainFBInfo=} [properties] Properties to set
         */
        function PB_MainFBInfo(properties) {
            this.fbList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MainFBInfo energyBuyCount.
         * @member {number} energyBuyCount
         * @memberof PB_MainFBInfo
         * @instance
         */
        PB_MainFBInfo.prototype.energyBuyCount = 0;
    
        /**
         * PB_MainFBInfo fbList.
         * @member {Array.<IPB_MainFBNode>} fbList
         * @memberof PB_MainFBInfo
         * @instance
         */
        PB_MainFBInfo.prototype.fbList = $util.emptyArray;
    
        /**
         * PB_MainFBInfo adReward.
         * @member {boolean} adReward
         * @memberof PB_MainFBInfo
         * @instance
         */
        PB_MainFBInfo.prototype.adReward = false;
    
        /**
         * Creates a new PB_MainFBInfo instance using the specified properties.
         * @function create
         * @memberof PB_MainFBInfo
         * @static
         * @param {IPB_MainFBInfo=} [properties] Properties to set
         * @returns {PB_MainFBInfo} PB_MainFBInfo instance
         */
        PB_MainFBInfo.create = function create(properties) {
            return new PB_MainFBInfo(properties);
        };
    
        /**
         * Encodes the specified PB_MainFBInfo message. Does not implicitly {@link PB_MainFBInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_MainFBInfo
         * @static
         * @param {IPB_MainFBInfo} message PB_MainFBInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.energyBuyCount != null && Object.hasOwnProperty.call(message, "energyBuyCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.energyBuyCount);
            if (message.fbList != null && message.fbList.length)
                for (var i = 0; i < message.fbList.length; ++i)
                    $root.PB_MainFBNode.encode(message.fbList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.adReward != null && Object.hasOwnProperty.call(message, "adReward"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.adReward);
            return writer;
        };
    
        /**
         * Encodes the specified PB_MainFBInfo message, length delimited. Does not implicitly {@link PB_MainFBInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MainFBInfo
         * @static
         * @param {IPB_MainFBInfo} message PB_MainFBInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MainFBInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MainFBInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MainFBInfo} PB_MainFBInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MainFBInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.energyBuyCount = reader.int32();
                    break;
                case 2:
                    if (!(message.fbList && message.fbList.length))
                        message.fbList = [];
                    message.fbList.push($root.PB_MainFBNode.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.adReward = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MainFBInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MainFBInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MainFBInfo} PB_MainFBInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MainFBInfo message.
         * @function verify
         * @memberof PB_MainFBInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MainFBInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.energyBuyCount != null && message.hasOwnProperty("energyBuyCount"))
                if (!$util.isInteger(message.energyBuyCount))
                    return "energyBuyCount: integer expected";
            if (message.fbList != null && message.hasOwnProperty("fbList")) {
                if (!Array.isArray(message.fbList))
                    return "fbList: array expected";
                for (var i = 0; i < message.fbList.length; ++i) {
                    var error = $root.PB_MainFBNode.verify(message.fbList[i]);
                    if (error)
                        return "fbList." + error;
                }
            }
            if (message.adReward != null && message.hasOwnProperty("adReward"))
                if (typeof message.adReward !== "boolean")
                    return "adReward: boolean expected";
            return null;
        };
    
        /**
         * Creates a PB_MainFBInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MainFBInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MainFBInfo} PB_MainFBInfo
         */
        PB_MainFBInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MainFBInfo)
                return object;
            var message = new $root.PB_MainFBInfo();
            if (object.energyBuyCount != null)
                message.energyBuyCount = object.energyBuyCount | 0;
            if (object.fbList) {
                if (!Array.isArray(object.fbList))
                    throw TypeError(".PB_MainFBInfo.fbList: array expected");
                message.fbList = [];
                for (var i = 0; i < object.fbList.length; ++i) {
                    if (typeof object.fbList[i] !== "object")
                        throw TypeError(".PB_MainFBInfo.fbList: object expected");
                    message.fbList[i] = $root.PB_MainFBNode.fromObject(object.fbList[i]);
                }
            }
            if (object.adReward != null)
                message.adReward = Boolean(object.adReward);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MainFBInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MainFBInfo
         * @static
         * @param {PB_MainFBInfo} message PB_MainFBInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MainFBInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fbList = [];
            if (options.defaults) {
                object.energyBuyCount = 0;
                object.adReward = false;
            }
            if (message.energyBuyCount != null && message.hasOwnProperty("energyBuyCount"))
                object.energyBuyCount = message.energyBuyCount;
            if (message.fbList && message.fbList.length) {
                object.fbList = [];
                for (var j = 0; j < message.fbList.length; ++j)
                    object.fbList[j] = $root.PB_MainFBNode.toObject(message.fbList[j], options);
            }
            if (message.adReward != null && message.hasOwnProperty("adReward"))
                object.adReward = message.adReward;
            return object;
        };
    
        /**
         * Converts this PB_MainFBInfo to JSON.
         * @function toJSON
         * @memberof PB_MainFBInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MainFBInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MainFBInfo;
    })();
    
    $root.PB_MainFBRewardInfo = (function() {
    
        /**
         * Properties of a PB_MainFBRewardInfo.
         * @exports IPB_MainFBRewardInfo
         * @interface IPB_MainFBRewardInfo
         * @property {Array.<number>|null} [itemId] PB_MainFBRewardInfo itemId
         * @property {Array.<number>|null} [itemNum] PB_MainFBRewardInfo itemNum
         * @property {number|null} [rewardType] PB_MainFBRewardInfo rewardType
         * @property {number|null} [rewardTime] PB_MainFBRewardInfo rewardTime
         * @property {number|null} [todayBuyCount] PB_MainFBRewardInfo todayBuyCount
         */
    
        /**
         * Constructs a new PB_MainFBRewardInfo.
         * @exports PB_MainFBRewardInfo
         * @classdesc Represents a PB_MainFBRewardInfo.
         * @implements IPB_MainFBRewardInfo
         * @constructor
         * @param {IPB_MainFBRewardInfo=} [properties] Properties to set
         */
        function PB_MainFBRewardInfo(properties) {
            this.itemId = [];
            this.itemNum = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MainFBRewardInfo itemId.
         * @member {Array.<number>} itemId
         * @memberof PB_MainFBRewardInfo
         * @instance
         */
        PB_MainFBRewardInfo.prototype.itemId = $util.emptyArray;
    
        /**
         * PB_MainFBRewardInfo itemNum.
         * @member {Array.<number>} itemNum
         * @memberof PB_MainFBRewardInfo
         * @instance
         */
        PB_MainFBRewardInfo.prototype.itemNum = $util.emptyArray;
    
        /**
         * PB_MainFBRewardInfo rewardType.
         * @member {number} rewardType
         * @memberof PB_MainFBRewardInfo
         * @instance
         */
        PB_MainFBRewardInfo.prototype.rewardType = 0;
    
        /**
         * PB_MainFBRewardInfo rewardTime.
         * @member {number} rewardTime
         * @memberof PB_MainFBRewardInfo
         * @instance
         */
        PB_MainFBRewardInfo.prototype.rewardTime = 0;
    
        /**
         * PB_MainFBRewardInfo todayBuyCount.
         * @member {number} todayBuyCount
         * @memberof PB_MainFBRewardInfo
         * @instance
         */
        PB_MainFBRewardInfo.prototype.todayBuyCount = 0;
    
        /**
         * Creates a new PB_MainFBRewardInfo instance using the specified properties.
         * @function create
         * @memberof PB_MainFBRewardInfo
         * @static
         * @param {IPB_MainFBRewardInfo=} [properties] Properties to set
         * @returns {PB_MainFBRewardInfo} PB_MainFBRewardInfo instance
         */
        PB_MainFBRewardInfo.create = function create(properties) {
            return new PB_MainFBRewardInfo(properties);
        };
    
        /**
         * Encodes the specified PB_MainFBRewardInfo message. Does not implicitly {@link PB_MainFBRewardInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_MainFBRewardInfo
         * @static
         * @param {IPB_MainFBRewardInfo} message PB_MainFBRewardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBRewardInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && message.itemId.length)
                for (var i = 0; i < message.itemId.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId[i]);
            if (message.itemNum != null && message.itemNum.length)
                for (var i = 0; i < message.itemNum.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemNum[i]);
            if (message.rewardType != null && Object.hasOwnProperty.call(message, "rewardType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rewardType);
            if (message.rewardTime != null && Object.hasOwnProperty.call(message, "rewardTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rewardTime);
            if (message.todayBuyCount != null && Object.hasOwnProperty.call(message, "todayBuyCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.todayBuyCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_MainFBRewardInfo message, length delimited. Does not implicitly {@link PB_MainFBRewardInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MainFBRewardInfo
         * @static
         * @param {IPB_MainFBRewardInfo} message PB_MainFBRewardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBRewardInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MainFBRewardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MainFBRewardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MainFBRewardInfo} PB_MainFBRewardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBRewardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MainFBRewardInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.itemId && message.itemId.length))
                        message.itemId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemId.push(reader.int32());
                    } else
                        message.itemId.push(reader.int32());
                    break;
                case 2:
                    if (!(message.itemNum && message.itemNum.length))
                        message.itemNum = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemNum.push(reader.int32());
                    } else
                        message.itemNum.push(reader.int32());
                    break;
                case 3:
                    message.rewardType = reader.int32();
                    break;
                case 4:
                    message.rewardTime = reader.int32();
                    break;
                case 5:
                    message.todayBuyCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MainFBRewardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MainFBRewardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MainFBRewardInfo} PB_MainFBRewardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBRewardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MainFBRewardInfo message.
         * @function verify
         * @memberof PB_MainFBRewardInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MainFBRewardInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId")) {
                if (!Array.isArray(message.itemId))
                    return "itemId: array expected";
                for (var i = 0; i < message.itemId.length; ++i)
                    if (!$util.isInteger(message.itemId[i]))
                        return "itemId: integer[] expected";
            }
            if (message.itemNum != null && message.hasOwnProperty("itemNum")) {
                if (!Array.isArray(message.itemNum))
                    return "itemNum: array expected";
                for (var i = 0; i < message.itemNum.length; ++i)
                    if (!$util.isInteger(message.itemNum[i]))
                        return "itemNum: integer[] expected";
            }
            if (message.rewardType != null && message.hasOwnProperty("rewardType"))
                if (!$util.isInteger(message.rewardType))
                    return "rewardType: integer expected";
            if (message.rewardTime != null && message.hasOwnProperty("rewardTime"))
                if (!$util.isInteger(message.rewardTime))
                    return "rewardTime: integer expected";
            if (message.todayBuyCount != null && message.hasOwnProperty("todayBuyCount"))
                if (!$util.isInteger(message.todayBuyCount))
                    return "todayBuyCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_MainFBRewardInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MainFBRewardInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MainFBRewardInfo} PB_MainFBRewardInfo
         */
        PB_MainFBRewardInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MainFBRewardInfo)
                return object;
            var message = new $root.PB_MainFBRewardInfo();
            if (object.itemId) {
                if (!Array.isArray(object.itemId))
                    throw TypeError(".PB_MainFBRewardInfo.itemId: array expected");
                message.itemId = [];
                for (var i = 0; i < object.itemId.length; ++i)
                    message.itemId[i] = object.itemId[i] | 0;
            }
            if (object.itemNum) {
                if (!Array.isArray(object.itemNum))
                    throw TypeError(".PB_MainFBRewardInfo.itemNum: array expected");
                message.itemNum = [];
                for (var i = 0; i < object.itemNum.length; ++i)
                    message.itemNum[i] = object.itemNum[i] | 0;
            }
            if (object.rewardType != null)
                message.rewardType = object.rewardType | 0;
            if (object.rewardTime != null)
                message.rewardTime = object.rewardTime | 0;
            if (object.todayBuyCount != null)
                message.todayBuyCount = object.todayBuyCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MainFBRewardInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MainFBRewardInfo
         * @static
         * @param {PB_MainFBRewardInfo} message PB_MainFBRewardInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MainFBRewardInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.itemId = [];
                object.itemNum = [];
            }
            if (options.defaults) {
                object.rewardType = 0;
                object.rewardTime = 0;
                object.todayBuyCount = 0;
            }
            if (message.itemId && message.itemId.length) {
                object.itemId = [];
                for (var j = 0; j < message.itemId.length; ++j)
                    object.itemId[j] = message.itemId[j];
            }
            if (message.itemNum && message.itemNum.length) {
                object.itemNum = [];
                for (var j = 0; j < message.itemNum.length; ++j)
                    object.itemNum[j] = message.itemNum[j];
            }
            if (message.rewardType != null && message.hasOwnProperty("rewardType"))
                object.rewardType = message.rewardType;
            if (message.rewardTime != null && message.hasOwnProperty("rewardTime"))
                object.rewardTime = message.rewardTime;
            if (message.todayBuyCount != null && message.hasOwnProperty("todayBuyCount"))
                object.todayBuyCount = message.todayBuyCount;
            return object;
        };
    
        /**
         * Converts this PB_MainFBRewardInfo to JSON.
         * @function toJSON
         * @memberof PB_MainFBRewardInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MainFBRewardInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MainFBRewardInfo;
    })();
    
    $root.PB_MainFBPassNode = (function() {
    
        /**
         * Properties of a PB_MainFBPassNode.
         * @exports IPB_MainFBPassNode
         * @interface IPB_MainFBPassNode
         * @property {IPB_RoleInfo|null} [roleInfo] PB_MainFBPassNode roleInfo
         * @property {number|null} [time] PB_MainFBPassNode time
         * @property {Array.<number>|null} [heroId] PB_MainFBPassNode heroId
         * @property {Array.<number>|null} [heroLevel] PB_MainFBPassNode heroLevel
         */
    
        /**
         * Constructs a new PB_MainFBPassNode.
         * @exports PB_MainFBPassNode
         * @classdesc Represents a PB_MainFBPassNode.
         * @implements IPB_MainFBPassNode
         * @constructor
         * @param {IPB_MainFBPassNode=} [properties] Properties to set
         */
        function PB_MainFBPassNode(properties) {
            this.heroId = [];
            this.heroLevel = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MainFBPassNode roleInfo.
         * @member {IPB_RoleInfo|null|undefined} roleInfo
         * @memberof PB_MainFBPassNode
         * @instance
         */
        PB_MainFBPassNode.prototype.roleInfo = null;
    
        /**
         * PB_MainFBPassNode time.
         * @member {number} time
         * @memberof PB_MainFBPassNode
         * @instance
         */
        PB_MainFBPassNode.prototype.time = 0;
    
        /**
         * PB_MainFBPassNode heroId.
         * @member {Array.<number>} heroId
         * @memberof PB_MainFBPassNode
         * @instance
         */
        PB_MainFBPassNode.prototype.heroId = $util.emptyArray;
    
        /**
         * PB_MainFBPassNode heroLevel.
         * @member {Array.<number>} heroLevel
         * @memberof PB_MainFBPassNode
         * @instance
         */
        PB_MainFBPassNode.prototype.heroLevel = $util.emptyArray;
    
        /**
         * Creates a new PB_MainFBPassNode instance using the specified properties.
         * @function create
         * @memberof PB_MainFBPassNode
         * @static
         * @param {IPB_MainFBPassNode=} [properties] Properties to set
         * @returns {PB_MainFBPassNode} PB_MainFBPassNode instance
         */
        PB_MainFBPassNode.create = function create(properties) {
            return new PB_MainFBPassNode(properties);
        };
    
        /**
         * Encodes the specified PB_MainFBPassNode message. Does not implicitly {@link PB_MainFBPassNode.verify|verify} messages.
         * @function encode
         * @memberof PB_MainFBPassNode
         * @static
         * @param {IPB_MainFBPassNode} message PB_MainFBPassNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBPassNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleInfo != null && Object.hasOwnProperty.call(message, "roleInfo"))
                $root.PB_RoleInfo.encode(message.roleInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.time);
            if (message.heroId != null && message.heroId.length)
                for (var i = 0; i < message.heroId.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.heroId[i]);
            if (message.heroLevel != null && message.heroLevel.length)
                for (var i = 0; i < message.heroLevel.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.heroLevel[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_MainFBPassNode message, length delimited. Does not implicitly {@link PB_MainFBPassNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MainFBPassNode
         * @static
         * @param {IPB_MainFBPassNode} message PB_MainFBPassNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBPassNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MainFBPassNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MainFBPassNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MainFBPassNode} PB_MainFBPassNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBPassNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MainFBPassNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.time = reader.uint32();
                    break;
                case 3:
                    if (!(message.heroId && message.heroId.length))
                        message.heroId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.heroId.push(reader.int32());
                    } else
                        message.heroId.push(reader.int32());
                    break;
                case 4:
                    if (!(message.heroLevel && message.heroLevel.length))
                        message.heroLevel = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.heroLevel.push(reader.int32());
                    } else
                        message.heroLevel.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MainFBPassNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MainFBPassNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MainFBPassNode} PB_MainFBPassNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBPassNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MainFBPassNode message.
         * @function verify
         * @memberof PB_MainFBPassNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MainFBPassNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleInfo);
                if (error)
                    return "roleInfo." + error;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.heroId != null && message.hasOwnProperty("heroId")) {
                if (!Array.isArray(message.heroId))
                    return "heroId: array expected";
                for (var i = 0; i < message.heroId.length; ++i)
                    if (!$util.isInteger(message.heroId[i]))
                        return "heroId: integer[] expected";
            }
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel")) {
                if (!Array.isArray(message.heroLevel))
                    return "heroLevel: array expected";
                for (var i = 0; i < message.heroLevel.length; ++i)
                    if (!$util.isInteger(message.heroLevel[i]))
                        return "heroLevel: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_MainFBPassNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MainFBPassNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MainFBPassNode} PB_MainFBPassNode
         */
        PB_MainFBPassNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MainFBPassNode)
                return object;
            var message = new $root.PB_MainFBPassNode();
            if (object.roleInfo != null) {
                if (typeof object.roleInfo !== "object")
                    throw TypeError(".PB_MainFBPassNode.roleInfo: object expected");
                message.roleInfo = $root.PB_RoleInfo.fromObject(object.roleInfo);
            }
            if (object.time != null)
                message.time = object.time >>> 0;
            if (object.heroId) {
                if (!Array.isArray(object.heroId))
                    throw TypeError(".PB_MainFBPassNode.heroId: array expected");
                message.heroId = [];
                for (var i = 0; i < object.heroId.length; ++i)
                    message.heroId[i] = object.heroId[i] | 0;
            }
            if (object.heroLevel) {
                if (!Array.isArray(object.heroLevel))
                    throw TypeError(".PB_MainFBPassNode.heroLevel: array expected");
                message.heroLevel = [];
                for (var i = 0; i < object.heroLevel.length; ++i)
                    message.heroLevel[i] = object.heroLevel[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MainFBPassNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MainFBPassNode
         * @static
         * @param {PB_MainFBPassNode} message PB_MainFBPassNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MainFBPassNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.heroId = [];
                object.heroLevel = [];
            }
            if (options.defaults) {
                object.roleInfo = null;
                object.time = 0;
            }
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo"))
                object.roleInfo = $root.PB_RoleInfo.toObject(message.roleInfo, options);
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.heroId && message.heroId.length) {
                object.heroId = [];
                for (var j = 0; j < message.heroId.length; ++j)
                    object.heroId[j] = message.heroId[j];
            }
            if (message.heroLevel && message.heroLevel.length) {
                object.heroLevel = [];
                for (var j = 0; j < message.heroLevel.length; ++j)
                    object.heroLevel[j] = message.heroLevel[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_MainFBPassNode to JSON.
         * @function toJSON
         * @memberof PB_MainFBPassNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MainFBPassNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MainFBPassNode;
    })();
    
    $root.PB_MainFBPassInfo = (function() {
    
        /**
         * Properties of a PB_MainFBPassInfo.
         * @exports IPB_MainFBPassInfo
         * @interface IPB_MainFBPassInfo
         * @property {number|null} [fbLevel] PB_MainFBPassInfo fbLevel
         * @property {Array.<IPB_MainFBPassNode>|null} [infoList] PB_MainFBPassInfo infoList
         */
    
        /**
         * Constructs a new PB_MainFBPassInfo.
         * @exports PB_MainFBPassInfo
         * @classdesc Represents a PB_MainFBPassInfo.
         * @implements IPB_MainFBPassInfo
         * @constructor
         * @param {IPB_MainFBPassInfo=} [properties] Properties to set
         */
        function PB_MainFBPassInfo(properties) {
            this.infoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MainFBPassInfo fbLevel.
         * @member {number} fbLevel
         * @memberof PB_MainFBPassInfo
         * @instance
         */
        PB_MainFBPassInfo.prototype.fbLevel = 0;
    
        /**
         * PB_MainFBPassInfo infoList.
         * @member {Array.<IPB_MainFBPassNode>} infoList
         * @memberof PB_MainFBPassInfo
         * @instance
         */
        PB_MainFBPassInfo.prototype.infoList = $util.emptyArray;
    
        /**
         * Creates a new PB_MainFBPassInfo instance using the specified properties.
         * @function create
         * @memberof PB_MainFBPassInfo
         * @static
         * @param {IPB_MainFBPassInfo=} [properties] Properties to set
         * @returns {PB_MainFBPassInfo} PB_MainFBPassInfo instance
         */
        PB_MainFBPassInfo.create = function create(properties) {
            return new PB_MainFBPassInfo(properties);
        };
    
        /**
         * Encodes the specified PB_MainFBPassInfo message. Does not implicitly {@link PB_MainFBPassInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_MainFBPassInfo
         * @static
         * @param {IPB_MainFBPassInfo} message PB_MainFBPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBPassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fbLevel != null && Object.hasOwnProperty.call(message, "fbLevel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fbLevel);
            if (message.infoList != null && message.infoList.length)
                for (var i = 0; i < message.infoList.length; ++i)
                    $root.PB_MainFBPassNode.encode(message.infoList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_MainFBPassInfo message, length delimited. Does not implicitly {@link PB_MainFBPassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MainFBPassInfo
         * @static
         * @param {IPB_MainFBPassInfo} message PB_MainFBPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBPassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MainFBPassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MainFBPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MainFBPassInfo} PB_MainFBPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBPassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MainFBPassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fbLevel = reader.int32();
                    break;
                case 2:
                    if (!(message.infoList && message.infoList.length))
                        message.infoList = [];
                    message.infoList.push($root.PB_MainFBPassNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MainFBPassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MainFBPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MainFBPassInfo} PB_MainFBPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBPassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MainFBPassInfo message.
         * @function verify
         * @memberof PB_MainFBPassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MainFBPassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fbLevel != null && message.hasOwnProperty("fbLevel"))
                if (!$util.isInteger(message.fbLevel))
                    return "fbLevel: integer expected";
            if (message.infoList != null && message.hasOwnProperty("infoList")) {
                if (!Array.isArray(message.infoList))
                    return "infoList: array expected";
                for (var i = 0; i < message.infoList.length; ++i) {
                    var error = $root.PB_MainFBPassNode.verify(message.infoList[i]);
                    if (error)
                        return "infoList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_MainFBPassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MainFBPassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MainFBPassInfo} PB_MainFBPassInfo
         */
        PB_MainFBPassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MainFBPassInfo)
                return object;
            var message = new $root.PB_MainFBPassInfo();
            if (object.fbLevel != null)
                message.fbLevel = object.fbLevel | 0;
            if (object.infoList) {
                if (!Array.isArray(object.infoList))
                    throw TypeError(".PB_MainFBPassInfo.infoList: array expected");
                message.infoList = [];
                for (var i = 0; i < object.infoList.length; ++i) {
                    if (typeof object.infoList[i] !== "object")
                        throw TypeError(".PB_MainFBPassInfo.infoList: object expected");
                    message.infoList[i] = $root.PB_MainFBPassNode.fromObject(object.infoList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MainFBPassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MainFBPassInfo
         * @static
         * @param {PB_MainFBPassInfo} message PB_MainFBPassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MainFBPassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infoList = [];
            if (options.defaults)
                object.fbLevel = 0;
            if (message.fbLevel != null && message.hasOwnProperty("fbLevel"))
                object.fbLevel = message.fbLevel;
            if (message.infoList && message.infoList.length) {
                object.infoList = [];
                for (var j = 0; j < message.infoList.length; ++j)
                    object.infoList[j] = $root.PB_MainFBPassNode.toObject(message.infoList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_MainFBPassInfo to JSON.
         * @function toJSON
         * @memberof PB_MainFBPassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MainFBPassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MainFBPassInfo;
    })();
    
    $root.PB_MainFBRankUser = (function() {
    
        /**
         * Properties of a PB_MainFBRankUser.
         * @exports IPB_MainFBRankUser
         * @interface IPB_MainFBRankUser
         * @property {IPB_RoleInfo|null} [roleInfo] PB_MainFBRankUser roleInfo
         * @property {number|null} [rankLevel] PB_MainFBRankUser rankLevel
         */
    
        /**
         * Constructs a new PB_MainFBRankUser.
         * @exports PB_MainFBRankUser
         * @classdesc Represents a PB_MainFBRankUser.
         * @implements IPB_MainFBRankUser
         * @constructor
         * @param {IPB_MainFBRankUser=} [properties] Properties to set
         */
        function PB_MainFBRankUser(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MainFBRankUser roleInfo.
         * @member {IPB_RoleInfo|null|undefined} roleInfo
         * @memberof PB_MainFBRankUser
         * @instance
         */
        PB_MainFBRankUser.prototype.roleInfo = null;
    
        /**
         * PB_MainFBRankUser rankLevel.
         * @member {number} rankLevel
         * @memberof PB_MainFBRankUser
         * @instance
         */
        PB_MainFBRankUser.prototype.rankLevel = 0;
    
        /**
         * Creates a new PB_MainFBRankUser instance using the specified properties.
         * @function create
         * @memberof PB_MainFBRankUser
         * @static
         * @param {IPB_MainFBRankUser=} [properties] Properties to set
         * @returns {PB_MainFBRankUser} PB_MainFBRankUser instance
         */
        PB_MainFBRankUser.create = function create(properties) {
            return new PB_MainFBRankUser(properties);
        };
    
        /**
         * Encodes the specified PB_MainFBRankUser message. Does not implicitly {@link PB_MainFBRankUser.verify|verify} messages.
         * @function encode
         * @memberof PB_MainFBRankUser
         * @static
         * @param {IPB_MainFBRankUser} message PB_MainFBRankUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBRankUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleInfo != null && Object.hasOwnProperty.call(message, "roleInfo"))
                $root.PB_RoleInfo.encode(message.roleInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rankLevel != null && Object.hasOwnProperty.call(message, "rankLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rankLevel);
            return writer;
        };
    
        /**
         * Encodes the specified PB_MainFBRankUser message, length delimited. Does not implicitly {@link PB_MainFBRankUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MainFBRankUser
         * @static
         * @param {IPB_MainFBRankUser} message PB_MainFBRankUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBRankUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MainFBRankUser message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MainFBRankUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MainFBRankUser} PB_MainFBRankUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBRankUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MainFBRankUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.rankLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MainFBRankUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MainFBRankUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MainFBRankUser} PB_MainFBRankUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBRankUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MainFBRankUser message.
         * @function verify
         * @memberof PB_MainFBRankUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MainFBRankUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleInfo);
                if (error)
                    return "roleInfo." + error;
            }
            if (message.rankLevel != null && message.hasOwnProperty("rankLevel"))
                if (!$util.isInteger(message.rankLevel))
                    return "rankLevel: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_MainFBRankUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MainFBRankUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MainFBRankUser} PB_MainFBRankUser
         */
        PB_MainFBRankUser.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MainFBRankUser)
                return object;
            var message = new $root.PB_MainFBRankUser();
            if (object.roleInfo != null) {
                if (typeof object.roleInfo !== "object")
                    throw TypeError(".PB_MainFBRankUser.roleInfo: object expected");
                message.roleInfo = $root.PB_RoleInfo.fromObject(object.roleInfo);
            }
            if (object.rankLevel != null)
                message.rankLevel = object.rankLevel | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MainFBRankUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MainFBRankUser
         * @static
         * @param {PB_MainFBRankUser} message PB_MainFBRankUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MainFBRankUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roleInfo = null;
                object.rankLevel = 0;
            }
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo"))
                object.roleInfo = $root.PB_RoleInfo.toObject(message.roleInfo, options);
            if (message.rankLevel != null && message.hasOwnProperty("rankLevel"))
                object.rankLevel = message.rankLevel;
            return object;
        };
    
        /**
         * Converts this PB_MainFBRankUser to JSON.
         * @function toJSON
         * @memberof PB_MainFBRankUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MainFBRankUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MainFBRankUser;
    })();
    
    $root.PB_MainFBRankInfo = (function() {
    
        /**
         * Properties of a PB_MainFBRankInfo.
         * @exports IPB_MainFBRankInfo
         * @interface IPB_MainFBRankInfo
         * @property {number|null} [beginRank] PB_MainFBRankInfo beginRank
         * @property {Array.<IPB_MainFBRankUser>|null} [rankList] PB_MainFBRankInfo rankList
         * @property {number|null} [myRank] PB_MainFBRankInfo myRank
         * @property {number|null} [myPassLevel] PB_MainFBRankInfo myPassLevel
         */
    
        /**
         * Constructs a new PB_MainFBRankInfo.
         * @exports PB_MainFBRankInfo
         * @classdesc Represents a PB_MainFBRankInfo.
         * @implements IPB_MainFBRankInfo
         * @constructor
         * @param {IPB_MainFBRankInfo=} [properties] Properties to set
         */
        function PB_MainFBRankInfo(properties) {
            this.rankList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_MainFBRankInfo beginRank.
         * @member {number} beginRank
         * @memberof PB_MainFBRankInfo
         * @instance
         */
        PB_MainFBRankInfo.prototype.beginRank = 0;
    
        /**
         * PB_MainFBRankInfo rankList.
         * @member {Array.<IPB_MainFBRankUser>} rankList
         * @memberof PB_MainFBRankInfo
         * @instance
         */
        PB_MainFBRankInfo.prototype.rankList = $util.emptyArray;
    
        /**
         * PB_MainFBRankInfo myRank.
         * @member {number} myRank
         * @memberof PB_MainFBRankInfo
         * @instance
         */
        PB_MainFBRankInfo.prototype.myRank = 0;
    
        /**
         * PB_MainFBRankInfo myPassLevel.
         * @member {number} myPassLevel
         * @memberof PB_MainFBRankInfo
         * @instance
         */
        PB_MainFBRankInfo.prototype.myPassLevel = 0;
    
        /**
         * Creates a new PB_MainFBRankInfo instance using the specified properties.
         * @function create
         * @memberof PB_MainFBRankInfo
         * @static
         * @param {IPB_MainFBRankInfo=} [properties] Properties to set
         * @returns {PB_MainFBRankInfo} PB_MainFBRankInfo instance
         */
        PB_MainFBRankInfo.create = function create(properties) {
            return new PB_MainFBRankInfo(properties);
        };
    
        /**
         * Encodes the specified PB_MainFBRankInfo message. Does not implicitly {@link PB_MainFBRankInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_MainFBRankInfo
         * @static
         * @param {IPB_MainFBRankInfo} message PB_MainFBRankInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBRankInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.beginRank != null && Object.hasOwnProperty.call(message, "beginRank"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.beginRank);
            if (message.rankList != null && message.rankList.length)
                for (var i = 0; i < message.rankList.length; ++i)
                    $root.PB_MainFBRankUser.encode(message.rankList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.myRank != null && Object.hasOwnProperty.call(message, "myRank"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.myRank);
            if (message.myPassLevel != null && Object.hasOwnProperty.call(message, "myPassLevel"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.myPassLevel);
            return writer;
        };
    
        /**
         * Encodes the specified PB_MainFBRankInfo message, length delimited. Does not implicitly {@link PB_MainFBRankInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_MainFBRankInfo
         * @static
         * @param {IPB_MainFBRankInfo} message PB_MainFBRankInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_MainFBRankInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_MainFBRankInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_MainFBRankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_MainFBRankInfo} PB_MainFBRankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBRankInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_MainFBRankInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.beginRank = reader.int32();
                    break;
                case 2:
                    if (!(message.rankList && message.rankList.length))
                        message.rankList = [];
                    message.rankList.push($root.PB_MainFBRankUser.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.myRank = reader.int32();
                    break;
                case 4:
                    message.myPassLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_MainFBRankInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_MainFBRankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_MainFBRankInfo} PB_MainFBRankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_MainFBRankInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_MainFBRankInfo message.
         * @function verify
         * @memberof PB_MainFBRankInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_MainFBRankInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.beginRank != null && message.hasOwnProperty("beginRank"))
                if (!$util.isInteger(message.beginRank))
                    return "beginRank: integer expected";
            if (message.rankList != null && message.hasOwnProperty("rankList")) {
                if (!Array.isArray(message.rankList))
                    return "rankList: array expected";
                for (var i = 0; i < message.rankList.length; ++i) {
                    var error = $root.PB_MainFBRankUser.verify(message.rankList[i]);
                    if (error)
                        return "rankList." + error;
                }
            }
            if (message.myRank != null && message.hasOwnProperty("myRank"))
                if (!$util.isInteger(message.myRank))
                    return "myRank: integer expected";
            if (message.myPassLevel != null && message.hasOwnProperty("myPassLevel"))
                if (!$util.isInteger(message.myPassLevel))
                    return "myPassLevel: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_MainFBRankInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_MainFBRankInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_MainFBRankInfo} PB_MainFBRankInfo
         */
        PB_MainFBRankInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_MainFBRankInfo)
                return object;
            var message = new $root.PB_MainFBRankInfo();
            if (object.beginRank != null)
                message.beginRank = object.beginRank | 0;
            if (object.rankList) {
                if (!Array.isArray(object.rankList))
                    throw TypeError(".PB_MainFBRankInfo.rankList: array expected");
                message.rankList = [];
                for (var i = 0; i < object.rankList.length; ++i) {
                    if (typeof object.rankList[i] !== "object")
                        throw TypeError(".PB_MainFBRankInfo.rankList: object expected");
                    message.rankList[i] = $root.PB_MainFBRankUser.fromObject(object.rankList[i]);
                }
            }
            if (object.myRank != null)
                message.myRank = object.myRank | 0;
            if (object.myPassLevel != null)
                message.myPassLevel = object.myPassLevel | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_MainFBRankInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_MainFBRankInfo
         * @static
         * @param {PB_MainFBRankInfo} message PB_MainFBRankInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_MainFBRankInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rankList = [];
            if (options.defaults) {
                object.beginRank = 0;
                object.myRank = 0;
                object.myPassLevel = 0;
            }
            if (message.beginRank != null && message.hasOwnProperty("beginRank"))
                object.beginRank = message.beginRank;
            if (message.rankList && message.rankList.length) {
                object.rankList = [];
                for (var j = 0; j < message.rankList.length; ++j)
                    object.rankList[j] = $root.PB_MainFBRankUser.toObject(message.rankList[j], options);
            }
            if (message.myRank != null && message.hasOwnProperty("myRank"))
                object.myRank = message.myRank;
            if (message.myPassLevel != null && message.hasOwnProperty("myPassLevel"))
                object.myPassLevel = message.myPassLevel;
            return object;
        };
    
        /**
         * Converts this PB_MainFBRankInfo to JSON.
         * @function toJSON
         * @memberof PB_MainFBRankInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_MainFBRankInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_MainFBRankInfo;
    })();
    
    $root.PB_SCAdvertisement = (function() {
    
        /**
         * Properties of a PB_SCAdvertisement.
         * @exports IPB_SCAdvertisement
         * @interface IPB_SCAdvertisement
         * @property {number|null} [seq] PB_SCAdvertisement seq
         * @property {number|null} [todayCount] PB_SCAdvertisement todayCount
         * @property {number|null} [nextFetchTime] PB_SCAdvertisement nextFetchTime
         */
    
        /**
         * Constructs a new PB_SCAdvertisement.
         * @exports PB_SCAdvertisement
         * @classdesc Represents a PB_SCAdvertisement.
         * @implements IPB_SCAdvertisement
         * @constructor
         * @param {IPB_SCAdvertisement=} [properties] Properties to set
         */
        function PB_SCAdvertisement(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCAdvertisement seq.
         * @member {number} seq
         * @memberof PB_SCAdvertisement
         * @instance
         */
        PB_SCAdvertisement.prototype.seq = 0;
    
        /**
         * PB_SCAdvertisement todayCount.
         * @member {number} todayCount
         * @memberof PB_SCAdvertisement
         * @instance
         */
        PB_SCAdvertisement.prototype.todayCount = 0;
    
        /**
         * PB_SCAdvertisement nextFetchTime.
         * @member {number} nextFetchTime
         * @memberof PB_SCAdvertisement
         * @instance
         */
        PB_SCAdvertisement.prototype.nextFetchTime = 0;
    
        /**
         * Creates a new PB_SCAdvertisement instance using the specified properties.
         * @function create
         * @memberof PB_SCAdvertisement
         * @static
         * @param {IPB_SCAdvertisement=} [properties] Properties to set
         * @returns {PB_SCAdvertisement} PB_SCAdvertisement instance
         */
        PB_SCAdvertisement.create = function create(properties) {
            return new PB_SCAdvertisement(properties);
        };
    
        /**
         * Encodes the specified PB_SCAdvertisement message. Does not implicitly {@link PB_SCAdvertisement.verify|verify} messages.
         * @function encode
         * @memberof PB_SCAdvertisement
         * @static
         * @param {IPB_SCAdvertisement} message PB_SCAdvertisement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAdvertisement.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.todayCount != null && Object.hasOwnProperty.call(message, "todayCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.todayCount);
            if (message.nextFetchTime != null && Object.hasOwnProperty.call(message, "nextFetchTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.nextFetchTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCAdvertisement message, length delimited. Does not implicitly {@link PB_SCAdvertisement.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCAdvertisement
         * @static
         * @param {IPB_SCAdvertisement} message PB_SCAdvertisement message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAdvertisement.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCAdvertisement message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCAdvertisement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCAdvertisement} PB_SCAdvertisement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAdvertisement.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCAdvertisement();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    message.todayCount = reader.int32();
                    break;
                case 3:
                    message.nextFetchTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCAdvertisement message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCAdvertisement
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCAdvertisement} PB_SCAdvertisement
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAdvertisement.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCAdvertisement message.
         * @function verify
         * @memberof PB_SCAdvertisement
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCAdvertisement.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.todayCount != null && message.hasOwnProperty("todayCount"))
                if (!$util.isInteger(message.todayCount))
                    return "todayCount: integer expected";
            if (message.nextFetchTime != null && message.hasOwnProperty("nextFetchTime"))
                if (!$util.isInteger(message.nextFetchTime))
                    return "nextFetchTime: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCAdvertisement message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCAdvertisement
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCAdvertisement} PB_SCAdvertisement
         */
        PB_SCAdvertisement.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCAdvertisement)
                return object;
            var message = new $root.PB_SCAdvertisement();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.todayCount != null)
                message.todayCount = object.todayCount | 0;
            if (object.nextFetchTime != null)
                message.nextFetchTime = object.nextFetchTime | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCAdvertisement message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCAdvertisement
         * @static
         * @param {PB_SCAdvertisement} message PB_SCAdvertisement
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCAdvertisement.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.seq = 0;
                object.todayCount = 0;
                object.nextFetchTime = 0;
            }
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.todayCount != null && message.hasOwnProperty("todayCount"))
                object.todayCount = message.todayCount;
            if (message.nextFetchTime != null && message.hasOwnProperty("nextFetchTime"))
                object.nextFetchTime = message.nextFetchTime;
            return object;
        };
    
        /**
         * Converts this PB_SCAdvertisement to JSON.
         * @function toJSON
         * @memberof PB_SCAdvertisement
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCAdvertisement.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCAdvertisement;
    })();
    
    $root.PB_SevenDayReq = (function() {
    
        /**
         * Properties of a PB_SevenDayReq.
         * @exports IPB_SevenDayReq
         * @interface IPB_SevenDayReq
         * @property {number|null} [operType] PB_SevenDayReq operType
         * @property {Array.<number>|null} [operParam] PB_SevenDayReq operParam
         */
    
        /**
         * Constructs a new PB_SevenDayReq.
         * @exports PB_SevenDayReq
         * @classdesc Represents a PB_SevenDayReq.
         * @implements IPB_SevenDayReq
         * @constructor
         * @param {IPB_SevenDayReq=} [properties] Properties to set
         */
        function PB_SevenDayReq(properties) {
            this.operParam = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SevenDayReq operType.
         * @member {number} operType
         * @memberof PB_SevenDayReq
         * @instance
         */
        PB_SevenDayReq.prototype.operType = 0;
    
        /**
         * PB_SevenDayReq operParam.
         * @member {Array.<number>} operParam
         * @memberof PB_SevenDayReq
         * @instance
         */
        PB_SevenDayReq.prototype.operParam = $util.emptyArray;
    
        /**
         * Creates a new PB_SevenDayReq instance using the specified properties.
         * @function create
         * @memberof PB_SevenDayReq
         * @static
         * @param {IPB_SevenDayReq=} [properties] Properties to set
         * @returns {PB_SevenDayReq} PB_SevenDayReq instance
         */
        PB_SevenDayReq.create = function create(properties) {
            return new PB_SevenDayReq(properties);
        };
    
        /**
         * Encodes the specified PB_SevenDayReq message. Does not implicitly {@link PB_SevenDayReq.verify|verify} messages.
         * @function encode
         * @memberof PB_SevenDayReq
         * @static
         * @param {IPB_SevenDayReq} message PB_SevenDayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SevenDayReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.operType != null && Object.hasOwnProperty.call(message, "operType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operType);
            if (message.operParam != null && message.operParam.length)
                for (var i = 0; i < message.operParam.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.operParam[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SevenDayReq message, length delimited. Does not implicitly {@link PB_SevenDayReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SevenDayReq
         * @static
         * @param {IPB_SevenDayReq} message PB_SevenDayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SevenDayReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SevenDayReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SevenDayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SevenDayReq} PB_SevenDayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SevenDayReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SevenDayReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.operType = reader.int32();
                    break;
                case 2:
                    if (!(message.operParam && message.operParam.length))
                        message.operParam = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.operParam.push(reader.int32());
                    } else
                        message.operParam.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SevenDayReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SevenDayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SevenDayReq} PB_SevenDayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SevenDayReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SevenDayReq message.
         * @function verify
         * @memberof PB_SevenDayReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SevenDayReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.operType != null && message.hasOwnProperty("operType"))
                if (!$util.isInteger(message.operType))
                    return "operType: integer expected";
            if (message.operParam != null && message.hasOwnProperty("operParam")) {
                if (!Array.isArray(message.operParam))
                    return "operParam: array expected";
                for (var i = 0; i < message.operParam.length; ++i)
                    if (!$util.isInteger(message.operParam[i]))
                        return "operParam: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SevenDayReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SevenDayReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SevenDayReq} PB_SevenDayReq
         */
        PB_SevenDayReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SevenDayReq)
                return object;
            var message = new $root.PB_SevenDayReq();
            if (object.operType != null)
                message.operType = object.operType | 0;
            if (object.operParam) {
                if (!Array.isArray(object.operParam))
                    throw TypeError(".PB_SevenDayReq.operParam: array expected");
                message.operParam = [];
                for (var i = 0; i < object.operParam.length; ++i)
                    message.operParam[i] = object.operParam[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SevenDayReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SevenDayReq
         * @static
         * @param {PB_SevenDayReq} message PB_SevenDayReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SevenDayReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.operParam = [];
            if (options.defaults)
                object.operType = 0;
            if (message.operType != null && message.hasOwnProperty("operType"))
                object.operType = message.operType;
            if (message.operParam && message.operParam.length) {
                object.operParam = [];
                for (var j = 0; j < message.operParam.length; ++j)
                    object.operParam[j] = message.operParam[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SevenDayReq to JSON.
         * @function toJSON
         * @memberof PB_SevenDayReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SevenDayReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SevenDayReq;
    })();
    
    $root.PB_SevenDayNode = (function() {
    
        /**
         * Properties of a PB_SevenDayNode.
         * @exports IPB_SevenDayNode
         * @interface IPB_SevenDayNode
         * @property {number|null} [dayId] PB_SevenDayNode dayId
         * @property {Array.<number>|null} [taskProgress] PB_SevenDayNode taskProgress
         * @property {Array.<boolean>|null} [taskFetch] PB_SevenDayNode taskFetch
         */
    
        /**
         * Constructs a new PB_SevenDayNode.
         * @exports PB_SevenDayNode
         * @classdesc Represents a PB_SevenDayNode.
         * @implements IPB_SevenDayNode
         * @constructor
         * @param {IPB_SevenDayNode=} [properties] Properties to set
         */
        function PB_SevenDayNode(properties) {
            this.taskProgress = [];
            this.taskFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SevenDayNode dayId.
         * @member {number} dayId
         * @memberof PB_SevenDayNode
         * @instance
         */
        PB_SevenDayNode.prototype.dayId = 0;
    
        /**
         * PB_SevenDayNode taskProgress.
         * @member {Array.<number>} taskProgress
         * @memberof PB_SevenDayNode
         * @instance
         */
        PB_SevenDayNode.prototype.taskProgress = $util.emptyArray;
    
        /**
         * PB_SevenDayNode taskFetch.
         * @member {Array.<boolean>} taskFetch
         * @memberof PB_SevenDayNode
         * @instance
         */
        PB_SevenDayNode.prototype.taskFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SevenDayNode instance using the specified properties.
         * @function create
         * @memberof PB_SevenDayNode
         * @static
         * @param {IPB_SevenDayNode=} [properties] Properties to set
         * @returns {PB_SevenDayNode} PB_SevenDayNode instance
         */
        PB_SevenDayNode.create = function create(properties) {
            return new PB_SevenDayNode(properties);
        };
    
        /**
         * Encodes the specified PB_SevenDayNode message. Does not implicitly {@link PB_SevenDayNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SevenDayNode
         * @static
         * @param {IPB_SevenDayNode} message PB_SevenDayNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SevenDayNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dayId != null && Object.hasOwnProperty.call(message, "dayId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dayId);
            if (message.taskProgress != null && message.taskProgress.length)
                for (var i = 0; i < message.taskProgress.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.taskProgress[i]);
            if (message.taskFetch != null && message.taskFetch.length)
                for (var i = 0; i < message.taskFetch.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.taskFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SevenDayNode message, length delimited. Does not implicitly {@link PB_SevenDayNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SevenDayNode
         * @static
         * @param {IPB_SevenDayNode} message PB_SevenDayNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SevenDayNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SevenDayNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SevenDayNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SevenDayNode} PB_SevenDayNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SevenDayNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SevenDayNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dayId = reader.int32();
                    break;
                case 2:
                    if (!(message.taskProgress && message.taskProgress.length))
                        message.taskProgress = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.taskProgress.push(reader.int32());
                    } else
                        message.taskProgress.push(reader.int32());
                    break;
                case 3:
                    if (!(message.taskFetch && message.taskFetch.length))
                        message.taskFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.taskFetch.push(reader.bool());
                    } else
                        message.taskFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SevenDayNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SevenDayNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SevenDayNode} PB_SevenDayNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SevenDayNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SevenDayNode message.
         * @function verify
         * @memberof PB_SevenDayNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SevenDayNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dayId != null && message.hasOwnProperty("dayId"))
                if (!$util.isInteger(message.dayId))
                    return "dayId: integer expected";
            if (message.taskProgress != null && message.hasOwnProperty("taskProgress")) {
                if (!Array.isArray(message.taskProgress))
                    return "taskProgress: array expected";
                for (var i = 0; i < message.taskProgress.length; ++i)
                    if (!$util.isInteger(message.taskProgress[i]))
                        return "taskProgress: integer[] expected";
            }
            if (message.taskFetch != null && message.hasOwnProperty("taskFetch")) {
                if (!Array.isArray(message.taskFetch))
                    return "taskFetch: array expected";
                for (var i = 0; i < message.taskFetch.length; ++i)
                    if (typeof message.taskFetch[i] !== "boolean")
                        return "taskFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SevenDayNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SevenDayNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SevenDayNode} PB_SevenDayNode
         */
        PB_SevenDayNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SevenDayNode)
                return object;
            var message = new $root.PB_SevenDayNode();
            if (object.dayId != null)
                message.dayId = object.dayId | 0;
            if (object.taskProgress) {
                if (!Array.isArray(object.taskProgress))
                    throw TypeError(".PB_SevenDayNode.taskProgress: array expected");
                message.taskProgress = [];
                for (var i = 0; i < object.taskProgress.length; ++i)
                    message.taskProgress[i] = object.taskProgress[i] | 0;
            }
            if (object.taskFetch) {
                if (!Array.isArray(object.taskFetch))
                    throw TypeError(".PB_SevenDayNode.taskFetch: array expected");
                message.taskFetch = [];
                for (var i = 0; i < object.taskFetch.length; ++i)
                    message.taskFetch[i] = Boolean(object.taskFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SevenDayNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SevenDayNode
         * @static
         * @param {PB_SevenDayNode} message PB_SevenDayNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SevenDayNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.taskProgress = [];
                object.taskFetch = [];
            }
            if (options.defaults)
                object.dayId = 0;
            if (message.dayId != null && message.hasOwnProperty("dayId"))
                object.dayId = message.dayId;
            if (message.taskProgress && message.taskProgress.length) {
                object.taskProgress = [];
                for (var j = 0; j < message.taskProgress.length; ++j)
                    object.taskProgress[j] = message.taskProgress[j];
            }
            if (message.taskFetch && message.taskFetch.length) {
                object.taskFetch = [];
                for (var j = 0; j < message.taskFetch.length; ++j)
                    object.taskFetch[j] = message.taskFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SevenDayNode to JSON.
         * @function toJSON
         * @memberof PB_SevenDayNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SevenDayNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SevenDayNode;
    })();
    
    $root.PB_SevenDayInfo = (function() {
    
        /**
         * Properties of a PB_SevenDayInfo.
         * @exports IPB_SevenDayInfo
         * @interface IPB_SevenDayInfo
         * @property {number|null} [stageRewardFlag] PB_SevenDayInfo stageRewardFlag
         * @property {number|null} [activityEndTime] PB_SevenDayInfo activityEndTime
         * @property {Array.<IPB_SevenDayNode>|null} [taskList] PB_SevenDayInfo taskList
         * @property {number|null} [sendType] PB_SevenDayInfo sendType
         * @property {number|null} [nowStage] PB_SevenDayInfo nowStage
         */
    
        /**
         * Constructs a new PB_SevenDayInfo.
         * @exports PB_SevenDayInfo
         * @classdesc Represents a PB_SevenDayInfo.
         * @implements IPB_SevenDayInfo
         * @constructor
         * @param {IPB_SevenDayInfo=} [properties] Properties to set
         */
        function PB_SevenDayInfo(properties) {
            this.taskList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SevenDayInfo stageRewardFlag.
         * @member {number} stageRewardFlag
         * @memberof PB_SevenDayInfo
         * @instance
         */
        PB_SevenDayInfo.prototype.stageRewardFlag = 0;
    
        /**
         * PB_SevenDayInfo activityEndTime.
         * @member {number} activityEndTime
         * @memberof PB_SevenDayInfo
         * @instance
         */
        PB_SevenDayInfo.prototype.activityEndTime = 0;
    
        /**
         * PB_SevenDayInfo taskList.
         * @member {Array.<IPB_SevenDayNode>} taskList
         * @memberof PB_SevenDayInfo
         * @instance
         */
        PB_SevenDayInfo.prototype.taskList = $util.emptyArray;
    
        /**
         * PB_SevenDayInfo sendType.
         * @member {number} sendType
         * @memberof PB_SevenDayInfo
         * @instance
         */
        PB_SevenDayInfo.prototype.sendType = 0;
    
        /**
         * PB_SevenDayInfo nowStage.
         * @member {number} nowStage
         * @memberof PB_SevenDayInfo
         * @instance
         */
        PB_SevenDayInfo.prototype.nowStage = 0;
    
        /**
         * Creates a new PB_SevenDayInfo instance using the specified properties.
         * @function create
         * @memberof PB_SevenDayInfo
         * @static
         * @param {IPB_SevenDayInfo=} [properties] Properties to set
         * @returns {PB_SevenDayInfo} PB_SevenDayInfo instance
         */
        PB_SevenDayInfo.create = function create(properties) {
            return new PB_SevenDayInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SevenDayInfo message. Does not implicitly {@link PB_SevenDayInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SevenDayInfo
         * @static
         * @param {IPB_SevenDayInfo} message PB_SevenDayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SevenDayInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stageRewardFlag != null && Object.hasOwnProperty.call(message, "stageRewardFlag"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.stageRewardFlag);
            if (message.activityEndTime != null && Object.hasOwnProperty.call(message, "activityEndTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.activityEndTime);
            if (message.taskList != null && message.taskList.length)
                for (var i = 0; i < message.taskList.length; ++i)
                    $root.PB_SevenDayNode.encode(message.taskList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.sendType != null && Object.hasOwnProperty.call(message, "sendType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.sendType);
            if (message.nowStage != null && Object.hasOwnProperty.call(message, "nowStage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.nowStage);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SevenDayInfo message, length delimited. Does not implicitly {@link PB_SevenDayInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SevenDayInfo
         * @static
         * @param {IPB_SevenDayInfo} message PB_SevenDayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SevenDayInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SevenDayInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SevenDayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SevenDayInfo} PB_SevenDayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SevenDayInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SevenDayInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.stageRewardFlag = reader.int32();
                    break;
                case 2:
                    message.activityEndTime = reader.uint32();
                    break;
                case 3:
                    if (!(message.taskList && message.taskList.length))
                        message.taskList = [];
                    message.taskList.push($root.PB_SevenDayNode.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.sendType = reader.int32();
                    break;
                case 5:
                    message.nowStage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SevenDayInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SevenDayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SevenDayInfo} PB_SevenDayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SevenDayInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SevenDayInfo message.
         * @function verify
         * @memberof PB_SevenDayInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SevenDayInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.stageRewardFlag != null && message.hasOwnProperty("stageRewardFlag"))
                if (!$util.isInteger(message.stageRewardFlag))
                    return "stageRewardFlag: integer expected";
            if (message.activityEndTime != null && message.hasOwnProperty("activityEndTime"))
                if (!$util.isInteger(message.activityEndTime))
                    return "activityEndTime: integer expected";
            if (message.taskList != null && message.hasOwnProperty("taskList")) {
                if (!Array.isArray(message.taskList))
                    return "taskList: array expected";
                for (var i = 0; i < message.taskList.length; ++i) {
                    var error = $root.PB_SevenDayNode.verify(message.taskList[i]);
                    if (error)
                        return "taskList." + error;
                }
            }
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                if (!$util.isInteger(message.sendType))
                    return "sendType: integer expected";
            if (message.nowStage != null && message.hasOwnProperty("nowStage"))
                if (!$util.isInteger(message.nowStage))
                    return "nowStage: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SevenDayInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SevenDayInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SevenDayInfo} PB_SevenDayInfo
         */
        PB_SevenDayInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SevenDayInfo)
                return object;
            var message = new $root.PB_SevenDayInfo();
            if (object.stageRewardFlag != null)
                message.stageRewardFlag = object.stageRewardFlag | 0;
            if (object.activityEndTime != null)
                message.activityEndTime = object.activityEndTime >>> 0;
            if (object.taskList) {
                if (!Array.isArray(object.taskList))
                    throw TypeError(".PB_SevenDayInfo.taskList: array expected");
                message.taskList = [];
                for (var i = 0; i < object.taskList.length; ++i) {
                    if (typeof object.taskList[i] !== "object")
                        throw TypeError(".PB_SevenDayInfo.taskList: object expected");
                    message.taskList[i] = $root.PB_SevenDayNode.fromObject(object.taskList[i]);
                }
            }
            if (object.sendType != null)
                message.sendType = object.sendType | 0;
            if (object.nowStage != null)
                message.nowStage = object.nowStage | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SevenDayInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SevenDayInfo
         * @static
         * @param {PB_SevenDayInfo} message PB_SevenDayInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SevenDayInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.taskList = [];
            if (options.defaults) {
                object.stageRewardFlag = 0;
                object.activityEndTime = 0;
                object.sendType = 0;
                object.nowStage = 0;
            }
            if (message.stageRewardFlag != null && message.hasOwnProperty("stageRewardFlag"))
                object.stageRewardFlag = message.stageRewardFlag;
            if (message.activityEndTime != null && message.hasOwnProperty("activityEndTime"))
                object.activityEndTime = message.activityEndTime;
            if (message.taskList && message.taskList.length) {
                object.taskList = [];
                for (var j = 0; j < message.taskList.length; ++j)
                    object.taskList[j] = $root.PB_SevenDayNode.toObject(message.taskList[j], options);
            }
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                object.sendType = message.sendType;
            if (message.nowStage != null && message.hasOwnProperty("nowStage"))
                object.nowStage = message.nowStage;
            return object;
        };
    
        /**
         * Converts this PB_SevenDayInfo to JSON.
         * @function toJSON
         * @memberof PB_SevenDayInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SevenDayInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SevenDayInfo;
    })();
    
    $root.PB_DailyFBNode = (function() {
    
        /**
         * Properties of a PB_DailyFBNode.
         * @exports IPB_DailyFBNode
         * @interface IPB_DailyFBNode
         * @property {number|null} [fbType] PB_DailyFBNode fbType
         * @property {number|null} [fbLevel] PB_DailyFBNode fbLevel
         * @property {number|null} [fbRound] PB_DailyFBNode fbRound
         * @property {number|null} [fightCount] PB_DailyFBNode fightCount
         */
    
        /**
         * Constructs a new PB_DailyFBNode.
         * @exports PB_DailyFBNode
         * @classdesc Represents a PB_DailyFBNode.
         * @implements IPB_DailyFBNode
         * @constructor
         * @param {IPB_DailyFBNode=} [properties] Properties to set
         */
        function PB_DailyFBNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_DailyFBNode fbType.
         * @member {number} fbType
         * @memberof PB_DailyFBNode
         * @instance
         */
        PB_DailyFBNode.prototype.fbType = 0;
    
        /**
         * PB_DailyFBNode fbLevel.
         * @member {number} fbLevel
         * @memberof PB_DailyFBNode
         * @instance
         */
        PB_DailyFBNode.prototype.fbLevel = 0;
    
        /**
         * PB_DailyFBNode fbRound.
         * @member {number} fbRound
         * @memberof PB_DailyFBNode
         * @instance
         */
        PB_DailyFBNode.prototype.fbRound = 0;
    
        /**
         * PB_DailyFBNode fightCount.
         * @member {number} fightCount
         * @memberof PB_DailyFBNode
         * @instance
         */
        PB_DailyFBNode.prototype.fightCount = 0;
    
        /**
         * Creates a new PB_DailyFBNode instance using the specified properties.
         * @function create
         * @memberof PB_DailyFBNode
         * @static
         * @param {IPB_DailyFBNode=} [properties] Properties to set
         * @returns {PB_DailyFBNode} PB_DailyFBNode instance
         */
        PB_DailyFBNode.create = function create(properties) {
            return new PB_DailyFBNode(properties);
        };
    
        /**
         * Encodes the specified PB_DailyFBNode message. Does not implicitly {@link PB_DailyFBNode.verify|verify} messages.
         * @function encode
         * @memberof PB_DailyFBNode
         * @static
         * @param {IPB_DailyFBNode} message PB_DailyFBNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyFBNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fbType != null && Object.hasOwnProperty.call(message, "fbType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fbType);
            if (message.fbLevel != null && Object.hasOwnProperty.call(message, "fbLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fbLevel);
            if (message.fbRound != null && Object.hasOwnProperty.call(message, "fbRound"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fbRound);
            if (message.fightCount != null && Object.hasOwnProperty.call(message, "fightCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.fightCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_DailyFBNode message, length delimited. Does not implicitly {@link PB_DailyFBNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_DailyFBNode
         * @static
         * @param {IPB_DailyFBNode} message PB_DailyFBNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyFBNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_DailyFBNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_DailyFBNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_DailyFBNode} PB_DailyFBNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyFBNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_DailyFBNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fbType = reader.int32();
                    break;
                case 2:
                    message.fbLevel = reader.int32();
                    break;
                case 3:
                    message.fbRound = reader.int32();
                    break;
                case 4:
                    message.fightCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_DailyFBNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_DailyFBNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_DailyFBNode} PB_DailyFBNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyFBNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_DailyFBNode message.
         * @function verify
         * @memberof PB_DailyFBNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_DailyFBNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fbType != null && message.hasOwnProperty("fbType"))
                if (!$util.isInteger(message.fbType))
                    return "fbType: integer expected";
            if (message.fbLevel != null && message.hasOwnProperty("fbLevel"))
                if (!$util.isInteger(message.fbLevel))
                    return "fbLevel: integer expected";
            if (message.fbRound != null && message.hasOwnProperty("fbRound"))
                if (!$util.isInteger(message.fbRound))
                    return "fbRound: integer expected";
            if (message.fightCount != null && message.hasOwnProperty("fightCount"))
                if (!$util.isInteger(message.fightCount))
                    return "fightCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_DailyFBNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_DailyFBNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_DailyFBNode} PB_DailyFBNode
         */
        PB_DailyFBNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_DailyFBNode)
                return object;
            var message = new $root.PB_DailyFBNode();
            if (object.fbType != null)
                message.fbType = object.fbType | 0;
            if (object.fbLevel != null)
                message.fbLevel = object.fbLevel | 0;
            if (object.fbRound != null)
                message.fbRound = object.fbRound | 0;
            if (object.fightCount != null)
                message.fightCount = object.fightCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_DailyFBNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_DailyFBNode
         * @static
         * @param {PB_DailyFBNode} message PB_DailyFBNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_DailyFBNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fbType = 0;
                object.fbLevel = 0;
                object.fbRound = 0;
                object.fightCount = 0;
            }
            if (message.fbType != null && message.hasOwnProperty("fbType"))
                object.fbType = message.fbType;
            if (message.fbLevel != null && message.hasOwnProperty("fbLevel"))
                object.fbLevel = message.fbLevel;
            if (message.fbRound != null && message.hasOwnProperty("fbRound"))
                object.fbRound = message.fbRound;
            if (message.fightCount != null && message.hasOwnProperty("fightCount"))
                object.fightCount = message.fightCount;
            return object;
        };
    
        /**
         * Converts this PB_DailyFBNode to JSON.
         * @function toJSON
         * @memberof PB_DailyFBNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_DailyFBNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_DailyFBNode;
    })();
    
    $root.PB_DailyFBOper = (function() {
    
        /**
         * Properties of a PB_DailyFBOper.
         * @exports IPB_DailyFBOper
         * @interface IPB_DailyFBOper
         * @property {number|null} [operType] PB_DailyFBOper operType
         * @property {Array.<number>|null} [param] PB_DailyFBOper param
         */
    
        /**
         * Constructs a new PB_DailyFBOper.
         * @exports PB_DailyFBOper
         * @classdesc Represents a PB_DailyFBOper.
         * @implements IPB_DailyFBOper
         * @constructor
         * @param {IPB_DailyFBOper=} [properties] Properties to set
         */
        function PB_DailyFBOper(properties) {
            this.param = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_DailyFBOper operType.
         * @member {number} operType
         * @memberof PB_DailyFBOper
         * @instance
         */
        PB_DailyFBOper.prototype.operType = 0;
    
        /**
         * PB_DailyFBOper param.
         * @member {Array.<number>} param
         * @memberof PB_DailyFBOper
         * @instance
         */
        PB_DailyFBOper.prototype.param = $util.emptyArray;
    
        /**
         * Creates a new PB_DailyFBOper instance using the specified properties.
         * @function create
         * @memberof PB_DailyFBOper
         * @static
         * @param {IPB_DailyFBOper=} [properties] Properties to set
         * @returns {PB_DailyFBOper} PB_DailyFBOper instance
         */
        PB_DailyFBOper.create = function create(properties) {
            return new PB_DailyFBOper(properties);
        };
    
        /**
         * Encodes the specified PB_DailyFBOper message. Does not implicitly {@link PB_DailyFBOper.verify|verify} messages.
         * @function encode
         * @memberof PB_DailyFBOper
         * @static
         * @param {IPB_DailyFBOper} message PB_DailyFBOper message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyFBOper.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.operType != null && Object.hasOwnProperty.call(message, "operType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operType);
            if (message.param != null && message.param.length)
                for (var i = 0; i < message.param.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.param[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_DailyFBOper message, length delimited. Does not implicitly {@link PB_DailyFBOper.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_DailyFBOper
         * @static
         * @param {IPB_DailyFBOper} message PB_DailyFBOper message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyFBOper.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_DailyFBOper message from the specified reader or buffer.
         * @function decode
         * @memberof PB_DailyFBOper
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_DailyFBOper} PB_DailyFBOper
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyFBOper.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_DailyFBOper();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.operType = reader.int32();
                    break;
                case 2:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_DailyFBOper message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_DailyFBOper
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_DailyFBOper} PB_DailyFBOper
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyFBOper.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_DailyFBOper message.
         * @function verify
         * @memberof PB_DailyFBOper
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_DailyFBOper.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.operType != null && message.hasOwnProperty("operType"))
                if (!$util.isInteger(message.operType))
                    return "operType: integer expected";
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (var i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_DailyFBOper message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_DailyFBOper
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_DailyFBOper} PB_DailyFBOper
         */
        PB_DailyFBOper.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_DailyFBOper)
                return object;
            var message = new $root.PB_DailyFBOper();
            if (object.operType != null)
                message.operType = object.operType | 0;
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".PB_DailyFBOper.param: array expected");
                message.param = [];
                for (var i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_DailyFBOper message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_DailyFBOper
         * @static
         * @param {PB_DailyFBOper} message PB_DailyFBOper
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_DailyFBOper.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.param = [];
            if (options.defaults)
                object.operType = 0;
            if (message.operType != null && message.hasOwnProperty("operType"))
                object.operType = message.operType;
            if (message.param && message.param.length) {
                object.param = [];
                for (var j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_DailyFBOper to JSON.
         * @function toJSON
         * @memberof PB_DailyFBOper
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_DailyFBOper.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_DailyFBOper;
    })();
    
    $root.PB_DailyFBInfo = (function() {
    
        /**
         * Properties of a PB_DailyFBInfo.
         * @exports IPB_DailyFBInfo
         * @interface IPB_DailyFBInfo
         * @property {number|null} [sendType] PB_DailyFBInfo sendType
         * @property {Array.<IPB_DailyFBNode>|null} [fbList] PB_DailyFBInfo fbList
         */
    
        /**
         * Constructs a new PB_DailyFBInfo.
         * @exports PB_DailyFBInfo
         * @classdesc Represents a PB_DailyFBInfo.
         * @implements IPB_DailyFBInfo
         * @constructor
         * @param {IPB_DailyFBInfo=} [properties] Properties to set
         */
        function PB_DailyFBInfo(properties) {
            this.fbList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_DailyFBInfo sendType.
         * @member {number} sendType
         * @memberof PB_DailyFBInfo
         * @instance
         */
        PB_DailyFBInfo.prototype.sendType = 0;
    
        /**
         * PB_DailyFBInfo fbList.
         * @member {Array.<IPB_DailyFBNode>} fbList
         * @memberof PB_DailyFBInfo
         * @instance
         */
        PB_DailyFBInfo.prototype.fbList = $util.emptyArray;
    
        /**
         * Creates a new PB_DailyFBInfo instance using the specified properties.
         * @function create
         * @memberof PB_DailyFBInfo
         * @static
         * @param {IPB_DailyFBInfo=} [properties] Properties to set
         * @returns {PB_DailyFBInfo} PB_DailyFBInfo instance
         */
        PB_DailyFBInfo.create = function create(properties) {
            return new PB_DailyFBInfo(properties);
        };
    
        /**
         * Encodes the specified PB_DailyFBInfo message. Does not implicitly {@link PB_DailyFBInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_DailyFBInfo
         * @static
         * @param {IPB_DailyFBInfo} message PB_DailyFBInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyFBInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sendType != null && Object.hasOwnProperty.call(message, "sendType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sendType);
            if (message.fbList != null && message.fbList.length)
                for (var i = 0; i < message.fbList.length; ++i)
                    $root.PB_DailyFBNode.encode(message.fbList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_DailyFBInfo message, length delimited. Does not implicitly {@link PB_DailyFBInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_DailyFBInfo
         * @static
         * @param {IPB_DailyFBInfo} message PB_DailyFBInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyFBInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_DailyFBInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_DailyFBInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_DailyFBInfo} PB_DailyFBInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyFBInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_DailyFBInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sendType = reader.int32();
                    break;
                case 2:
                    if (!(message.fbList && message.fbList.length))
                        message.fbList = [];
                    message.fbList.push($root.PB_DailyFBNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_DailyFBInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_DailyFBInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_DailyFBInfo} PB_DailyFBInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyFBInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_DailyFBInfo message.
         * @function verify
         * @memberof PB_DailyFBInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_DailyFBInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                if (!$util.isInteger(message.sendType))
                    return "sendType: integer expected";
            if (message.fbList != null && message.hasOwnProperty("fbList")) {
                if (!Array.isArray(message.fbList))
                    return "fbList: array expected";
                for (var i = 0; i < message.fbList.length; ++i) {
                    var error = $root.PB_DailyFBNode.verify(message.fbList[i]);
                    if (error)
                        return "fbList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_DailyFBInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_DailyFBInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_DailyFBInfo} PB_DailyFBInfo
         */
        PB_DailyFBInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_DailyFBInfo)
                return object;
            var message = new $root.PB_DailyFBInfo();
            if (object.sendType != null)
                message.sendType = object.sendType | 0;
            if (object.fbList) {
                if (!Array.isArray(object.fbList))
                    throw TypeError(".PB_DailyFBInfo.fbList: array expected");
                message.fbList = [];
                for (var i = 0; i < object.fbList.length; ++i) {
                    if (typeof object.fbList[i] !== "object")
                        throw TypeError(".PB_DailyFBInfo.fbList: object expected");
                    message.fbList[i] = $root.PB_DailyFBNode.fromObject(object.fbList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_DailyFBInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_DailyFBInfo
         * @static
         * @param {PB_DailyFBInfo} message PB_DailyFBInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_DailyFBInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fbList = [];
            if (options.defaults)
                object.sendType = 0;
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                object.sendType = message.sendType;
            if (message.fbList && message.fbList.length) {
                object.fbList = [];
                for (var j = 0; j < message.fbList.length; ++j)
                    object.fbList[j] = $root.PB_DailyFBNode.toObject(message.fbList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_DailyFBInfo to JSON.
         * @function toJSON
         * @memberof PB_DailyFBInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_DailyFBInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_DailyFBInfo;
    })();
    
    $root.PB_SCAdvertisementInfo = (function() {
    
        /**
         * Properties of a PB_SCAdvertisementInfo.
         * @exports IPB_SCAdvertisementInfo
         * @interface IPB_SCAdvertisementInfo
         * @property {Array.<IPB_SCAdvertisement>|null} [adList] PB_SCAdvertisementInfo adList
         * @property {number|null} [isInit] PB_SCAdvertisementInfo isInit
         */
    
        /**
         * Constructs a new PB_SCAdvertisementInfo.
         * @exports PB_SCAdvertisementInfo
         * @classdesc Represents a PB_SCAdvertisementInfo.
         * @implements IPB_SCAdvertisementInfo
         * @constructor
         * @param {IPB_SCAdvertisementInfo=} [properties] Properties to set
         */
        function PB_SCAdvertisementInfo(properties) {
            this.adList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCAdvertisementInfo adList.
         * @member {Array.<IPB_SCAdvertisement>} adList
         * @memberof PB_SCAdvertisementInfo
         * @instance
         */
        PB_SCAdvertisementInfo.prototype.adList = $util.emptyArray;
    
        /**
         * PB_SCAdvertisementInfo isInit.
         * @member {number} isInit
         * @memberof PB_SCAdvertisementInfo
         * @instance
         */
        PB_SCAdvertisementInfo.prototype.isInit = 0;
    
        /**
         * Creates a new PB_SCAdvertisementInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCAdvertisementInfo
         * @static
         * @param {IPB_SCAdvertisementInfo=} [properties] Properties to set
         * @returns {PB_SCAdvertisementInfo} PB_SCAdvertisementInfo instance
         */
        PB_SCAdvertisementInfo.create = function create(properties) {
            return new PB_SCAdvertisementInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCAdvertisementInfo message. Does not implicitly {@link PB_SCAdvertisementInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCAdvertisementInfo
         * @static
         * @param {IPB_SCAdvertisementInfo} message PB_SCAdvertisementInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAdvertisementInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.adList != null && message.adList.length)
                for (var i = 0; i < message.adList.length; ++i)
                    $root.PB_SCAdvertisement.encode(message.adList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.isInit != null && Object.hasOwnProperty.call(message, "isInit"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isInit);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCAdvertisementInfo message, length delimited. Does not implicitly {@link PB_SCAdvertisementInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCAdvertisementInfo
         * @static
         * @param {IPB_SCAdvertisementInfo} message PB_SCAdvertisementInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAdvertisementInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCAdvertisementInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCAdvertisementInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCAdvertisementInfo} PB_SCAdvertisementInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAdvertisementInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCAdvertisementInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.adList && message.adList.length))
                        message.adList = [];
                    message.adList.push($root.PB_SCAdvertisement.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.isInit = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCAdvertisementInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCAdvertisementInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCAdvertisementInfo} PB_SCAdvertisementInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAdvertisementInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCAdvertisementInfo message.
         * @function verify
         * @memberof PB_SCAdvertisementInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCAdvertisementInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.adList != null && message.hasOwnProperty("adList")) {
                if (!Array.isArray(message.adList))
                    return "adList: array expected";
                for (var i = 0; i < message.adList.length; ++i) {
                    var error = $root.PB_SCAdvertisement.verify(message.adList[i]);
                    if (error)
                        return "adList." + error;
                }
            }
            if (message.isInit != null && message.hasOwnProperty("isInit"))
                if (!$util.isInteger(message.isInit))
                    return "isInit: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCAdvertisementInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCAdvertisementInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCAdvertisementInfo} PB_SCAdvertisementInfo
         */
        PB_SCAdvertisementInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCAdvertisementInfo)
                return object;
            var message = new $root.PB_SCAdvertisementInfo();
            if (object.adList) {
                if (!Array.isArray(object.adList))
                    throw TypeError(".PB_SCAdvertisementInfo.adList: array expected");
                message.adList = [];
                for (var i = 0; i < object.adList.length; ++i) {
                    if (typeof object.adList[i] !== "object")
                        throw TypeError(".PB_SCAdvertisementInfo.adList: object expected");
                    message.adList[i] = $root.PB_SCAdvertisement.fromObject(object.adList[i]);
                }
            }
            if (object.isInit != null)
                message.isInit = object.isInit | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCAdvertisementInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCAdvertisementInfo
         * @static
         * @param {PB_SCAdvertisementInfo} message PB_SCAdvertisementInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCAdvertisementInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.adList = [];
            if (options.defaults)
                object.isInit = 0;
            if (message.adList && message.adList.length) {
                object.adList = [];
                for (var j = 0; j < message.adList.length; ++j)
                    object.adList[j] = $root.PB_SCAdvertisement.toObject(message.adList[j], options);
            }
            if (message.isInit != null && message.hasOwnProperty("isInit"))
                object.isInit = message.isInit;
            return object;
        };
    
        /**
         * Converts this PB_SCAdvertisementInfo to JSON.
         * @function toJSON
         * @memberof PB_SCAdvertisementInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCAdvertisementInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCAdvertisementInfo;
    })();
    
    $root.PB_CSAdvertisementFetch = (function() {
    
        /**
         * Properties of a PB_CSAdvertisementFetch.
         * @exports IPB_CSAdvertisementFetch
         * @interface IPB_CSAdvertisementFetch
         * @property {number|null} [seq] PB_CSAdvertisementFetch seq
         * @property {number|null} [isDia] PB_CSAdvertisementFetch isDia
         * @property {number|null} [param] PB_CSAdvertisementFetch param
         */
    
        /**
         * Constructs a new PB_CSAdvertisementFetch.
         * @exports PB_CSAdvertisementFetch
         * @classdesc Represents a PB_CSAdvertisementFetch.
         * @implements IPB_CSAdvertisementFetch
         * @constructor
         * @param {IPB_CSAdvertisementFetch=} [properties] Properties to set
         */
        function PB_CSAdvertisementFetch(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSAdvertisementFetch seq.
         * @member {number} seq
         * @memberof PB_CSAdvertisementFetch
         * @instance
         */
        PB_CSAdvertisementFetch.prototype.seq = 0;
    
        /**
         * PB_CSAdvertisementFetch isDia.
         * @member {number} isDia
         * @memberof PB_CSAdvertisementFetch
         * @instance
         */
        PB_CSAdvertisementFetch.prototype.isDia = 0;
    
        /**
         * PB_CSAdvertisementFetch param.
         * @member {number} param
         * @memberof PB_CSAdvertisementFetch
         * @instance
         */
        PB_CSAdvertisementFetch.prototype.param = 0;
    
        /**
         * Creates a new PB_CSAdvertisementFetch instance using the specified properties.
         * @function create
         * @memberof PB_CSAdvertisementFetch
         * @static
         * @param {IPB_CSAdvertisementFetch=} [properties] Properties to set
         * @returns {PB_CSAdvertisementFetch} PB_CSAdvertisementFetch instance
         */
        PB_CSAdvertisementFetch.create = function create(properties) {
            return new PB_CSAdvertisementFetch(properties);
        };
    
        /**
         * Encodes the specified PB_CSAdvertisementFetch message. Does not implicitly {@link PB_CSAdvertisementFetch.verify|verify} messages.
         * @function encode
         * @memberof PB_CSAdvertisementFetch
         * @static
         * @param {IPB_CSAdvertisementFetch} message PB_CSAdvertisementFetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSAdvertisementFetch.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.isDia != null && Object.hasOwnProperty.call(message, "isDia"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isDia);
            if (message.param != null && Object.hasOwnProperty.call(message, "param"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.param);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSAdvertisementFetch message, length delimited. Does not implicitly {@link PB_CSAdvertisementFetch.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSAdvertisementFetch
         * @static
         * @param {IPB_CSAdvertisementFetch} message PB_CSAdvertisementFetch message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSAdvertisementFetch.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSAdvertisementFetch message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSAdvertisementFetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSAdvertisementFetch} PB_CSAdvertisementFetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSAdvertisementFetch.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSAdvertisementFetch();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    message.isDia = reader.int32();
                    break;
                case 3:
                    message.param = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSAdvertisementFetch message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSAdvertisementFetch
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSAdvertisementFetch} PB_CSAdvertisementFetch
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSAdvertisementFetch.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSAdvertisementFetch message.
         * @function verify
         * @memberof PB_CSAdvertisementFetch
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSAdvertisementFetch.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.isDia != null && message.hasOwnProperty("isDia"))
                if (!$util.isInteger(message.isDia))
                    return "isDia: integer expected";
            if (message.param != null && message.hasOwnProperty("param"))
                if (!$util.isInteger(message.param))
                    return "param: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSAdvertisementFetch message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSAdvertisementFetch
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSAdvertisementFetch} PB_CSAdvertisementFetch
         */
        PB_CSAdvertisementFetch.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSAdvertisementFetch)
                return object;
            var message = new $root.PB_CSAdvertisementFetch();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.isDia != null)
                message.isDia = object.isDia | 0;
            if (object.param != null)
                message.param = object.param | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSAdvertisementFetch message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSAdvertisementFetch
         * @static
         * @param {PB_CSAdvertisementFetch} message PB_CSAdvertisementFetch
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSAdvertisementFetch.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.seq = 0;
                object.isDia = 0;
                object.param = 0;
            }
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.isDia != null && message.hasOwnProperty("isDia"))
                object.isDia = message.isDia;
            if (message.param != null && message.hasOwnProperty("param"))
                object.param = message.param;
            return object;
        };
    
        /**
         * Converts this PB_CSAdvertisementFetch to JSON.
         * @function toJSON
         * @memberof PB_CSAdvertisementFetch
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSAdvertisementFetch.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSAdvertisementFetch;
    })();
    
    $root.PB_CSFirstRechargeOper = (function() {
    
        /**
         * Properties of a PB_CSFirstRechargeOper.
         * @exports IPB_CSFirstRechargeOper
         * @interface IPB_CSFirstRechargeOper
         */
    
        /**
         * Constructs a new PB_CSFirstRechargeOper.
         * @exports PB_CSFirstRechargeOper
         * @classdesc Represents a PB_CSFirstRechargeOper.
         * @implements IPB_CSFirstRechargeOper
         * @constructor
         * @param {IPB_CSFirstRechargeOper=} [properties] Properties to set
         */
        function PB_CSFirstRechargeOper(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new PB_CSFirstRechargeOper instance using the specified properties.
         * @function create
         * @memberof PB_CSFirstRechargeOper
         * @static
         * @param {IPB_CSFirstRechargeOper=} [properties] Properties to set
         * @returns {PB_CSFirstRechargeOper} PB_CSFirstRechargeOper instance
         */
        PB_CSFirstRechargeOper.create = function create(properties) {
            return new PB_CSFirstRechargeOper(properties);
        };
    
        /**
         * Encodes the specified PB_CSFirstRechargeOper message. Does not implicitly {@link PB_CSFirstRechargeOper.verify|verify} messages.
         * @function encode
         * @memberof PB_CSFirstRechargeOper
         * @static
         * @param {IPB_CSFirstRechargeOper} message PB_CSFirstRechargeOper message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSFirstRechargeOper.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSFirstRechargeOper message, length delimited. Does not implicitly {@link PB_CSFirstRechargeOper.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSFirstRechargeOper
         * @static
         * @param {IPB_CSFirstRechargeOper} message PB_CSFirstRechargeOper message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSFirstRechargeOper.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSFirstRechargeOper message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSFirstRechargeOper
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSFirstRechargeOper} PB_CSFirstRechargeOper
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSFirstRechargeOper.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSFirstRechargeOper();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSFirstRechargeOper message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSFirstRechargeOper
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSFirstRechargeOper} PB_CSFirstRechargeOper
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSFirstRechargeOper.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSFirstRechargeOper message.
         * @function verify
         * @memberof PB_CSFirstRechargeOper
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSFirstRechargeOper.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a PB_CSFirstRechargeOper message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSFirstRechargeOper
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSFirstRechargeOper} PB_CSFirstRechargeOper
         */
        PB_CSFirstRechargeOper.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSFirstRechargeOper)
                return object;
            return new $root.PB_CSFirstRechargeOper();
        };
    
        /**
         * Creates a plain object from a PB_CSFirstRechargeOper message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSFirstRechargeOper
         * @static
         * @param {PB_CSFirstRechargeOper} message PB_CSFirstRechargeOper
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSFirstRechargeOper.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this PB_CSFirstRechargeOper to JSON.
         * @function toJSON
         * @memberof PB_CSFirstRechargeOper
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSFirstRechargeOper.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSFirstRechargeOper;
    })();
    
    $root.PB_SCFirstRechargeInfo = (function() {
    
        /**
         * Properties of a PB_SCFirstRechargeInfo.
         * @exports IPB_SCFirstRechargeInfo
         * @interface IPB_SCFirstRechargeInfo
         * @property {boolean|null} [isActive] PB_SCFirstRechargeInfo isActive
         * @property {boolean|null} [isFetch] PB_SCFirstRechargeInfo isFetch
         */
    
        /**
         * Constructs a new PB_SCFirstRechargeInfo.
         * @exports PB_SCFirstRechargeInfo
         * @classdesc Represents a PB_SCFirstRechargeInfo.
         * @implements IPB_SCFirstRechargeInfo
         * @constructor
         * @param {IPB_SCFirstRechargeInfo=} [properties] Properties to set
         */
        function PB_SCFirstRechargeInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCFirstRechargeInfo isActive.
         * @member {boolean} isActive
         * @memberof PB_SCFirstRechargeInfo
         * @instance
         */
        PB_SCFirstRechargeInfo.prototype.isActive = false;
    
        /**
         * PB_SCFirstRechargeInfo isFetch.
         * @member {boolean} isFetch
         * @memberof PB_SCFirstRechargeInfo
         * @instance
         */
        PB_SCFirstRechargeInfo.prototype.isFetch = false;
    
        /**
         * Creates a new PB_SCFirstRechargeInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCFirstRechargeInfo
         * @static
         * @param {IPB_SCFirstRechargeInfo=} [properties] Properties to set
         * @returns {PB_SCFirstRechargeInfo} PB_SCFirstRechargeInfo instance
         */
        PB_SCFirstRechargeInfo.create = function create(properties) {
            return new PB_SCFirstRechargeInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCFirstRechargeInfo message. Does not implicitly {@link PB_SCFirstRechargeInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCFirstRechargeInfo
         * @static
         * @param {IPB_SCFirstRechargeInfo} message PB_SCFirstRechargeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCFirstRechargeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isActive);
            if (message.isFetch != null && Object.hasOwnProperty.call(message, "isFetch"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCFirstRechargeInfo message, length delimited. Does not implicitly {@link PB_SCFirstRechargeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCFirstRechargeInfo
         * @static
         * @param {IPB_SCFirstRechargeInfo} message PB_SCFirstRechargeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCFirstRechargeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCFirstRechargeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCFirstRechargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCFirstRechargeInfo} PB_SCFirstRechargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCFirstRechargeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCFirstRechargeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.bool();
                    break;
                case 2:
                    message.isFetch = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCFirstRechargeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCFirstRechargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCFirstRechargeInfo} PB_SCFirstRechargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCFirstRechargeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCFirstRechargeInfo message.
         * @function verify
         * @memberof PB_SCFirstRechargeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCFirstRechargeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (typeof message.isActive !== "boolean")
                    return "isActive: boolean expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                if (typeof message.isFetch !== "boolean")
                    return "isFetch: boolean expected";
            return null;
        };
    
        /**
         * Creates a PB_SCFirstRechargeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCFirstRechargeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCFirstRechargeInfo} PB_SCFirstRechargeInfo
         */
        PB_SCFirstRechargeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCFirstRechargeInfo)
                return object;
            var message = new $root.PB_SCFirstRechargeInfo();
            if (object.isActive != null)
                message.isActive = Boolean(object.isActive);
            if (object.isFetch != null)
                message.isFetch = Boolean(object.isFetch);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCFirstRechargeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCFirstRechargeInfo
         * @static
         * @param {PB_SCFirstRechargeInfo} message PB_SCFirstRechargeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCFirstRechargeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.isActive = false;
                object.isFetch = false;
            }
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                object.isFetch = message.isFetch;
            return object;
        };
    
        /**
         * Converts this PB_SCFirstRechargeInfo to JSON.
         * @function toJSON
         * @memberof PB_SCFirstRechargeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCFirstRechargeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCFirstRechargeInfo;
    })();
    
    $root.PB_SCBattleRevive = (function() {
    
        /**
         * Properties of a PB_SCBattleRevive.
         * @exports IPB_SCBattleRevive
         * @interface IPB_SCBattleRevive
         * @property {number|null} [reviveHp] PB_SCBattleRevive reviveHp
         */
    
        /**
         * Constructs a new PB_SCBattleRevive.
         * @exports PB_SCBattleRevive
         * @classdesc Represents a PB_SCBattleRevive.
         * @implements IPB_SCBattleRevive
         * @constructor
         * @param {IPB_SCBattleRevive=} [properties] Properties to set
         */
        function PB_SCBattleRevive(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCBattleRevive reviveHp.
         * @member {number} reviveHp
         * @memberof PB_SCBattleRevive
         * @instance
         */
        PB_SCBattleRevive.prototype.reviveHp = 0;
    
        /**
         * Creates a new PB_SCBattleRevive instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleRevive
         * @static
         * @param {IPB_SCBattleRevive=} [properties] Properties to set
         * @returns {PB_SCBattleRevive} PB_SCBattleRevive instance
         */
        PB_SCBattleRevive.create = function create(properties) {
            return new PB_SCBattleRevive(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleRevive message. Does not implicitly {@link PB_SCBattleRevive.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleRevive
         * @static
         * @param {IPB_SCBattleRevive} message PB_SCBattleRevive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleRevive.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reviveHp != null && Object.hasOwnProperty.call(message, "reviveHp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reviveHp);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleRevive message, length delimited. Does not implicitly {@link PB_SCBattleRevive.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleRevive
         * @static
         * @param {IPB_SCBattleRevive} message PB_SCBattleRevive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleRevive.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleRevive message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleRevive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleRevive} PB_SCBattleRevive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleRevive.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleRevive();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reviveHp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleRevive message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleRevive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleRevive} PB_SCBattleRevive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleRevive.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleRevive message.
         * @function verify
         * @memberof PB_SCBattleRevive
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleRevive.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reviveHp != null && message.hasOwnProperty("reviveHp"))
                if (!$util.isInteger(message.reviveHp))
                    return "reviveHp: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCBattleRevive message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleRevive
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleRevive} PB_SCBattleRevive
         */
        PB_SCBattleRevive.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleRevive)
                return object;
            var message = new $root.PB_SCBattleRevive();
            if (object.reviveHp != null)
                message.reviveHp = object.reviveHp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCBattleRevive message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleRevive
         * @static
         * @param {PB_SCBattleRevive} message PB_SCBattleRevive
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleRevive.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reviveHp = 0;
            if (message.reviveHp != null && message.hasOwnProperty("reviveHp"))
                object.reviveHp = message.reviveHp;
            return object;
        };
    
        /**
         * Converts this PB_SCBattleRevive to JSON.
         * @function toJSON
         * @memberof PB_SCBattleRevive
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleRevive.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleRevive;
    })();
    
    $root.PB_SCBattleBuffRefresh = (function() {
    
        /**
         * Properties of a PB_SCBattleBuffRefresh.
         * @exports IPB_SCBattleBuffRefresh
         * @interface IPB_SCBattleBuffRefresh
         */
    
        /**
         * Constructs a new PB_SCBattleBuffRefresh.
         * @exports PB_SCBattleBuffRefresh
         * @classdesc Represents a PB_SCBattleBuffRefresh.
         * @implements IPB_SCBattleBuffRefresh
         * @constructor
         * @param {IPB_SCBattleBuffRefresh=} [properties] Properties to set
         */
        function PB_SCBattleBuffRefresh(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new PB_SCBattleBuffRefresh instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleBuffRefresh
         * @static
         * @param {IPB_SCBattleBuffRefresh=} [properties] Properties to set
         * @returns {PB_SCBattleBuffRefresh} PB_SCBattleBuffRefresh instance
         */
        PB_SCBattleBuffRefresh.create = function create(properties) {
            return new PB_SCBattleBuffRefresh(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleBuffRefresh message. Does not implicitly {@link PB_SCBattleBuffRefresh.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleBuffRefresh
         * @static
         * @param {IPB_SCBattleBuffRefresh} message PB_SCBattleBuffRefresh message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleBuffRefresh.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleBuffRefresh message, length delimited. Does not implicitly {@link PB_SCBattleBuffRefresh.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleBuffRefresh
         * @static
         * @param {IPB_SCBattleBuffRefresh} message PB_SCBattleBuffRefresh message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleBuffRefresh.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleBuffRefresh message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleBuffRefresh
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleBuffRefresh} PB_SCBattleBuffRefresh
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleBuffRefresh.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleBuffRefresh();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleBuffRefresh message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleBuffRefresh
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleBuffRefresh} PB_SCBattleBuffRefresh
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleBuffRefresh.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleBuffRefresh message.
         * @function verify
         * @memberof PB_SCBattleBuffRefresh
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleBuffRefresh.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a PB_SCBattleBuffRefresh message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleBuffRefresh
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleBuffRefresh} PB_SCBattleBuffRefresh
         */
        PB_SCBattleBuffRefresh.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleBuffRefresh)
                return object;
            return new $root.PB_SCBattleBuffRefresh();
        };
    
        /**
         * Creates a plain object from a PB_SCBattleBuffRefresh message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleBuffRefresh
         * @static
         * @param {PB_SCBattleBuffRefresh} message PB_SCBattleBuffRefresh
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleBuffRefresh.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this PB_SCBattleBuffRefresh to JSON.
         * @function toJSON
         * @memberof PB_SCBattleBuffRefresh
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleBuffRefresh.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleBuffRefresh;
    })();
    
    $root.PB_SCBattleSpeed3 = (function() {
    
        /**
         * Properties of a PB_SCBattleSpeed3.
         * @exports IPB_SCBattleSpeed3
         * @interface IPB_SCBattleSpeed3
         */
    
        /**
         * Constructs a new PB_SCBattleSpeed3.
         * @exports PB_SCBattleSpeed3
         * @classdesc Represents a PB_SCBattleSpeed3.
         * @implements IPB_SCBattleSpeed3
         * @constructor
         * @param {IPB_SCBattleSpeed3=} [properties] Properties to set
         */
        function PB_SCBattleSpeed3(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new PB_SCBattleSpeed3 instance using the specified properties.
         * @function create
         * @memberof PB_SCBattleSpeed3
         * @static
         * @param {IPB_SCBattleSpeed3=} [properties] Properties to set
         * @returns {PB_SCBattleSpeed3} PB_SCBattleSpeed3 instance
         */
        PB_SCBattleSpeed3.create = function create(properties) {
            return new PB_SCBattleSpeed3(properties);
        };
    
        /**
         * Encodes the specified PB_SCBattleSpeed3 message. Does not implicitly {@link PB_SCBattleSpeed3.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBattleSpeed3
         * @static
         * @param {IPB_SCBattleSpeed3} message PB_SCBattleSpeed3 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleSpeed3.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBattleSpeed3 message, length delimited. Does not implicitly {@link PB_SCBattleSpeed3.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBattleSpeed3
         * @static
         * @param {IPB_SCBattleSpeed3} message PB_SCBattleSpeed3 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBattleSpeed3.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBattleSpeed3 message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBattleSpeed3
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBattleSpeed3} PB_SCBattleSpeed3
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleSpeed3.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBattleSpeed3();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBattleSpeed3 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBattleSpeed3
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBattleSpeed3} PB_SCBattleSpeed3
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBattleSpeed3.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBattleSpeed3 message.
         * @function verify
         * @memberof PB_SCBattleSpeed3
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBattleSpeed3.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };
    
        /**
         * Creates a PB_SCBattleSpeed3 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBattleSpeed3
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBattleSpeed3} PB_SCBattleSpeed3
         */
        PB_SCBattleSpeed3.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBattleSpeed3)
                return object;
            return new $root.PB_SCBattleSpeed3();
        };
    
        /**
         * Creates a plain object from a PB_SCBattleSpeed3 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBattleSpeed3
         * @static
         * @param {PB_SCBattleSpeed3} message PB_SCBattleSpeed3
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBattleSpeed3.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this PB_SCBattleSpeed3 to JSON.
         * @function toJSON
         * @memberof PB_SCBattleSpeed3
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBattleSpeed3.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBattleSpeed3;
    })();
    
    $root.PB_SCAdPassInfo = (function() {
    
        /**
         * Properties of a PB_SCAdPassInfo.
         * @exports IPB_SCAdPassInfo
         * @interface IPB_SCAdPassInfo
         * @property {boolean|null} [isActive] PB_SCAdPassInfo isActive
         */
    
        /**
         * Constructs a new PB_SCAdPassInfo.
         * @exports PB_SCAdPassInfo
         * @classdesc Represents a PB_SCAdPassInfo.
         * @implements IPB_SCAdPassInfo
         * @constructor
         * @param {IPB_SCAdPassInfo=} [properties] Properties to set
         */
        function PB_SCAdPassInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCAdPassInfo isActive.
         * @member {boolean} isActive
         * @memberof PB_SCAdPassInfo
         * @instance
         */
        PB_SCAdPassInfo.prototype.isActive = false;
    
        /**
         * Creates a new PB_SCAdPassInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCAdPassInfo
         * @static
         * @param {IPB_SCAdPassInfo=} [properties] Properties to set
         * @returns {PB_SCAdPassInfo} PB_SCAdPassInfo instance
         */
        PB_SCAdPassInfo.create = function create(properties) {
            return new PB_SCAdPassInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCAdPassInfo message. Does not implicitly {@link PB_SCAdPassInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCAdPassInfo
         * @static
         * @param {IPB_SCAdPassInfo} message PB_SCAdPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAdPassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isActive);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCAdPassInfo message, length delimited. Does not implicitly {@link PB_SCAdPassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCAdPassInfo
         * @static
         * @param {IPB_SCAdPassInfo} message PB_SCAdPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCAdPassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCAdPassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCAdPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCAdPassInfo} PB_SCAdPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAdPassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCAdPassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCAdPassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCAdPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCAdPassInfo} PB_SCAdPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCAdPassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCAdPassInfo message.
         * @function verify
         * @memberof PB_SCAdPassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCAdPassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (typeof message.isActive !== "boolean")
                    return "isActive: boolean expected";
            return null;
        };
    
        /**
         * Creates a PB_SCAdPassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCAdPassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCAdPassInfo} PB_SCAdPassInfo
         */
        PB_SCAdPassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCAdPassInfo)
                return object;
            var message = new $root.PB_SCAdPassInfo();
            if (object.isActive != null)
                message.isActive = Boolean(object.isActive);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCAdPassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCAdPassInfo
         * @static
         * @param {PB_SCAdPassInfo} message PB_SCAdPassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCAdPassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isActive = false;
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            return object;
        };
    
        /**
         * Converts this PB_SCAdPassInfo to JSON.
         * @function toJSON
         * @memberof PB_SCAdPassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCAdPassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCAdPassInfo;
    })();
    
    $root.PB_CSMiningCaveReq = (function() {
    
        /**
         * Properties of a PB_CSMiningCaveReq.
         * @exports IPB_CSMiningCaveReq
         * @interface IPB_CSMiningCaveReq
         * @property {number|null} [opType] PB_CSMiningCaveReq opType
         * @property {number|null} [p1] PB_CSMiningCaveReq p1
         * @property {number|null} [p2] PB_CSMiningCaveReq p2
         */
    
        /**
         * Constructs a new PB_CSMiningCaveReq.
         * @exports PB_CSMiningCaveReq
         * @classdesc Represents a PB_CSMiningCaveReq.
         * @implements IPB_CSMiningCaveReq
         * @constructor
         * @param {IPB_CSMiningCaveReq=} [properties] Properties to set
         */
        function PB_CSMiningCaveReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSMiningCaveReq opType.
         * @member {number} opType
         * @memberof PB_CSMiningCaveReq
         * @instance
         */
        PB_CSMiningCaveReq.prototype.opType = 0;
    
        /**
         * PB_CSMiningCaveReq p1.
         * @member {number} p1
         * @memberof PB_CSMiningCaveReq
         * @instance
         */
        PB_CSMiningCaveReq.prototype.p1 = 0;
    
        /**
         * PB_CSMiningCaveReq p2.
         * @member {number} p2
         * @memberof PB_CSMiningCaveReq
         * @instance
         */
        PB_CSMiningCaveReq.prototype.p2 = 0;
    
        /**
         * Creates a new PB_CSMiningCaveReq instance using the specified properties.
         * @function create
         * @memberof PB_CSMiningCaveReq
         * @static
         * @param {IPB_CSMiningCaveReq=} [properties] Properties to set
         * @returns {PB_CSMiningCaveReq} PB_CSMiningCaveReq instance
         */
        PB_CSMiningCaveReq.create = function create(properties) {
            return new PB_CSMiningCaveReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSMiningCaveReq message. Does not implicitly {@link PB_CSMiningCaveReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSMiningCaveReq
         * @static
         * @param {IPB_CSMiningCaveReq} message PB_CSMiningCaveReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSMiningCaveReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.opType != null && Object.hasOwnProperty.call(message, "opType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.opType);
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.p1);
            if (message.p2 != null && Object.hasOwnProperty.call(message, "p2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.p2);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSMiningCaveReq message, length delimited. Does not implicitly {@link PB_CSMiningCaveReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSMiningCaveReq
         * @static
         * @param {IPB_CSMiningCaveReq} message PB_CSMiningCaveReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSMiningCaveReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSMiningCaveReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSMiningCaveReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSMiningCaveReq} PB_CSMiningCaveReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSMiningCaveReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSMiningCaveReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.opType = reader.int32();
                    break;
                case 2:
                    message.p1 = reader.int32();
                    break;
                case 3:
                    message.p2 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSMiningCaveReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSMiningCaveReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSMiningCaveReq} PB_CSMiningCaveReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSMiningCaveReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSMiningCaveReq message.
         * @function verify
         * @memberof PB_CSMiningCaveReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSMiningCaveReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.opType != null && message.hasOwnProperty("opType"))
                if (!$util.isInteger(message.opType))
                    return "opType: integer expected";
            if (message.p1 != null && message.hasOwnProperty("p1"))
                if (!$util.isInteger(message.p1))
                    return "p1: integer expected";
            if (message.p2 != null && message.hasOwnProperty("p2"))
                if (!$util.isInteger(message.p2))
                    return "p2: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSMiningCaveReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSMiningCaveReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSMiningCaveReq} PB_CSMiningCaveReq
         */
        PB_CSMiningCaveReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSMiningCaveReq)
                return object;
            var message = new $root.PB_CSMiningCaveReq();
            if (object.opType != null)
                message.opType = object.opType | 0;
            if (object.p1 != null)
                message.p1 = object.p1 | 0;
            if (object.p2 != null)
                message.p2 = object.p2 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSMiningCaveReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSMiningCaveReq
         * @static
         * @param {PB_CSMiningCaveReq} message PB_CSMiningCaveReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSMiningCaveReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.opType = 0;
                object.p1 = 0;
                object.p2 = 0;
            }
            if (message.opType != null && message.hasOwnProperty("opType"))
                object.opType = message.opType;
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = message.p1;
            if (message.p2 != null && message.hasOwnProperty("p2"))
                object.p2 = message.p2;
            return object;
        };
    
        /**
         * Converts this PB_CSMiningCaveReq to JSON.
         * @function toJSON
         * @memberof PB_CSMiningCaveReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSMiningCaveReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSMiningCaveReq;
    })();
    
    $root.PB_SCMiningCaveCold = (function() {
    
        /**
         * Properties of a PB_SCMiningCaveCold.
         * @exports IPB_SCMiningCaveCold
         * @interface IPB_SCMiningCaveCold
         * @property {number|null} [coldType] PB_SCMiningCaveCold coldType
         * @property {number|null} [excavateCount] PB_SCMiningCaveCold excavateCount
         */
    
        /**
         * Constructs a new PB_SCMiningCaveCold.
         * @exports PB_SCMiningCaveCold
         * @classdesc Represents a PB_SCMiningCaveCold.
         * @implements IPB_SCMiningCaveCold
         * @constructor
         * @param {IPB_SCMiningCaveCold=} [properties] Properties to set
         */
        function PB_SCMiningCaveCold(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCMiningCaveCold coldType.
         * @member {number} coldType
         * @memberof PB_SCMiningCaveCold
         * @instance
         */
        PB_SCMiningCaveCold.prototype.coldType = 0;
    
        /**
         * PB_SCMiningCaveCold excavateCount.
         * @member {number} excavateCount
         * @memberof PB_SCMiningCaveCold
         * @instance
         */
        PB_SCMiningCaveCold.prototype.excavateCount = 0;
    
        /**
         * Creates a new PB_SCMiningCaveCold instance using the specified properties.
         * @function create
         * @memberof PB_SCMiningCaveCold
         * @static
         * @param {IPB_SCMiningCaveCold=} [properties] Properties to set
         * @returns {PB_SCMiningCaveCold} PB_SCMiningCaveCold instance
         */
        PB_SCMiningCaveCold.create = function create(properties) {
            return new PB_SCMiningCaveCold(properties);
        };
    
        /**
         * Encodes the specified PB_SCMiningCaveCold message. Does not implicitly {@link PB_SCMiningCaveCold.verify|verify} messages.
         * @function encode
         * @memberof PB_SCMiningCaveCold
         * @static
         * @param {IPB_SCMiningCaveCold} message PB_SCMiningCaveCold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMiningCaveCold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.coldType != null && Object.hasOwnProperty.call(message, "coldType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.coldType);
            if (message.excavateCount != null && Object.hasOwnProperty.call(message, "excavateCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.excavateCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCMiningCaveCold message, length delimited. Does not implicitly {@link PB_SCMiningCaveCold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCMiningCaveCold
         * @static
         * @param {IPB_SCMiningCaveCold} message PB_SCMiningCaveCold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMiningCaveCold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCMiningCaveCold message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCMiningCaveCold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCMiningCaveCold} PB_SCMiningCaveCold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMiningCaveCold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCMiningCaveCold();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.coldType = reader.int32();
                    break;
                case 2:
                    message.excavateCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCMiningCaveCold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCMiningCaveCold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCMiningCaveCold} PB_SCMiningCaveCold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMiningCaveCold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCMiningCaveCold message.
         * @function verify
         * @memberof PB_SCMiningCaveCold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCMiningCaveCold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.coldType != null && message.hasOwnProperty("coldType"))
                if (!$util.isInteger(message.coldType))
                    return "coldType: integer expected";
            if (message.excavateCount != null && message.hasOwnProperty("excavateCount"))
                if (!$util.isInteger(message.excavateCount))
                    return "excavateCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCMiningCaveCold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCMiningCaveCold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCMiningCaveCold} PB_SCMiningCaveCold
         */
        PB_SCMiningCaveCold.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCMiningCaveCold)
                return object;
            var message = new $root.PB_SCMiningCaveCold();
            if (object.coldType != null)
                message.coldType = object.coldType | 0;
            if (object.excavateCount != null)
                message.excavateCount = object.excavateCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCMiningCaveCold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCMiningCaveCold
         * @static
         * @param {PB_SCMiningCaveCold} message PB_SCMiningCaveCold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCMiningCaveCold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.coldType = 0;
                object.excavateCount = 0;
            }
            if (message.coldType != null && message.hasOwnProperty("coldType"))
                object.coldType = message.coldType;
            if (message.excavateCount != null && message.hasOwnProperty("excavateCount"))
                object.excavateCount = message.excavateCount;
            return object;
        };
    
        /**
         * Converts this PB_SCMiningCaveCold to JSON.
         * @function toJSON
         * @memberof PB_SCMiningCaveCold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCMiningCaveCold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCMiningCaveCold;
    })();
    
    $root.PB_SCMiningCaveInfo = (function() {
    
        /**
         * Properties of a PB_SCMiningCaveInfo.
         * @exports IPB_SCMiningCaveInfo
         * @interface IPB_SCMiningCaveInfo
         * @property {number|Long|null} [excavateReplyTime] PB_SCMiningCaveInfo excavateReplyTime
         * @property {number|Long|null} [nowHigh] PB_SCMiningCaveInfo nowHigh
         * @property {Array.<IPB_SCMiningCaveCold>|null} [coldList] PB_SCMiningCaveInfo coldList
         * @property {Array.<boolean>|null} [metersReward] PB_SCMiningCaveInfo metersReward
         */
    
        /**
         * Constructs a new PB_SCMiningCaveInfo.
         * @exports PB_SCMiningCaveInfo
         * @classdesc Represents a PB_SCMiningCaveInfo.
         * @implements IPB_SCMiningCaveInfo
         * @constructor
         * @param {IPB_SCMiningCaveInfo=} [properties] Properties to set
         */
        function PB_SCMiningCaveInfo(properties) {
            this.coldList = [];
            this.metersReward = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCMiningCaveInfo excavateReplyTime.
         * @member {number|Long} excavateReplyTime
         * @memberof PB_SCMiningCaveInfo
         * @instance
         */
        PB_SCMiningCaveInfo.prototype.excavateReplyTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCMiningCaveInfo nowHigh.
         * @member {number|Long} nowHigh
         * @memberof PB_SCMiningCaveInfo
         * @instance
         */
        PB_SCMiningCaveInfo.prototype.nowHigh = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * PB_SCMiningCaveInfo coldList.
         * @member {Array.<IPB_SCMiningCaveCold>} coldList
         * @memberof PB_SCMiningCaveInfo
         * @instance
         */
        PB_SCMiningCaveInfo.prototype.coldList = $util.emptyArray;
    
        /**
         * PB_SCMiningCaveInfo metersReward.
         * @member {Array.<boolean>} metersReward
         * @memberof PB_SCMiningCaveInfo
         * @instance
         */
        PB_SCMiningCaveInfo.prototype.metersReward = $util.emptyArray;
    
        /**
         * Creates a new PB_SCMiningCaveInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCMiningCaveInfo
         * @static
         * @param {IPB_SCMiningCaveInfo=} [properties] Properties to set
         * @returns {PB_SCMiningCaveInfo} PB_SCMiningCaveInfo instance
         */
        PB_SCMiningCaveInfo.create = function create(properties) {
            return new PB_SCMiningCaveInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCMiningCaveInfo message. Does not implicitly {@link PB_SCMiningCaveInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCMiningCaveInfo
         * @static
         * @param {IPB_SCMiningCaveInfo} message PB_SCMiningCaveInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMiningCaveInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.excavateReplyTime != null && Object.hasOwnProperty.call(message, "excavateReplyTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.excavateReplyTime);
            if (message.nowHigh != null && Object.hasOwnProperty.call(message, "nowHigh"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nowHigh);
            if (message.coldList != null && message.coldList.length)
                for (var i = 0; i < message.coldList.length; ++i)
                    $root.PB_SCMiningCaveCold.encode(message.coldList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.metersReward != null && message.metersReward.length)
                for (var i = 0; i < message.metersReward.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.metersReward[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCMiningCaveInfo message, length delimited. Does not implicitly {@link PB_SCMiningCaveInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCMiningCaveInfo
         * @static
         * @param {IPB_SCMiningCaveInfo} message PB_SCMiningCaveInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCMiningCaveInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCMiningCaveInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCMiningCaveInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCMiningCaveInfo} PB_SCMiningCaveInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMiningCaveInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCMiningCaveInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.excavateReplyTime = reader.int64();
                    break;
                case 2:
                    message.nowHigh = reader.uint64();
                    break;
                case 3:
                    if (!(message.coldList && message.coldList.length))
                        message.coldList = [];
                    message.coldList.push($root.PB_SCMiningCaveCold.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.metersReward && message.metersReward.length))
                        message.metersReward = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.metersReward.push(reader.bool());
                    } else
                        message.metersReward.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCMiningCaveInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCMiningCaveInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCMiningCaveInfo} PB_SCMiningCaveInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCMiningCaveInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCMiningCaveInfo message.
         * @function verify
         * @memberof PB_SCMiningCaveInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCMiningCaveInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.excavateReplyTime != null && message.hasOwnProperty("excavateReplyTime"))
                if (!$util.isInteger(message.excavateReplyTime) && !(message.excavateReplyTime && $util.isInteger(message.excavateReplyTime.low) && $util.isInteger(message.excavateReplyTime.high)))
                    return "excavateReplyTime: integer|Long expected";
            if (message.nowHigh != null && message.hasOwnProperty("nowHigh"))
                if (!$util.isInteger(message.nowHigh) && !(message.nowHigh && $util.isInteger(message.nowHigh.low) && $util.isInteger(message.nowHigh.high)))
                    return "nowHigh: integer|Long expected";
            if (message.coldList != null && message.hasOwnProperty("coldList")) {
                if (!Array.isArray(message.coldList))
                    return "coldList: array expected";
                for (var i = 0; i < message.coldList.length; ++i) {
                    var error = $root.PB_SCMiningCaveCold.verify(message.coldList[i]);
                    if (error)
                        return "coldList." + error;
                }
            }
            if (message.metersReward != null && message.hasOwnProperty("metersReward")) {
                if (!Array.isArray(message.metersReward))
                    return "metersReward: array expected";
                for (var i = 0; i < message.metersReward.length; ++i)
                    if (typeof message.metersReward[i] !== "boolean")
                        return "metersReward: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCMiningCaveInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCMiningCaveInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCMiningCaveInfo} PB_SCMiningCaveInfo
         */
        PB_SCMiningCaveInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCMiningCaveInfo)
                return object;
            var message = new $root.PB_SCMiningCaveInfo();
            if (object.excavateReplyTime != null)
                if ($util.Long)
                    (message.excavateReplyTime = $util.Long.fromValue(object.excavateReplyTime)).unsigned = false;
                else if (typeof object.excavateReplyTime === "string")
                    message.excavateReplyTime = parseInt(object.excavateReplyTime, 10);
                else if (typeof object.excavateReplyTime === "number")
                    message.excavateReplyTime = object.excavateReplyTime;
                else if (typeof object.excavateReplyTime === "object")
                    message.excavateReplyTime = new $util.LongBits(object.excavateReplyTime.low >>> 0, object.excavateReplyTime.high >>> 0).toNumber();
            if (object.nowHigh != null)
                if ($util.Long)
                    (message.nowHigh = $util.Long.fromValue(object.nowHigh)).unsigned = true;
                else if (typeof object.nowHigh === "string")
                    message.nowHigh = parseInt(object.nowHigh, 10);
                else if (typeof object.nowHigh === "number")
                    message.nowHigh = object.nowHigh;
                else if (typeof object.nowHigh === "object")
                    message.nowHigh = new $util.LongBits(object.nowHigh.low >>> 0, object.nowHigh.high >>> 0).toNumber(true);
            if (object.coldList) {
                if (!Array.isArray(object.coldList))
                    throw TypeError(".PB_SCMiningCaveInfo.coldList: array expected");
                message.coldList = [];
                for (var i = 0; i < object.coldList.length; ++i) {
                    if (typeof object.coldList[i] !== "object")
                        throw TypeError(".PB_SCMiningCaveInfo.coldList: object expected");
                    message.coldList[i] = $root.PB_SCMiningCaveCold.fromObject(object.coldList[i]);
                }
            }
            if (object.metersReward) {
                if (!Array.isArray(object.metersReward))
                    throw TypeError(".PB_SCMiningCaveInfo.metersReward: array expected");
                message.metersReward = [];
                for (var i = 0; i < object.metersReward.length; ++i)
                    message.metersReward[i] = Boolean(object.metersReward[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCMiningCaveInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCMiningCaveInfo
         * @static
         * @param {PB_SCMiningCaveInfo} message PB_SCMiningCaveInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCMiningCaveInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.coldList = [];
                object.metersReward = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.excavateReplyTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.excavateReplyTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.nowHigh = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nowHigh = options.longs === String ? "0" : 0;
            }
            if (message.excavateReplyTime != null && message.hasOwnProperty("excavateReplyTime"))
                if (typeof message.excavateReplyTime === "number")
                    object.excavateReplyTime = options.longs === String ? String(message.excavateReplyTime) : message.excavateReplyTime;
                else
                    object.excavateReplyTime = options.longs === String ? $util.Long.prototype.toString.call(message.excavateReplyTime) : options.longs === Number ? new $util.LongBits(message.excavateReplyTime.low >>> 0, message.excavateReplyTime.high >>> 0).toNumber() : message.excavateReplyTime;
            if (message.nowHigh != null && message.hasOwnProperty("nowHigh"))
                if (typeof message.nowHigh === "number")
                    object.nowHigh = options.longs === String ? String(message.nowHigh) : message.nowHigh;
                else
                    object.nowHigh = options.longs === String ? $util.Long.prototype.toString.call(message.nowHigh) : options.longs === Number ? new $util.LongBits(message.nowHigh.low >>> 0, message.nowHigh.high >>> 0).toNumber(true) : message.nowHigh;
            if (message.coldList && message.coldList.length) {
                object.coldList = [];
                for (var j = 0; j < message.coldList.length; ++j)
                    object.coldList[j] = $root.PB_SCMiningCaveCold.toObject(message.coldList[j], options);
            }
            if (message.metersReward && message.metersReward.length) {
                object.metersReward = [];
                for (var j = 0; j < message.metersReward.length; ++j)
                    object.metersReward[j] = message.metersReward[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCMiningCaveInfo to JSON.
         * @function toJSON
         * @memberof PB_SCMiningCaveInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCMiningCaveInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCMiningCaveInfo;
    })();
    
    $root.PB_SCInstituteInfo = (function() {
    
        /**
         * Properties of a PB_SCInstituteInfo.
         * @exports IPB_SCInstituteInfo
         * @interface IPB_SCInstituteInfo
         * @property {Array.<number>|null} [talentLevel] PB_SCInstituteInfo talentLevel
         * @property {number|Long|null} [upTalentTime] PB_SCInstituteInfo upTalentTime
         * @property {number|null} [upTalentId] PB_SCInstituteInfo upTalentId
         */
    
        /**
         * Constructs a new PB_SCInstituteInfo.
         * @exports PB_SCInstituteInfo
         * @classdesc Represents a PB_SCInstituteInfo.
         * @implements IPB_SCInstituteInfo
         * @constructor
         * @param {IPB_SCInstituteInfo=} [properties] Properties to set
         */
        function PB_SCInstituteInfo(properties) {
            this.talentLevel = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCInstituteInfo talentLevel.
         * @member {Array.<number>} talentLevel
         * @memberof PB_SCInstituteInfo
         * @instance
         */
        PB_SCInstituteInfo.prototype.talentLevel = $util.emptyArray;
    
        /**
         * PB_SCInstituteInfo upTalentTime.
         * @member {number|Long} upTalentTime
         * @memberof PB_SCInstituteInfo
         * @instance
         */
        PB_SCInstituteInfo.prototype.upTalentTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCInstituteInfo upTalentId.
         * @member {number} upTalentId
         * @memberof PB_SCInstituteInfo
         * @instance
         */
        PB_SCInstituteInfo.prototype.upTalentId = 0;
    
        /**
         * Creates a new PB_SCInstituteInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCInstituteInfo
         * @static
         * @param {IPB_SCInstituteInfo=} [properties] Properties to set
         * @returns {PB_SCInstituteInfo} PB_SCInstituteInfo instance
         */
        PB_SCInstituteInfo.create = function create(properties) {
            return new PB_SCInstituteInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCInstituteInfo message. Does not implicitly {@link PB_SCInstituteInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCInstituteInfo
         * @static
         * @param {IPB_SCInstituteInfo} message PB_SCInstituteInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCInstituteInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.talentLevel != null && message.talentLevel.length)
                for (var i = 0; i < message.talentLevel.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.talentLevel[i]);
            if (message.upTalentTime != null && Object.hasOwnProperty.call(message, "upTalentTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.upTalentTime);
            if (message.upTalentId != null && Object.hasOwnProperty.call(message, "upTalentId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.upTalentId);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCInstituteInfo message, length delimited. Does not implicitly {@link PB_SCInstituteInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCInstituteInfo
         * @static
         * @param {IPB_SCInstituteInfo} message PB_SCInstituteInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCInstituteInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCInstituteInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCInstituteInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCInstituteInfo} PB_SCInstituteInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCInstituteInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCInstituteInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.talentLevel && message.talentLevel.length))
                        message.talentLevel = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.talentLevel.push(reader.int32());
                    } else
                        message.talentLevel.push(reader.int32());
                    break;
                case 2:
                    message.upTalentTime = reader.int64();
                    break;
                case 3:
                    message.upTalentId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCInstituteInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCInstituteInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCInstituteInfo} PB_SCInstituteInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCInstituteInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCInstituteInfo message.
         * @function verify
         * @memberof PB_SCInstituteInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCInstituteInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.talentLevel != null && message.hasOwnProperty("talentLevel")) {
                if (!Array.isArray(message.talentLevel))
                    return "talentLevel: array expected";
                for (var i = 0; i < message.talentLevel.length; ++i)
                    if (!$util.isInteger(message.talentLevel[i]))
                        return "talentLevel: integer[] expected";
            }
            if (message.upTalentTime != null && message.hasOwnProperty("upTalentTime"))
                if (!$util.isInteger(message.upTalentTime) && !(message.upTalentTime && $util.isInteger(message.upTalentTime.low) && $util.isInteger(message.upTalentTime.high)))
                    return "upTalentTime: integer|Long expected";
            if (message.upTalentId != null && message.hasOwnProperty("upTalentId"))
                if (!$util.isInteger(message.upTalentId))
                    return "upTalentId: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCInstituteInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCInstituteInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCInstituteInfo} PB_SCInstituteInfo
         */
        PB_SCInstituteInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCInstituteInfo)
                return object;
            var message = new $root.PB_SCInstituteInfo();
            if (object.talentLevel) {
                if (!Array.isArray(object.talentLevel))
                    throw TypeError(".PB_SCInstituteInfo.talentLevel: array expected");
                message.talentLevel = [];
                for (var i = 0; i < object.talentLevel.length; ++i)
                    message.talentLevel[i] = object.talentLevel[i] | 0;
            }
            if (object.upTalentTime != null)
                if ($util.Long)
                    (message.upTalentTime = $util.Long.fromValue(object.upTalentTime)).unsigned = false;
                else if (typeof object.upTalentTime === "string")
                    message.upTalentTime = parseInt(object.upTalentTime, 10);
                else if (typeof object.upTalentTime === "number")
                    message.upTalentTime = object.upTalentTime;
                else if (typeof object.upTalentTime === "object")
                    message.upTalentTime = new $util.LongBits(object.upTalentTime.low >>> 0, object.upTalentTime.high >>> 0).toNumber();
            if (object.upTalentId != null)
                message.upTalentId = object.upTalentId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCInstituteInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCInstituteInfo
         * @static
         * @param {PB_SCInstituteInfo} message PB_SCInstituteInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCInstituteInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.talentLevel = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.upTalentTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.upTalentTime = options.longs === String ? "0" : 0;
                object.upTalentId = 0;
            }
            if (message.talentLevel && message.talentLevel.length) {
                object.talentLevel = [];
                for (var j = 0; j < message.talentLevel.length; ++j)
                    object.talentLevel[j] = message.talentLevel[j];
            }
            if (message.upTalentTime != null && message.hasOwnProperty("upTalentTime"))
                if (typeof message.upTalentTime === "number")
                    object.upTalentTime = options.longs === String ? String(message.upTalentTime) : message.upTalentTime;
                else
                    object.upTalentTime = options.longs === String ? $util.Long.prototype.toString.call(message.upTalentTime) : options.longs === Number ? new $util.LongBits(message.upTalentTime.low >>> 0, message.upTalentTime.high >>> 0).toNumber() : message.upTalentTime;
            if (message.upTalentId != null && message.hasOwnProperty("upTalentId"))
                object.upTalentId = message.upTalentId;
            return object;
        };
    
        /**
         * Converts this PB_SCInstituteInfo to JSON.
         * @function toJSON
         * @memberof PB_SCInstituteInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCInstituteInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCInstituteInfo;
    })();
    
    $root.PB_SCHerotrialInfo = (function() {
    
        /**
         * Properties of a PB_SCHerotrialInfo.
         * @exports IPB_SCHerotrialInfo
         * @interface IPB_SCHerotrialInfo
         * @property {Array.<boolean>|null} [isFetch] PB_SCHerotrialInfo isFetch
         */
    
        /**
         * Constructs a new PB_SCHerotrialInfo.
         * @exports PB_SCHerotrialInfo
         * @classdesc Represents a PB_SCHerotrialInfo.
         * @implements IPB_SCHerotrialInfo
         * @constructor
         * @param {IPB_SCHerotrialInfo=} [properties] Properties to set
         */
        function PB_SCHerotrialInfo(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCHerotrialInfo isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCHerotrialInfo
         * @instance
         */
        PB_SCHerotrialInfo.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCHerotrialInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCHerotrialInfo
         * @static
         * @param {IPB_SCHerotrialInfo=} [properties] Properties to set
         * @returns {PB_SCHerotrialInfo} PB_SCHerotrialInfo instance
         */
        PB_SCHerotrialInfo.create = function create(properties) {
            return new PB_SCHerotrialInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCHerotrialInfo message. Does not implicitly {@link PB_SCHerotrialInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCHerotrialInfo
         * @static
         * @param {IPB_SCHerotrialInfo} message PB_SCHerotrialInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHerotrialInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCHerotrialInfo message, length delimited. Does not implicitly {@link PB_SCHerotrialInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCHerotrialInfo
         * @static
         * @param {IPB_SCHerotrialInfo} message PB_SCHerotrialInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHerotrialInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCHerotrialInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCHerotrialInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCHerotrialInfo} PB_SCHerotrialInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHerotrialInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCHerotrialInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCHerotrialInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCHerotrialInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCHerotrialInfo} PB_SCHerotrialInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHerotrialInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCHerotrialInfo message.
         * @function verify
         * @memberof PB_SCHerotrialInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCHerotrialInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCHerotrialInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCHerotrialInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCHerotrialInfo} PB_SCHerotrialInfo
         */
        PB_SCHerotrialInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCHerotrialInfo)
                return object;
            var message = new $root.PB_SCHerotrialInfo();
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCHerotrialInfo.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCHerotrialInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCHerotrialInfo
         * @static
         * @param {PB_SCHerotrialInfo} message PB_SCHerotrialInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCHerotrialInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCHerotrialInfo to JSON.
         * @function toJSON
         * @memberof PB_SCHerotrialInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCHerotrialInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCHerotrialInfo;
    })();
    
    $root.PB_CSGameCircleReq = (function() {
    
        /**
         * Properties of a PB_CSGameCircleReq.
         * @exports IPB_CSGameCircleReq
         * @interface IPB_CSGameCircleReq
         * @property {number|null} [reqType] PB_CSGameCircleReq reqType
         * @property {Array.<number>|null} [reqParam] PB_CSGameCircleReq reqParam
         */
    
        /**
         * Constructs a new PB_CSGameCircleReq.
         * @exports PB_CSGameCircleReq
         * @classdesc Represents a PB_CSGameCircleReq.
         * @implements IPB_CSGameCircleReq
         * @constructor
         * @param {IPB_CSGameCircleReq=} [properties] Properties to set
         */
        function PB_CSGameCircleReq(properties) {
            this.reqParam = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSGameCircleReq reqType.
         * @member {number} reqType
         * @memberof PB_CSGameCircleReq
         * @instance
         */
        PB_CSGameCircleReq.prototype.reqType = 0;
    
        /**
         * PB_CSGameCircleReq reqParam.
         * @member {Array.<number>} reqParam
         * @memberof PB_CSGameCircleReq
         * @instance
         */
        PB_CSGameCircleReq.prototype.reqParam = $util.emptyArray;
    
        /**
         * Creates a new PB_CSGameCircleReq instance using the specified properties.
         * @function create
         * @memberof PB_CSGameCircleReq
         * @static
         * @param {IPB_CSGameCircleReq=} [properties] Properties to set
         * @returns {PB_CSGameCircleReq} PB_CSGameCircleReq instance
         */
        PB_CSGameCircleReq.create = function create(properties) {
            return new PB_CSGameCircleReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSGameCircleReq message. Does not implicitly {@link PB_CSGameCircleReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSGameCircleReq
         * @static
         * @param {IPB_CSGameCircleReq} message PB_CSGameCircleReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGameCircleReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.reqParam != null && message.reqParam.length)
                for (var i = 0; i < message.reqParam.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reqParam[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSGameCircleReq message, length delimited. Does not implicitly {@link PB_CSGameCircleReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSGameCircleReq
         * @static
         * @param {IPB_CSGameCircleReq} message PB_CSGameCircleReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSGameCircleReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSGameCircleReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSGameCircleReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSGameCircleReq} PB_CSGameCircleReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGameCircleReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSGameCircleReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    if (!(message.reqParam && message.reqParam.length))
                        message.reqParam = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.reqParam.push(reader.int32());
                    } else
                        message.reqParam.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSGameCircleReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSGameCircleReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSGameCircleReq} PB_CSGameCircleReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSGameCircleReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSGameCircleReq message.
         * @function verify
         * @memberof PB_CSGameCircleReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSGameCircleReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.reqParam != null && message.hasOwnProperty("reqParam")) {
                if (!Array.isArray(message.reqParam))
                    return "reqParam: array expected";
                for (var i = 0; i < message.reqParam.length; ++i)
                    if (!$util.isInteger(message.reqParam[i]))
                        return "reqParam: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSGameCircleReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSGameCircleReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSGameCircleReq} PB_CSGameCircleReq
         */
        PB_CSGameCircleReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSGameCircleReq)
                return object;
            var message = new $root.PB_CSGameCircleReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.reqParam) {
                if (!Array.isArray(object.reqParam))
                    throw TypeError(".PB_CSGameCircleReq.reqParam: array expected");
                message.reqParam = [];
                for (var i = 0; i < object.reqParam.length; ++i)
                    message.reqParam[i] = object.reqParam[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSGameCircleReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSGameCircleReq
         * @static
         * @param {PB_CSGameCircleReq} message PB_CSGameCircleReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSGameCircleReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reqParam = [];
            if (options.defaults)
                object.reqType = 0;
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.reqParam && message.reqParam.length) {
                object.reqParam = [];
                for (var j = 0; j < message.reqParam.length; ++j)
                    object.reqParam[j] = message.reqParam[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSGameCircleReq to JSON.
         * @function toJSON
         * @memberof PB_CSGameCircleReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSGameCircleReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSGameCircleReq;
    })();
    
    $root.PB_SCGameCircleInfo = (function() {
    
        /**
         * Properties of a PB_SCGameCircleInfo.
         * @exports IPB_SCGameCircleInfo
         * @interface IPB_SCGameCircleInfo
         * @property {boolean|null} [todaySignIn] PB_SCGameCircleInfo todaySignIn
         * @property {boolean|null} [newReward] PB_SCGameCircleInfo newReward
         * @property {number|null} [signCount] PB_SCGameCircleInfo signCount
         * @property {number|null} [likeCount] PB_SCGameCircleInfo likeCount
         */
    
        /**
         * Constructs a new PB_SCGameCircleInfo.
         * @exports PB_SCGameCircleInfo
         * @classdesc Represents a PB_SCGameCircleInfo.
         * @implements IPB_SCGameCircleInfo
         * @constructor
         * @param {IPB_SCGameCircleInfo=} [properties] Properties to set
         */
        function PB_SCGameCircleInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCGameCircleInfo todaySignIn.
         * @member {boolean} todaySignIn
         * @memberof PB_SCGameCircleInfo
         * @instance
         */
        PB_SCGameCircleInfo.prototype.todaySignIn = false;
    
        /**
         * PB_SCGameCircleInfo newReward.
         * @member {boolean} newReward
         * @memberof PB_SCGameCircleInfo
         * @instance
         */
        PB_SCGameCircleInfo.prototype.newReward = false;
    
        /**
         * PB_SCGameCircleInfo signCount.
         * @member {number} signCount
         * @memberof PB_SCGameCircleInfo
         * @instance
         */
        PB_SCGameCircleInfo.prototype.signCount = 0;
    
        /**
         * PB_SCGameCircleInfo likeCount.
         * @member {number} likeCount
         * @memberof PB_SCGameCircleInfo
         * @instance
         */
        PB_SCGameCircleInfo.prototype.likeCount = 0;
    
        /**
         * Creates a new PB_SCGameCircleInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCGameCircleInfo
         * @static
         * @param {IPB_SCGameCircleInfo=} [properties] Properties to set
         * @returns {PB_SCGameCircleInfo} PB_SCGameCircleInfo instance
         */
        PB_SCGameCircleInfo.create = function create(properties) {
            return new PB_SCGameCircleInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCGameCircleInfo message. Does not implicitly {@link PB_SCGameCircleInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCGameCircleInfo
         * @static
         * @param {IPB_SCGameCircleInfo} message PB_SCGameCircleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGameCircleInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.todaySignIn != null && Object.hasOwnProperty.call(message, "todaySignIn"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.todaySignIn);
            if (message.newReward != null && Object.hasOwnProperty.call(message, "newReward"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.newReward);
            if (message.signCount != null && Object.hasOwnProperty.call(message, "signCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.signCount);
            if (message.likeCount != null && Object.hasOwnProperty.call(message, "likeCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.likeCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCGameCircleInfo message, length delimited. Does not implicitly {@link PB_SCGameCircleInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCGameCircleInfo
         * @static
         * @param {IPB_SCGameCircleInfo} message PB_SCGameCircleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCGameCircleInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCGameCircleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCGameCircleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCGameCircleInfo} PB_SCGameCircleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGameCircleInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCGameCircleInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.todaySignIn = reader.bool();
                    break;
                case 2:
                    message.newReward = reader.bool();
                    break;
                case 3:
                    message.signCount = reader.int32();
                    break;
                case 4:
                    message.likeCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCGameCircleInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCGameCircleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCGameCircleInfo} PB_SCGameCircleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCGameCircleInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCGameCircleInfo message.
         * @function verify
         * @memberof PB_SCGameCircleInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCGameCircleInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.todaySignIn != null && message.hasOwnProperty("todaySignIn"))
                if (typeof message.todaySignIn !== "boolean")
                    return "todaySignIn: boolean expected";
            if (message.newReward != null && message.hasOwnProperty("newReward"))
                if (typeof message.newReward !== "boolean")
                    return "newReward: boolean expected";
            if (message.signCount != null && message.hasOwnProperty("signCount"))
                if (!$util.isInteger(message.signCount))
                    return "signCount: integer expected";
            if (message.likeCount != null && message.hasOwnProperty("likeCount"))
                if (!$util.isInteger(message.likeCount))
                    return "likeCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCGameCircleInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCGameCircleInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCGameCircleInfo} PB_SCGameCircleInfo
         */
        PB_SCGameCircleInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCGameCircleInfo)
                return object;
            var message = new $root.PB_SCGameCircleInfo();
            if (object.todaySignIn != null)
                message.todaySignIn = Boolean(object.todaySignIn);
            if (object.newReward != null)
                message.newReward = Boolean(object.newReward);
            if (object.signCount != null)
                message.signCount = object.signCount | 0;
            if (object.likeCount != null)
                message.likeCount = object.likeCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCGameCircleInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCGameCircleInfo
         * @static
         * @param {PB_SCGameCircleInfo} message PB_SCGameCircleInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCGameCircleInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.todaySignIn = false;
                object.newReward = false;
                object.signCount = 0;
                object.likeCount = 0;
            }
            if (message.todaySignIn != null && message.hasOwnProperty("todaySignIn"))
                object.todaySignIn = message.todaySignIn;
            if (message.newReward != null && message.hasOwnProperty("newReward"))
                object.newReward = message.newReward;
            if (message.signCount != null && message.hasOwnProperty("signCount"))
                object.signCount = message.signCount;
            if (message.likeCount != null && message.hasOwnProperty("likeCount"))
                object.likeCount = message.likeCount;
            return object;
        };
    
        /**
         * Converts this PB_SCGameCircleInfo to JSON.
         * @function toJSON
         * @memberof PB_SCGameCircleInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCGameCircleInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCGameCircleInfo;
    })();
    
    $root.PB_CSHorcruxesReq = (function() {
    
        /**
         * Properties of a PB_CSHorcruxesReq.
         * @exports IPB_CSHorcruxesReq
         * @interface IPB_CSHorcruxesReq
         * @property {number|null} [reqType] PB_CSHorcruxesReq reqType
         * @property {Array.<number>|null} [reqParam] PB_CSHorcruxesReq reqParam
         */
    
        /**
         * Constructs a new PB_CSHorcruxesReq.
         * @exports PB_CSHorcruxesReq
         * @classdesc Represents a PB_CSHorcruxesReq.
         * @implements IPB_CSHorcruxesReq
         * @constructor
         * @param {IPB_CSHorcruxesReq=} [properties] Properties to set
         */
        function PB_CSHorcruxesReq(properties) {
            this.reqParam = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSHorcruxesReq reqType.
         * @member {number} reqType
         * @memberof PB_CSHorcruxesReq
         * @instance
         */
        PB_CSHorcruxesReq.prototype.reqType = 0;
    
        /**
         * PB_CSHorcruxesReq reqParam.
         * @member {Array.<number>} reqParam
         * @memberof PB_CSHorcruxesReq
         * @instance
         */
        PB_CSHorcruxesReq.prototype.reqParam = $util.emptyArray;
    
        /**
         * Creates a new PB_CSHorcruxesReq instance using the specified properties.
         * @function create
         * @memberof PB_CSHorcruxesReq
         * @static
         * @param {IPB_CSHorcruxesReq=} [properties] Properties to set
         * @returns {PB_CSHorcruxesReq} PB_CSHorcruxesReq instance
         */
        PB_CSHorcruxesReq.create = function create(properties) {
            return new PB_CSHorcruxesReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSHorcruxesReq message. Does not implicitly {@link PB_CSHorcruxesReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSHorcruxesReq
         * @static
         * @param {IPB_CSHorcruxesReq} message PB_CSHorcruxesReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSHorcruxesReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.reqParam != null && message.reqParam.length)
                for (var i = 0; i < message.reqParam.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reqParam[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSHorcruxesReq message, length delimited. Does not implicitly {@link PB_CSHorcruxesReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSHorcruxesReq
         * @static
         * @param {IPB_CSHorcruxesReq} message PB_CSHorcruxesReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSHorcruxesReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSHorcruxesReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSHorcruxesReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSHorcruxesReq} PB_CSHorcruxesReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSHorcruxesReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSHorcruxesReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    if (!(message.reqParam && message.reqParam.length))
                        message.reqParam = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.reqParam.push(reader.int32());
                    } else
                        message.reqParam.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSHorcruxesReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSHorcruxesReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSHorcruxesReq} PB_CSHorcruxesReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSHorcruxesReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSHorcruxesReq message.
         * @function verify
         * @memberof PB_CSHorcruxesReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSHorcruxesReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.reqParam != null && message.hasOwnProperty("reqParam")) {
                if (!Array.isArray(message.reqParam))
                    return "reqParam: array expected";
                for (var i = 0; i < message.reqParam.length; ++i)
                    if (!$util.isInteger(message.reqParam[i]))
                        return "reqParam: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSHorcruxesReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSHorcruxesReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSHorcruxesReq} PB_CSHorcruxesReq
         */
        PB_CSHorcruxesReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSHorcruxesReq)
                return object;
            var message = new $root.PB_CSHorcruxesReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.reqParam) {
                if (!Array.isArray(object.reqParam))
                    throw TypeError(".PB_CSHorcruxesReq.reqParam: array expected");
                message.reqParam = [];
                for (var i = 0; i < object.reqParam.length; ++i)
                    message.reqParam[i] = object.reqParam[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSHorcruxesReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSHorcruxesReq
         * @static
         * @param {PB_CSHorcruxesReq} message PB_CSHorcruxesReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSHorcruxesReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reqParam = [];
            if (options.defaults)
                object.reqType = 0;
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.reqParam && message.reqParam.length) {
                object.reqParam = [];
                for (var j = 0; j < message.reqParam.length; ++j)
                    object.reqParam[j] = message.reqParam[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSHorcruxesReq to JSON.
         * @function toJSON
         * @memberof PB_CSHorcruxesReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSHorcruxesReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSHorcruxesReq;
    })();
    
    $root.PB_SCHorcruxesGift = (function() {
    
        /**
         * Properties of a PB_SCHorcruxesGift.
         * @exports IPB_SCHorcruxesGift
         * @interface IPB_SCHorcruxesGift
         * @property {number|null} [seq] PB_SCHorcruxesGift seq
         * @property {number|Long|null} [endTime] PB_SCHorcruxesGift endTime
         */
    
        /**
         * Constructs a new PB_SCHorcruxesGift.
         * @exports PB_SCHorcruxesGift
         * @classdesc Represents a PB_SCHorcruxesGift.
         * @implements IPB_SCHorcruxesGift
         * @constructor
         * @param {IPB_SCHorcruxesGift=} [properties] Properties to set
         */
        function PB_SCHorcruxesGift(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCHorcruxesGift seq.
         * @member {number} seq
         * @memberof PB_SCHorcruxesGift
         * @instance
         */
        PB_SCHorcruxesGift.prototype.seq = 0;
    
        /**
         * PB_SCHorcruxesGift endTime.
         * @member {number|Long} endTime
         * @memberof PB_SCHorcruxesGift
         * @instance
         */
        PB_SCHorcruxesGift.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCHorcruxesGift instance using the specified properties.
         * @function create
         * @memberof PB_SCHorcruxesGift
         * @static
         * @param {IPB_SCHorcruxesGift=} [properties] Properties to set
         * @returns {PB_SCHorcruxesGift} PB_SCHorcruxesGift instance
         */
        PB_SCHorcruxesGift.create = function create(properties) {
            return new PB_SCHorcruxesGift(properties);
        };
    
        /**
         * Encodes the specified PB_SCHorcruxesGift message. Does not implicitly {@link PB_SCHorcruxesGift.verify|verify} messages.
         * @function encode
         * @memberof PB_SCHorcruxesGift
         * @static
         * @param {IPB_SCHorcruxesGift} message PB_SCHorcruxesGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHorcruxesGift.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCHorcruxesGift message, length delimited. Does not implicitly {@link PB_SCHorcruxesGift.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCHorcruxesGift
         * @static
         * @param {IPB_SCHorcruxesGift} message PB_SCHorcruxesGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHorcruxesGift.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCHorcruxesGift message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCHorcruxesGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCHorcruxesGift} PB_SCHorcruxesGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHorcruxesGift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCHorcruxesGift();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    message.endTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCHorcruxesGift message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCHorcruxesGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCHorcruxesGift} PB_SCHorcruxesGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHorcruxesGift.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCHorcruxesGift message.
         * @function verify
         * @memberof PB_SCHorcruxesGift
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCHorcruxesGift.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCHorcruxesGift message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCHorcruxesGift
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCHorcruxesGift} PB_SCHorcruxesGift
         */
        PB_SCHorcruxesGift.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCHorcruxesGift)
                return object;
            var message = new $root.PB_SCHorcruxesGift();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCHorcruxesGift message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCHorcruxesGift
         * @static
         * @param {PB_SCHorcruxesGift} message PB_SCHorcruxesGift
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCHorcruxesGift.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.seq = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTime = options.longs === String ? "0" : 0;
            }
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (typeof message.endTime === "number")
                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                else
                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
            return object;
        };
    
        /**
         * Converts this PB_SCHorcruxesGift to JSON.
         * @function toJSON
         * @memberof PB_SCHorcruxesGift
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCHorcruxesGift.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCHorcruxesGift;
    })();
    
    $root.PB_SCHorcruxesInfo = (function() {
    
        /**
         * Properties of a PB_SCHorcruxesInfo.
         * @exports IPB_SCHorcruxesInfo
         * @interface IPB_SCHorcruxesInfo
         * @property {Array.<boolean>|null} [drawTimesReward] PB_SCHorcruxesInfo drawTimesReward
         * @property {Array.<number>|null} [shopBuyCount] PB_SCHorcruxesInfo shopBuyCount
         * @property {Array.<IPB_SCHorcruxesGift>|null} [giftList] PB_SCHorcruxesInfo giftList
         * @property {number|null} [drawCount] PB_SCHorcruxesInfo drawCount
         */
    
        /**
         * Constructs a new PB_SCHorcruxesInfo.
         * @exports PB_SCHorcruxesInfo
         * @classdesc Represents a PB_SCHorcruxesInfo.
         * @implements IPB_SCHorcruxesInfo
         * @constructor
         * @param {IPB_SCHorcruxesInfo=} [properties] Properties to set
         */
        function PB_SCHorcruxesInfo(properties) {
            this.drawTimesReward = [];
            this.shopBuyCount = [];
            this.giftList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCHorcruxesInfo drawTimesReward.
         * @member {Array.<boolean>} drawTimesReward
         * @memberof PB_SCHorcruxesInfo
         * @instance
         */
        PB_SCHorcruxesInfo.prototype.drawTimesReward = $util.emptyArray;
    
        /**
         * PB_SCHorcruxesInfo shopBuyCount.
         * @member {Array.<number>} shopBuyCount
         * @memberof PB_SCHorcruxesInfo
         * @instance
         */
        PB_SCHorcruxesInfo.prototype.shopBuyCount = $util.emptyArray;
    
        /**
         * PB_SCHorcruxesInfo giftList.
         * @member {Array.<IPB_SCHorcruxesGift>} giftList
         * @memberof PB_SCHorcruxesInfo
         * @instance
         */
        PB_SCHorcruxesInfo.prototype.giftList = $util.emptyArray;
    
        /**
         * PB_SCHorcruxesInfo drawCount.
         * @member {number} drawCount
         * @memberof PB_SCHorcruxesInfo
         * @instance
         */
        PB_SCHorcruxesInfo.prototype.drawCount = 0;
    
        /**
         * Creates a new PB_SCHorcruxesInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCHorcruxesInfo
         * @static
         * @param {IPB_SCHorcruxesInfo=} [properties] Properties to set
         * @returns {PB_SCHorcruxesInfo} PB_SCHorcruxesInfo instance
         */
        PB_SCHorcruxesInfo.create = function create(properties) {
            return new PB_SCHorcruxesInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCHorcruxesInfo message. Does not implicitly {@link PB_SCHorcruxesInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCHorcruxesInfo
         * @static
         * @param {IPB_SCHorcruxesInfo} message PB_SCHorcruxesInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHorcruxesInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.drawTimesReward != null && message.drawTimesReward.length)
                for (var i = 0; i < message.drawTimesReward.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.drawTimesReward[i]);
            if (message.shopBuyCount != null && message.shopBuyCount.length)
                for (var i = 0; i < message.shopBuyCount.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.shopBuyCount[i]);
            if (message.giftList != null && message.giftList.length)
                for (var i = 0; i < message.giftList.length; ++i)
                    $root.PB_SCHorcruxesGift.encode(message.giftList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.drawCount != null && Object.hasOwnProperty.call(message, "drawCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.drawCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCHorcruxesInfo message, length delimited. Does not implicitly {@link PB_SCHorcruxesInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCHorcruxesInfo
         * @static
         * @param {IPB_SCHorcruxesInfo} message PB_SCHorcruxesInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHorcruxesInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCHorcruxesInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCHorcruxesInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCHorcruxesInfo} PB_SCHorcruxesInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHorcruxesInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCHorcruxesInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.drawTimesReward && message.drawTimesReward.length))
                        message.drawTimesReward = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.drawTimesReward.push(reader.bool());
                    } else
                        message.drawTimesReward.push(reader.bool());
                    break;
                case 2:
                    if (!(message.shopBuyCount && message.shopBuyCount.length))
                        message.shopBuyCount = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shopBuyCount.push(reader.int32());
                    } else
                        message.shopBuyCount.push(reader.int32());
                    break;
                case 3:
                    if (!(message.giftList && message.giftList.length))
                        message.giftList = [];
                    message.giftList.push($root.PB_SCHorcruxesGift.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.drawCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCHorcruxesInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCHorcruxesInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCHorcruxesInfo} PB_SCHorcruxesInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHorcruxesInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCHorcruxesInfo message.
         * @function verify
         * @memberof PB_SCHorcruxesInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCHorcruxesInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.drawTimesReward != null && message.hasOwnProperty("drawTimesReward")) {
                if (!Array.isArray(message.drawTimesReward))
                    return "drawTimesReward: array expected";
                for (var i = 0; i < message.drawTimesReward.length; ++i)
                    if (typeof message.drawTimesReward[i] !== "boolean")
                        return "drawTimesReward: boolean[] expected";
            }
            if (message.shopBuyCount != null && message.hasOwnProperty("shopBuyCount")) {
                if (!Array.isArray(message.shopBuyCount))
                    return "shopBuyCount: array expected";
                for (var i = 0; i < message.shopBuyCount.length; ++i)
                    if (!$util.isInteger(message.shopBuyCount[i]))
                        return "shopBuyCount: integer[] expected";
            }
            if (message.giftList != null && message.hasOwnProperty("giftList")) {
                if (!Array.isArray(message.giftList))
                    return "giftList: array expected";
                for (var i = 0; i < message.giftList.length; ++i) {
                    var error = $root.PB_SCHorcruxesGift.verify(message.giftList[i]);
                    if (error)
                        return "giftList." + error;
                }
            }
            if (message.drawCount != null && message.hasOwnProperty("drawCount"))
                if (!$util.isInteger(message.drawCount))
                    return "drawCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCHorcruxesInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCHorcruxesInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCHorcruxesInfo} PB_SCHorcruxesInfo
         */
        PB_SCHorcruxesInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCHorcruxesInfo)
                return object;
            var message = new $root.PB_SCHorcruxesInfo();
            if (object.drawTimesReward) {
                if (!Array.isArray(object.drawTimesReward))
                    throw TypeError(".PB_SCHorcruxesInfo.drawTimesReward: array expected");
                message.drawTimesReward = [];
                for (var i = 0; i < object.drawTimesReward.length; ++i)
                    message.drawTimesReward[i] = Boolean(object.drawTimesReward[i]);
            }
            if (object.shopBuyCount) {
                if (!Array.isArray(object.shopBuyCount))
                    throw TypeError(".PB_SCHorcruxesInfo.shopBuyCount: array expected");
                message.shopBuyCount = [];
                for (var i = 0; i < object.shopBuyCount.length; ++i)
                    message.shopBuyCount[i] = object.shopBuyCount[i] | 0;
            }
            if (object.giftList) {
                if (!Array.isArray(object.giftList))
                    throw TypeError(".PB_SCHorcruxesInfo.giftList: array expected");
                message.giftList = [];
                for (var i = 0; i < object.giftList.length; ++i) {
                    if (typeof object.giftList[i] !== "object")
                        throw TypeError(".PB_SCHorcruxesInfo.giftList: object expected");
                    message.giftList[i] = $root.PB_SCHorcruxesGift.fromObject(object.giftList[i]);
                }
            }
            if (object.drawCount != null)
                message.drawCount = object.drawCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCHorcruxesInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCHorcruxesInfo
         * @static
         * @param {PB_SCHorcruxesInfo} message PB_SCHorcruxesInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCHorcruxesInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.drawTimesReward = [];
                object.shopBuyCount = [];
                object.giftList = [];
            }
            if (options.defaults)
                object.drawCount = 0;
            if (message.drawTimesReward && message.drawTimesReward.length) {
                object.drawTimesReward = [];
                for (var j = 0; j < message.drawTimesReward.length; ++j)
                    object.drawTimesReward[j] = message.drawTimesReward[j];
            }
            if (message.shopBuyCount && message.shopBuyCount.length) {
                object.shopBuyCount = [];
                for (var j = 0; j < message.shopBuyCount.length; ++j)
                    object.shopBuyCount[j] = message.shopBuyCount[j];
            }
            if (message.giftList && message.giftList.length) {
                object.giftList = [];
                for (var j = 0; j < message.giftList.length; ++j)
                    object.giftList[j] = $root.PB_SCHorcruxesGift.toObject(message.giftList[j], options);
            }
            if (message.drawCount != null && message.hasOwnProperty("drawCount"))
                object.drawCount = message.drawCount;
            return object;
        };
    
        /**
         * Converts this PB_SCHorcruxesInfo to JSON.
         * @function toJSON
         * @memberof PB_SCHorcruxesInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCHorcruxesInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCHorcruxesInfo;
    })();
    
    $root.PB_SCHorcruxesRet = (function() {
    
        /**
         * Properties of a PB_SCHorcruxesRet.
         * @exports IPB_SCHorcruxesRet
         * @interface IPB_SCHorcruxesRet
         * @property {number|null} [retType] PB_SCHorcruxesRet retType
         * @property {Array.<number>|null} [retParam] PB_SCHorcruxesRet retParam
         */
    
        /**
         * Constructs a new PB_SCHorcruxesRet.
         * @exports PB_SCHorcruxesRet
         * @classdesc Represents a PB_SCHorcruxesRet.
         * @implements IPB_SCHorcruxesRet
         * @constructor
         * @param {IPB_SCHorcruxesRet=} [properties] Properties to set
         */
        function PB_SCHorcruxesRet(properties) {
            this.retParam = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCHorcruxesRet retType.
         * @member {number} retType
         * @memberof PB_SCHorcruxesRet
         * @instance
         */
        PB_SCHorcruxesRet.prototype.retType = 0;
    
        /**
         * PB_SCHorcruxesRet retParam.
         * @member {Array.<number>} retParam
         * @memberof PB_SCHorcruxesRet
         * @instance
         */
        PB_SCHorcruxesRet.prototype.retParam = $util.emptyArray;
    
        /**
         * Creates a new PB_SCHorcruxesRet instance using the specified properties.
         * @function create
         * @memberof PB_SCHorcruxesRet
         * @static
         * @param {IPB_SCHorcruxesRet=} [properties] Properties to set
         * @returns {PB_SCHorcruxesRet} PB_SCHorcruxesRet instance
         */
        PB_SCHorcruxesRet.create = function create(properties) {
            return new PB_SCHorcruxesRet(properties);
        };
    
        /**
         * Encodes the specified PB_SCHorcruxesRet message. Does not implicitly {@link PB_SCHorcruxesRet.verify|verify} messages.
         * @function encode
         * @memberof PB_SCHorcruxesRet
         * @static
         * @param {IPB_SCHorcruxesRet} message PB_SCHorcruxesRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHorcruxesRet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retType != null && Object.hasOwnProperty.call(message, "retType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.retParam != null && message.retParam.length)
                for (var i = 0; i < message.retParam.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.retParam[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCHorcruxesRet message, length delimited. Does not implicitly {@link PB_SCHorcruxesRet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCHorcruxesRet
         * @static
         * @param {IPB_SCHorcruxesRet} message PB_SCHorcruxesRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHorcruxesRet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCHorcruxesRet message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCHorcruxesRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCHorcruxesRet} PB_SCHorcruxesRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHorcruxesRet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCHorcruxesRet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    if (!(message.retParam && message.retParam.length))
                        message.retParam = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.retParam.push(reader.int32());
                    } else
                        message.retParam.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCHorcruxesRet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCHorcruxesRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCHorcruxesRet} PB_SCHorcruxesRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHorcruxesRet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCHorcruxesRet message.
         * @function verify
         * @memberof PB_SCHorcruxesRet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCHorcruxesRet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.retType != null && message.hasOwnProperty("retType"))
                if (!$util.isInteger(message.retType))
                    return "retType: integer expected";
            if (message.retParam != null && message.hasOwnProperty("retParam")) {
                if (!Array.isArray(message.retParam))
                    return "retParam: array expected";
                for (var i = 0; i < message.retParam.length; ++i)
                    if (!$util.isInteger(message.retParam[i]))
                        return "retParam: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCHorcruxesRet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCHorcruxesRet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCHorcruxesRet} PB_SCHorcruxesRet
         */
        PB_SCHorcruxesRet.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCHorcruxesRet)
                return object;
            var message = new $root.PB_SCHorcruxesRet();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.retParam) {
                if (!Array.isArray(object.retParam))
                    throw TypeError(".PB_SCHorcruxesRet.retParam: array expected");
                message.retParam = [];
                for (var i = 0; i < object.retParam.length; ++i)
                    message.retParam[i] = object.retParam[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCHorcruxesRet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCHorcruxesRet
         * @static
         * @param {PB_SCHorcruxesRet} message PB_SCHorcruxesRet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCHorcruxesRet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.retParam = [];
            if (options.defaults)
                object.retType = 0;
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.retParam && message.retParam.length) {
                object.retParam = [];
                for (var j = 0; j < message.retParam.length; ++j)
                    object.retParam[j] = message.retParam[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCHorcruxesRet to JSON.
         * @function toJSON
         * @memberof PB_SCHorcruxesRet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCHorcruxesRet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCHorcruxesRet;
    })();
    
    $root.PB_CSRandActivityOperaReq = (function() {
    
        /**
         * Properties of a PB_CSRandActivityOperaReq.
         * @exports IPB_CSRandActivityOperaReq
         * @interface IPB_CSRandActivityOperaReq
         * @property {number|null} [randActivityType] PB_CSRandActivityOperaReq randActivityType
         * @property {number|null} [operaType] PB_CSRandActivityOperaReq operaType
         * @property {number|null} [param1] PB_CSRandActivityOperaReq param1
         * @property {number|null} [param2] PB_CSRandActivityOperaReq param2
         * @property {number|null} [param3] PB_CSRandActivityOperaReq param3
         */
    
        /**
         * Constructs a new PB_CSRandActivityOperaReq.
         * @exports PB_CSRandActivityOperaReq
         * @classdesc Represents a PB_CSRandActivityOperaReq.
         * @implements IPB_CSRandActivityOperaReq
         * @constructor
         * @param {IPB_CSRandActivityOperaReq=} [properties] Properties to set
         */
        function PB_CSRandActivityOperaReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSRandActivityOperaReq randActivityType.
         * @member {number} randActivityType
         * @memberof PB_CSRandActivityOperaReq
         * @instance
         */
        PB_CSRandActivityOperaReq.prototype.randActivityType = 0;
    
        /**
         * PB_CSRandActivityOperaReq operaType.
         * @member {number} operaType
         * @memberof PB_CSRandActivityOperaReq
         * @instance
         */
        PB_CSRandActivityOperaReq.prototype.operaType = 0;
    
        /**
         * PB_CSRandActivityOperaReq param1.
         * @member {number} param1
         * @memberof PB_CSRandActivityOperaReq
         * @instance
         */
        PB_CSRandActivityOperaReq.prototype.param1 = 0;
    
        /**
         * PB_CSRandActivityOperaReq param2.
         * @member {number} param2
         * @memberof PB_CSRandActivityOperaReq
         * @instance
         */
        PB_CSRandActivityOperaReq.prototype.param2 = 0;
    
        /**
         * PB_CSRandActivityOperaReq param3.
         * @member {number} param3
         * @memberof PB_CSRandActivityOperaReq
         * @instance
         */
        PB_CSRandActivityOperaReq.prototype.param3 = 0;
    
        /**
         * Creates a new PB_CSRandActivityOperaReq instance using the specified properties.
         * @function create
         * @memberof PB_CSRandActivityOperaReq
         * @static
         * @param {IPB_CSRandActivityOperaReq=} [properties] Properties to set
         * @returns {PB_CSRandActivityOperaReq} PB_CSRandActivityOperaReq instance
         */
        PB_CSRandActivityOperaReq.create = function create(properties) {
            return new PB_CSRandActivityOperaReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSRandActivityOperaReq message. Does not implicitly {@link PB_CSRandActivityOperaReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSRandActivityOperaReq
         * @static
         * @param {IPB_CSRandActivityOperaReq} message PB_CSRandActivityOperaReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRandActivityOperaReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.randActivityType != null && Object.hasOwnProperty.call(message, "randActivityType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.randActivityType);
            if (message.operaType != null && Object.hasOwnProperty.call(message, "operaType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.operaType);
            if (message.param1 != null && Object.hasOwnProperty.call(message, "param1"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.param1);
            if (message.param2 != null && Object.hasOwnProperty.call(message, "param2"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.param2);
            if (message.param3 != null && Object.hasOwnProperty.call(message, "param3"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.param3);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSRandActivityOperaReq message, length delimited. Does not implicitly {@link PB_CSRandActivityOperaReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSRandActivityOperaReq
         * @static
         * @param {IPB_CSRandActivityOperaReq} message PB_CSRandActivityOperaReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRandActivityOperaReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSRandActivityOperaReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSRandActivityOperaReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSRandActivityOperaReq} PB_CSRandActivityOperaReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRandActivityOperaReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSRandActivityOperaReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.randActivityType = reader.int32();
                    break;
                case 2:
                    message.operaType = reader.int32();
                    break;
                case 3:
                    message.param1 = reader.int32();
                    break;
                case 4:
                    message.param2 = reader.int32();
                    break;
                case 5:
                    message.param3 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSRandActivityOperaReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSRandActivityOperaReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSRandActivityOperaReq} PB_CSRandActivityOperaReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRandActivityOperaReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSRandActivityOperaReq message.
         * @function verify
         * @memberof PB_CSRandActivityOperaReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSRandActivityOperaReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.randActivityType != null && message.hasOwnProperty("randActivityType"))
                if (!$util.isInteger(message.randActivityType))
                    return "randActivityType: integer expected";
            if (message.operaType != null && message.hasOwnProperty("operaType"))
                if (!$util.isInteger(message.operaType))
                    return "operaType: integer expected";
            if (message.param1 != null && message.hasOwnProperty("param1"))
                if (!$util.isInteger(message.param1))
                    return "param1: integer expected";
            if (message.param2 != null && message.hasOwnProperty("param2"))
                if (!$util.isInteger(message.param2))
                    return "param2: integer expected";
            if (message.param3 != null && message.hasOwnProperty("param3"))
                if (!$util.isInteger(message.param3))
                    return "param3: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSRandActivityOperaReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSRandActivityOperaReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSRandActivityOperaReq} PB_CSRandActivityOperaReq
         */
        PB_CSRandActivityOperaReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSRandActivityOperaReq)
                return object;
            var message = new $root.PB_CSRandActivityOperaReq();
            if (object.randActivityType != null)
                message.randActivityType = object.randActivityType | 0;
            if (object.operaType != null)
                message.operaType = object.operaType | 0;
            if (object.param1 != null)
                message.param1 = object.param1 | 0;
            if (object.param2 != null)
                message.param2 = object.param2 | 0;
            if (object.param3 != null)
                message.param3 = object.param3 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSRandActivityOperaReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSRandActivityOperaReq
         * @static
         * @param {PB_CSRandActivityOperaReq} message PB_CSRandActivityOperaReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSRandActivityOperaReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.randActivityType = 0;
                object.operaType = 0;
                object.param1 = 0;
                object.param2 = 0;
                object.param3 = 0;
            }
            if (message.randActivityType != null && message.hasOwnProperty("randActivityType"))
                object.randActivityType = message.randActivityType;
            if (message.operaType != null && message.hasOwnProperty("operaType"))
                object.operaType = message.operaType;
            if (message.param1 != null && message.hasOwnProperty("param1"))
                object.param1 = message.param1;
            if (message.param2 != null && message.hasOwnProperty("param2"))
                object.param2 = message.param2;
            if (message.param3 != null && message.hasOwnProperty("param3"))
                object.param3 = message.param3;
            return object;
        };
    
        /**
         * Converts this PB_CSRandActivityOperaReq to JSON.
         * @function toJSON
         * @memberof PB_CSRandActivityOperaReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSRandActivityOperaReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSRandActivityOperaReq;
    })();
    
    $root.PB_SCChongZhiInfo = (function() {
    
        /**
         * Properties of a PB_SCChongZhiInfo.
         * @exports IPB_SCChongZhiInfo
         * @interface IPB_SCChongZhiInfo
         * @property {number|Long|null} [historyChongzhi] PB_SCChongZhiInfo historyChongzhi
         * @property {number|null} [historyChongzhiCount] PB_SCChongZhiInfo historyChongzhiCount
         * @property {number|null} [todayChongzhi] PB_SCChongZhiInfo todayChongzhi
         * @property {Array.<number>|null} [chongzhiRewardTimes] PB_SCChongZhiInfo chongzhiRewardTimes
         */
    
        /**
         * Constructs a new PB_SCChongZhiInfo.
         * @exports PB_SCChongZhiInfo
         * @classdesc Represents a PB_SCChongZhiInfo.
         * @implements IPB_SCChongZhiInfo
         * @constructor
         * @param {IPB_SCChongZhiInfo=} [properties] Properties to set
         */
        function PB_SCChongZhiInfo(properties) {
            this.chongzhiRewardTimes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCChongZhiInfo historyChongzhi.
         * @member {number|Long} historyChongzhi
         * @memberof PB_SCChongZhiInfo
         * @instance
         */
        PB_SCChongZhiInfo.prototype.historyChongzhi = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCChongZhiInfo historyChongzhiCount.
         * @member {number} historyChongzhiCount
         * @memberof PB_SCChongZhiInfo
         * @instance
         */
        PB_SCChongZhiInfo.prototype.historyChongzhiCount = 0;
    
        /**
         * PB_SCChongZhiInfo todayChongzhi.
         * @member {number} todayChongzhi
         * @memberof PB_SCChongZhiInfo
         * @instance
         */
        PB_SCChongZhiInfo.prototype.todayChongzhi = 0;
    
        /**
         * PB_SCChongZhiInfo chongzhiRewardTimes.
         * @member {Array.<number>} chongzhiRewardTimes
         * @memberof PB_SCChongZhiInfo
         * @instance
         */
        PB_SCChongZhiInfo.prototype.chongzhiRewardTimes = $util.emptyArray;
    
        /**
         * Creates a new PB_SCChongZhiInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCChongZhiInfo
         * @static
         * @param {IPB_SCChongZhiInfo=} [properties] Properties to set
         * @returns {PB_SCChongZhiInfo} PB_SCChongZhiInfo instance
         */
        PB_SCChongZhiInfo.create = function create(properties) {
            return new PB_SCChongZhiInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCChongZhiInfo message. Does not implicitly {@link PB_SCChongZhiInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCChongZhiInfo
         * @static
         * @param {IPB_SCChongZhiInfo} message PB_SCChongZhiInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCChongZhiInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.historyChongzhi != null && Object.hasOwnProperty.call(message, "historyChongzhi"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.historyChongzhi);
            if (message.historyChongzhiCount != null && Object.hasOwnProperty.call(message, "historyChongzhiCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.historyChongzhiCount);
            if (message.todayChongzhi != null && Object.hasOwnProperty.call(message, "todayChongzhi"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.todayChongzhi);
            if (message.chongzhiRewardTimes != null && message.chongzhiRewardTimes.length)
                for (var i = 0; i < message.chongzhiRewardTimes.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.chongzhiRewardTimes[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCChongZhiInfo message, length delimited. Does not implicitly {@link PB_SCChongZhiInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCChongZhiInfo
         * @static
         * @param {IPB_SCChongZhiInfo} message PB_SCChongZhiInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCChongZhiInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCChongZhiInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCChongZhiInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCChongZhiInfo} PB_SCChongZhiInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCChongZhiInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCChongZhiInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.historyChongzhi = reader.int64();
                    break;
                case 2:
                    message.historyChongzhiCount = reader.int32();
                    break;
                case 3:
                    message.todayChongzhi = reader.int32();
                    break;
                case 4:
                    if (!(message.chongzhiRewardTimes && message.chongzhiRewardTimes.length))
                        message.chongzhiRewardTimes = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.chongzhiRewardTimes.push(reader.int32());
                    } else
                        message.chongzhiRewardTimes.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCChongZhiInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCChongZhiInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCChongZhiInfo} PB_SCChongZhiInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCChongZhiInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCChongZhiInfo message.
         * @function verify
         * @memberof PB_SCChongZhiInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCChongZhiInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.historyChongzhi != null && message.hasOwnProperty("historyChongzhi"))
                if (!$util.isInteger(message.historyChongzhi) && !(message.historyChongzhi && $util.isInteger(message.historyChongzhi.low) && $util.isInteger(message.historyChongzhi.high)))
                    return "historyChongzhi: integer|Long expected";
            if (message.historyChongzhiCount != null && message.hasOwnProperty("historyChongzhiCount"))
                if (!$util.isInteger(message.historyChongzhiCount))
                    return "historyChongzhiCount: integer expected";
            if (message.todayChongzhi != null && message.hasOwnProperty("todayChongzhi"))
                if (!$util.isInteger(message.todayChongzhi))
                    return "todayChongzhi: integer expected";
            if (message.chongzhiRewardTimes != null && message.hasOwnProperty("chongzhiRewardTimes")) {
                if (!Array.isArray(message.chongzhiRewardTimes))
                    return "chongzhiRewardTimes: array expected";
                for (var i = 0; i < message.chongzhiRewardTimes.length; ++i)
                    if (!$util.isInteger(message.chongzhiRewardTimes[i]))
                        return "chongzhiRewardTimes: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCChongZhiInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCChongZhiInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCChongZhiInfo} PB_SCChongZhiInfo
         */
        PB_SCChongZhiInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCChongZhiInfo)
                return object;
            var message = new $root.PB_SCChongZhiInfo();
            if (object.historyChongzhi != null)
                if ($util.Long)
                    (message.historyChongzhi = $util.Long.fromValue(object.historyChongzhi)).unsigned = false;
                else if (typeof object.historyChongzhi === "string")
                    message.historyChongzhi = parseInt(object.historyChongzhi, 10);
                else if (typeof object.historyChongzhi === "number")
                    message.historyChongzhi = object.historyChongzhi;
                else if (typeof object.historyChongzhi === "object")
                    message.historyChongzhi = new $util.LongBits(object.historyChongzhi.low >>> 0, object.historyChongzhi.high >>> 0).toNumber();
            if (object.historyChongzhiCount != null)
                message.historyChongzhiCount = object.historyChongzhiCount | 0;
            if (object.todayChongzhi != null)
                message.todayChongzhi = object.todayChongzhi | 0;
            if (object.chongzhiRewardTimes) {
                if (!Array.isArray(object.chongzhiRewardTimes))
                    throw TypeError(".PB_SCChongZhiInfo.chongzhiRewardTimes: array expected");
                message.chongzhiRewardTimes = [];
                for (var i = 0; i < object.chongzhiRewardTimes.length; ++i)
                    message.chongzhiRewardTimes[i] = object.chongzhiRewardTimes[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCChongZhiInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCChongZhiInfo
         * @static
         * @param {PB_SCChongZhiInfo} message PB_SCChongZhiInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCChongZhiInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chongzhiRewardTimes = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.historyChongzhi = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.historyChongzhi = options.longs === String ? "0" : 0;
                object.historyChongzhiCount = 0;
                object.todayChongzhi = 0;
            }
            if (message.historyChongzhi != null && message.hasOwnProperty("historyChongzhi"))
                if (typeof message.historyChongzhi === "number")
                    object.historyChongzhi = options.longs === String ? String(message.historyChongzhi) : message.historyChongzhi;
                else
                    object.historyChongzhi = options.longs === String ? $util.Long.prototype.toString.call(message.historyChongzhi) : options.longs === Number ? new $util.LongBits(message.historyChongzhi.low >>> 0, message.historyChongzhi.high >>> 0).toNumber() : message.historyChongzhi;
            if (message.historyChongzhiCount != null && message.hasOwnProperty("historyChongzhiCount"))
                object.historyChongzhiCount = message.historyChongzhiCount;
            if (message.todayChongzhi != null && message.hasOwnProperty("todayChongzhi"))
                object.todayChongzhi = message.todayChongzhi;
            if (message.chongzhiRewardTimes && message.chongzhiRewardTimes.length) {
                object.chongzhiRewardTimes = [];
                for (var j = 0; j < message.chongzhiRewardTimes.length; ++j)
                    object.chongzhiRewardTimes[j] = message.chongzhiRewardTimes[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCChongZhiInfo to JSON.
         * @function toJSON
         * @memberof PB_SCChongZhiInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCChongZhiInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCChongZhiInfo;
    })();
    
    $root.PB_SCChongZhiInfoChange = (function() {
    
        /**
         * Properties of a PB_SCChongZhiInfoChange.
         * @exports IPB_SCChongZhiInfoChange
         * @interface IPB_SCChongZhiInfoChange
         * @property {number|Long|null} [historyChongzhi] PB_SCChongZhiInfoChange historyChongzhi
         * @property {number|null} [historyChongzhiCount] PB_SCChongZhiInfoChange historyChongzhiCount
         * @property {number|null} [todayChongzhi] PB_SCChongZhiInfoChange todayChongzhi
         * @property {number|null} [seq] PB_SCChongZhiInfoChange seq
         * @property {number|null} [times] PB_SCChongZhiInfoChange times
         */
    
        /**
         * Constructs a new PB_SCChongZhiInfoChange.
         * @exports PB_SCChongZhiInfoChange
         * @classdesc Represents a PB_SCChongZhiInfoChange.
         * @implements IPB_SCChongZhiInfoChange
         * @constructor
         * @param {IPB_SCChongZhiInfoChange=} [properties] Properties to set
         */
        function PB_SCChongZhiInfoChange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCChongZhiInfoChange historyChongzhi.
         * @member {number|Long} historyChongzhi
         * @memberof PB_SCChongZhiInfoChange
         * @instance
         */
        PB_SCChongZhiInfoChange.prototype.historyChongzhi = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCChongZhiInfoChange historyChongzhiCount.
         * @member {number} historyChongzhiCount
         * @memberof PB_SCChongZhiInfoChange
         * @instance
         */
        PB_SCChongZhiInfoChange.prototype.historyChongzhiCount = 0;
    
        /**
         * PB_SCChongZhiInfoChange todayChongzhi.
         * @member {number} todayChongzhi
         * @memberof PB_SCChongZhiInfoChange
         * @instance
         */
        PB_SCChongZhiInfoChange.prototype.todayChongzhi = 0;
    
        /**
         * PB_SCChongZhiInfoChange seq.
         * @member {number} seq
         * @memberof PB_SCChongZhiInfoChange
         * @instance
         */
        PB_SCChongZhiInfoChange.prototype.seq = 0;
    
        /**
         * PB_SCChongZhiInfoChange times.
         * @member {number} times
         * @memberof PB_SCChongZhiInfoChange
         * @instance
         */
        PB_SCChongZhiInfoChange.prototype.times = 0;
    
        /**
         * Creates a new PB_SCChongZhiInfoChange instance using the specified properties.
         * @function create
         * @memberof PB_SCChongZhiInfoChange
         * @static
         * @param {IPB_SCChongZhiInfoChange=} [properties] Properties to set
         * @returns {PB_SCChongZhiInfoChange} PB_SCChongZhiInfoChange instance
         */
        PB_SCChongZhiInfoChange.create = function create(properties) {
            return new PB_SCChongZhiInfoChange(properties);
        };
    
        /**
         * Encodes the specified PB_SCChongZhiInfoChange message. Does not implicitly {@link PB_SCChongZhiInfoChange.verify|verify} messages.
         * @function encode
         * @memberof PB_SCChongZhiInfoChange
         * @static
         * @param {IPB_SCChongZhiInfoChange} message PB_SCChongZhiInfoChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCChongZhiInfoChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.historyChongzhi != null && Object.hasOwnProperty.call(message, "historyChongzhi"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.historyChongzhi);
            if (message.historyChongzhiCount != null && Object.hasOwnProperty.call(message, "historyChongzhiCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.historyChongzhiCount);
            if (message.todayChongzhi != null && Object.hasOwnProperty.call(message, "todayChongzhi"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.todayChongzhi);
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.seq);
            if (message.times != null && Object.hasOwnProperty.call(message, "times"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.times);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCChongZhiInfoChange message, length delimited. Does not implicitly {@link PB_SCChongZhiInfoChange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCChongZhiInfoChange
         * @static
         * @param {IPB_SCChongZhiInfoChange} message PB_SCChongZhiInfoChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCChongZhiInfoChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCChongZhiInfoChange message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCChongZhiInfoChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCChongZhiInfoChange} PB_SCChongZhiInfoChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCChongZhiInfoChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCChongZhiInfoChange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.historyChongzhi = reader.int64();
                    break;
                case 2:
                    message.historyChongzhiCount = reader.int32();
                    break;
                case 3:
                    message.todayChongzhi = reader.int32();
                    break;
                case 4:
                    message.seq = reader.int32();
                    break;
                case 5:
                    message.times = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCChongZhiInfoChange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCChongZhiInfoChange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCChongZhiInfoChange} PB_SCChongZhiInfoChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCChongZhiInfoChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCChongZhiInfoChange message.
         * @function verify
         * @memberof PB_SCChongZhiInfoChange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCChongZhiInfoChange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.historyChongzhi != null && message.hasOwnProperty("historyChongzhi"))
                if (!$util.isInteger(message.historyChongzhi) && !(message.historyChongzhi && $util.isInteger(message.historyChongzhi.low) && $util.isInteger(message.historyChongzhi.high)))
                    return "historyChongzhi: integer|Long expected";
            if (message.historyChongzhiCount != null && message.hasOwnProperty("historyChongzhiCount"))
                if (!$util.isInteger(message.historyChongzhiCount))
                    return "historyChongzhiCount: integer expected";
            if (message.todayChongzhi != null && message.hasOwnProperty("todayChongzhi"))
                if (!$util.isInteger(message.todayChongzhi))
                    return "todayChongzhi: integer expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.times != null && message.hasOwnProperty("times"))
                if (!$util.isInteger(message.times))
                    return "times: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCChongZhiInfoChange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCChongZhiInfoChange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCChongZhiInfoChange} PB_SCChongZhiInfoChange
         */
        PB_SCChongZhiInfoChange.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCChongZhiInfoChange)
                return object;
            var message = new $root.PB_SCChongZhiInfoChange();
            if (object.historyChongzhi != null)
                if ($util.Long)
                    (message.historyChongzhi = $util.Long.fromValue(object.historyChongzhi)).unsigned = false;
                else if (typeof object.historyChongzhi === "string")
                    message.historyChongzhi = parseInt(object.historyChongzhi, 10);
                else if (typeof object.historyChongzhi === "number")
                    message.historyChongzhi = object.historyChongzhi;
                else if (typeof object.historyChongzhi === "object")
                    message.historyChongzhi = new $util.LongBits(object.historyChongzhi.low >>> 0, object.historyChongzhi.high >>> 0).toNumber();
            if (object.historyChongzhiCount != null)
                message.historyChongzhiCount = object.historyChongzhiCount | 0;
            if (object.todayChongzhi != null)
                message.todayChongzhi = object.todayChongzhi | 0;
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.times != null)
                message.times = object.times | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCChongZhiInfoChange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCChongZhiInfoChange
         * @static
         * @param {PB_SCChongZhiInfoChange} message PB_SCChongZhiInfoChange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCChongZhiInfoChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.historyChongzhi = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.historyChongzhi = options.longs === String ? "0" : 0;
                object.historyChongzhiCount = 0;
                object.todayChongzhi = 0;
                object.seq = 0;
                object.times = 0;
            }
            if (message.historyChongzhi != null && message.hasOwnProperty("historyChongzhi"))
                if (typeof message.historyChongzhi === "number")
                    object.historyChongzhi = options.longs === String ? String(message.historyChongzhi) : message.historyChongzhi;
                else
                    object.historyChongzhi = options.longs === String ? $util.Long.prototype.toString.call(message.historyChongzhi) : options.longs === Number ? new $util.LongBits(message.historyChongzhi.low >>> 0, message.historyChongzhi.high >>> 0).toNumber() : message.historyChongzhi;
            if (message.historyChongzhiCount != null && message.hasOwnProperty("historyChongzhiCount"))
                object.historyChongzhiCount = message.historyChongzhiCount;
            if (message.todayChongzhi != null && message.hasOwnProperty("todayChongzhi"))
                object.todayChongzhi = message.todayChongzhi;
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.times != null && message.hasOwnProperty("times"))
                object.times = message.times;
            return object;
        };
    
        /**
         * Converts this PB_SCChongZhiInfoChange to JSON.
         * @function toJSON
         * @memberof PB_SCChongZhiInfoChange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCChongZhiInfoChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCChongZhiInfoChange;
    })();
    
    $root.PB_SCActivityStatus = (function() {
    
        /**
         * Properties of a PB_SCActivityStatus.
         * @exports IPB_SCActivityStatus
         * @interface IPB_SCActivityStatus
         * @property {number|null} [activityType] PB_SCActivityStatus activityType
         * @property {number|null} [status] PB_SCActivityStatus status
         * @property {number|null} [isBroadcast] PB_SCActivityStatus isBroadcast
         * @property {number|null} [nextStatusSwitchTime] PB_SCActivityStatus nextStatusSwitchTime
         * @property {number|null} [param_1] PB_SCActivityStatus param_1
         * @property {number|null} [param_2] PB_SCActivityStatus param_2
         */
    
        /**
         * Constructs a new PB_SCActivityStatus.
         * @exports PB_SCActivityStatus
         * @classdesc Represents a PB_SCActivityStatus.
         * @implements IPB_SCActivityStatus
         * @constructor
         * @param {IPB_SCActivityStatus=} [properties] Properties to set
         */
        function PB_SCActivityStatus(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCActivityStatus activityType.
         * @member {number} activityType
         * @memberof PB_SCActivityStatus
         * @instance
         */
        PB_SCActivityStatus.prototype.activityType = 0;
    
        /**
         * PB_SCActivityStatus status.
         * @member {number} status
         * @memberof PB_SCActivityStatus
         * @instance
         */
        PB_SCActivityStatus.prototype.status = 0;
    
        /**
         * PB_SCActivityStatus isBroadcast.
         * @member {number} isBroadcast
         * @memberof PB_SCActivityStatus
         * @instance
         */
        PB_SCActivityStatus.prototype.isBroadcast = 0;
    
        /**
         * PB_SCActivityStatus nextStatusSwitchTime.
         * @member {number} nextStatusSwitchTime
         * @memberof PB_SCActivityStatus
         * @instance
         */
        PB_SCActivityStatus.prototype.nextStatusSwitchTime = 0;
    
        /**
         * PB_SCActivityStatus param_1.
         * @member {number} param_1
         * @memberof PB_SCActivityStatus
         * @instance
         */
        PB_SCActivityStatus.prototype.param_1 = 0;
    
        /**
         * PB_SCActivityStatus param_2.
         * @member {number} param_2
         * @memberof PB_SCActivityStatus
         * @instance
         */
        PB_SCActivityStatus.prototype.param_2 = 0;
    
        /**
         * Creates a new PB_SCActivityStatus instance using the specified properties.
         * @function create
         * @memberof PB_SCActivityStatus
         * @static
         * @param {IPB_SCActivityStatus=} [properties] Properties to set
         * @returns {PB_SCActivityStatus} PB_SCActivityStatus instance
         */
        PB_SCActivityStatus.create = function create(properties) {
            return new PB_SCActivityStatus(properties);
        };
    
        /**
         * Encodes the specified PB_SCActivityStatus message. Does not implicitly {@link PB_SCActivityStatus.verify|verify} messages.
         * @function encode
         * @memberof PB_SCActivityStatus
         * @static
         * @param {IPB_SCActivityStatus} message PB_SCActivityStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCActivityStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activityType != null && Object.hasOwnProperty.call(message, "activityType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activityType);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.isBroadcast != null && Object.hasOwnProperty.call(message, "isBroadcast"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isBroadcast);
            if (message.nextStatusSwitchTime != null && Object.hasOwnProperty.call(message, "nextStatusSwitchTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.nextStatusSwitchTime);
            if (message.param_1 != null && Object.hasOwnProperty.call(message, "param_1"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.param_1);
            if (message.param_2 != null && Object.hasOwnProperty.call(message, "param_2"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.param_2);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCActivityStatus message, length delimited. Does not implicitly {@link PB_SCActivityStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCActivityStatus
         * @static
         * @param {IPB_SCActivityStatus} message PB_SCActivityStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCActivityStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCActivityStatus message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCActivityStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCActivityStatus} PB_SCActivityStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCActivityStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCActivityStatus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activityType = reader.int32();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                case 3:
                    message.isBroadcast = reader.int32();
                    break;
                case 4:
                    message.nextStatusSwitchTime = reader.uint32();
                    break;
                case 5:
                    message.param_1 = reader.uint32();
                    break;
                case 6:
                    message.param_2 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCActivityStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCActivityStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCActivityStatus} PB_SCActivityStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCActivityStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCActivityStatus message.
         * @function verify
         * @memberof PB_SCActivityStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCActivityStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activityType != null && message.hasOwnProperty("activityType"))
                if (!$util.isInteger(message.activityType))
                    return "activityType: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.isBroadcast != null && message.hasOwnProperty("isBroadcast"))
                if (!$util.isInteger(message.isBroadcast))
                    return "isBroadcast: integer expected";
            if (message.nextStatusSwitchTime != null && message.hasOwnProperty("nextStatusSwitchTime"))
                if (!$util.isInteger(message.nextStatusSwitchTime))
                    return "nextStatusSwitchTime: integer expected";
            if (message.param_1 != null && message.hasOwnProperty("param_1"))
                if (!$util.isInteger(message.param_1))
                    return "param_1: integer expected";
            if (message.param_2 != null && message.hasOwnProperty("param_2"))
                if (!$util.isInteger(message.param_2))
                    return "param_2: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCActivityStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCActivityStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCActivityStatus} PB_SCActivityStatus
         */
        PB_SCActivityStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCActivityStatus)
                return object;
            var message = new $root.PB_SCActivityStatus();
            if (object.activityType != null)
                message.activityType = object.activityType | 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.isBroadcast != null)
                message.isBroadcast = object.isBroadcast | 0;
            if (object.nextStatusSwitchTime != null)
                message.nextStatusSwitchTime = object.nextStatusSwitchTime >>> 0;
            if (object.param_1 != null)
                message.param_1 = object.param_1 >>> 0;
            if (object.param_2 != null)
                message.param_2 = object.param_2 >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCActivityStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCActivityStatus
         * @static
         * @param {PB_SCActivityStatus} message PB_SCActivityStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCActivityStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.activityType = 0;
                object.status = 0;
                object.isBroadcast = 0;
                object.nextStatusSwitchTime = 0;
                object.param_1 = 0;
                object.param_2 = 0;
            }
            if (message.activityType != null && message.hasOwnProperty("activityType"))
                object.activityType = message.activityType;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.isBroadcast != null && message.hasOwnProperty("isBroadcast"))
                object.isBroadcast = message.isBroadcast;
            if (message.nextStatusSwitchTime != null && message.hasOwnProperty("nextStatusSwitchTime"))
                object.nextStatusSwitchTime = message.nextStatusSwitchTime;
            if (message.param_1 != null && message.hasOwnProperty("param_1"))
                object.param_1 = message.param_1;
            if (message.param_2 != null && message.hasOwnProperty("param_2"))
                object.param_2 = message.param_2;
            return object;
        };
    
        /**
         * Converts this PB_SCActivityStatus to JSON.
         * @function toJSON
         * @memberof PB_SCActivityStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCActivityStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCActivityStatus;
    })();
    
    $root.PB_CSChongZhiConfigReq = (function() {
    
        /**
         * Properties of a PB_CSChongZhiConfigReq.
         * @exports IPB_CSChongZhiConfigReq
         * @interface IPB_CSChongZhiConfigReq
         * @property {number|null} [currency] PB_CSChongZhiConfigReq currency
         * @property {Uint8Array|null} [spidStr] PB_CSChongZhiConfigReq spidStr
         */
    
        /**
         * Constructs a new PB_CSChongZhiConfigReq.
         * @exports PB_CSChongZhiConfigReq
         * @classdesc Represents a PB_CSChongZhiConfigReq.
         * @implements IPB_CSChongZhiConfigReq
         * @constructor
         * @param {IPB_CSChongZhiConfigReq=} [properties] Properties to set
         */
        function PB_CSChongZhiConfigReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSChongZhiConfigReq currency.
         * @member {number} currency
         * @memberof PB_CSChongZhiConfigReq
         * @instance
         */
        PB_CSChongZhiConfigReq.prototype.currency = 0;
    
        /**
         * PB_CSChongZhiConfigReq spidStr.
         * @member {Uint8Array} spidStr
         * @memberof PB_CSChongZhiConfigReq
         * @instance
         */
        PB_CSChongZhiConfigReq.prototype.spidStr = $util.newBuffer([]);
    
        /**
         * Creates a new PB_CSChongZhiConfigReq instance using the specified properties.
         * @function create
         * @memberof PB_CSChongZhiConfigReq
         * @static
         * @param {IPB_CSChongZhiConfigReq=} [properties] Properties to set
         * @returns {PB_CSChongZhiConfigReq} PB_CSChongZhiConfigReq instance
         */
        PB_CSChongZhiConfigReq.create = function create(properties) {
            return new PB_CSChongZhiConfigReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSChongZhiConfigReq message. Does not implicitly {@link PB_CSChongZhiConfigReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSChongZhiConfigReq
         * @static
         * @param {IPB_CSChongZhiConfigReq} message PB_CSChongZhiConfigReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSChongZhiConfigReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currency);
            if (message.spidStr != null && Object.hasOwnProperty.call(message, "spidStr"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spidStr);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSChongZhiConfigReq message, length delimited. Does not implicitly {@link PB_CSChongZhiConfigReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSChongZhiConfigReq
         * @static
         * @param {IPB_CSChongZhiConfigReq} message PB_CSChongZhiConfigReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSChongZhiConfigReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSChongZhiConfigReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSChongZhiConfigReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSChongZhiConfigReq} PB_CSChongZhiConfigReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSChongZhiConfigReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSChongZhiConfigReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currency = reader.int32();
                    break;
                case 2:
                    message.spidStr = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSChongZhiConfigReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSChongZhiConfigReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSChongZhiConfigReq} PB_CSChongZhiConfigReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSChongZhiConfigReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSChongZhiConfigReq message.
         * @function verify
         * @memberof PB_CSChongZhiConfigReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSChongZhiConfigReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currency != null && message.hasOwnProperty("currency"))
                if (!$util.isInteger(message.currency))
                    return "currency: integer expected";
            if (message.spidStr != null && message.hasOwnProperty("spidStr"))
                if (!(message.spidStr && typeof message.spidStr.length === "number" || $util.isString(message.spidStr)))
                    return "spidStr: buffer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSChongZhiConfigReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSChongZhiConfigReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSChongZhiConfigReq} PB_CSChongZhiConfigReq
         */
        PB_CSChongZhiConfigReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSChongZhiConfigReq)
                return object;
            var message = new $root.PB_CSChongZhiConfigReq();
            if (object.currency != null)
                message.currency = object.currency | 0;
            if (object.spidStr != null)
                if (typeof object.spidStr === "string")
                    $util.base64.decode(object.spidStr, message.spidStr = $util.newBuffer($util.base64.length(object.spidStr)), 0);
                else if (object.spidStr.length)
                    message.spidStr = object.spidStr;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSChongZhiConfigReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSChongZhiConfigReq
         * @static
         * @param {PB_CSChongZhiConfigReq} message PB_CSChongZhiConfigReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSChongZhiConfigReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.currency = 0;
                if (options.bytes === String)
                    object.spidStr = "";
                else {
                    object.spidStr = [];
                    if (options.bytes !== Array)
                        object.spidStr = $util.newBuffer(object.spidStr);
                }
            }
            if (message.currency != null && message.hasOwnProperty("currency"))
                object.currency = message.currency;
            if (message.spidStr != null && message.hasOwnProperty("spidStr"))
                object.spidStr = options.bytes === String ? $util.base64.encode(message.spidStr, 0, message.spidStr.length) : options.bytes === Array ? Array.prototype.slice.call(message.spidStr) : message.spidStr;
            return object;
        };
    
        /**
         * Converts this PB_CSChongZhiConfigReq to JSON.
         * @function toJSON
         * @memberof PB_CSChongZhiConfigReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSChongZhiConfigReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSChongZhiConfigReq;
    })();
    
    $root.PB_ChongzhiInfo = (function() {
    
        /**
         * Properties of a PB_ChongzhiInfo.
         * @exports IPB_ChongzhiInfo
         * @interface IPB_ChongzhiInfo
         * @property {number|null} [seq] PB_ChongzhiInfo seq
         * @property {number|null} [extraRewardType] PB_ChongzhiInfo extraRewardType
         * @property {number|null} [addGold] PB_ChongzhiInfo addGold
         * @property {number|null} [extraReward] PB_ChongzhiInfo extraReward
         * @property {number|null} [moneyShow] PB_ChongzhiInfo moneyShow
         * @property {Uint8Array|null} [descriptionFirstChongzhi] PB_ChongzhiInfo descriptionFirstChongzhi
         */
    
        /**
         * Constructs a new PB_ChongzhiInfo.
         * @exports PB_ChongzhiInfo
         * @classdesc Represents a PB_ChongzhiInfo.
         * @implements IPB_ChongzhiInfo
         * @constructor
         * @param {IPB_ChongzhiInfo=} [properties] Properties to set
         */
        function PB_ChongzhiInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_ChongzhiInfo seq.
         * @member {number} seq
         * @memberof PB_ChongzhiInfo
         * @instance
         */
        PB_ChongzhiInfo.prototype.seq = 0;
    
        /**
         * PB_ChongzhiInfo extraRewardType.
         * @member {number} extraRewardType
         * @memberof PB_ChongzhiInfo
         * @instance
         */
        PB_ChongzhiInfo.prototype.extraRewardType = 0;
    
        /**
         * PB_ChongzhiInfo addGold.
         * @member {number} addGold
         * @memberof PB_ChongzhiInfo
         * @instance
         */
        PB_ChongzhiInfo.prototype.addGold = 0;
    
        /**
         * PB_ChongzhiInfo extraReward.
         * @member {number} extraReward
         * @memberof PB_ChongzhiInfo
         * @instance
         */
        PB_ChongzhiInfo.prototype.extraReward = 0;
    
        /**
         * PB_ChongzhiInfo moneyShow.
         * @member {number} moneyShow
         * @memberof PB_ChongzhiInfo
         * @instance
         */
        PB_ChongzhiInfo.prototype.moneyShow = 0;
    
        /**
         * PB_ChongzhiInfo descriptionFirstChongzhi.
         * @member {Uint8Array} descriptionFirstChongzhi
         * @memberof PB_ChongzhiInfo
         * @instance
         */
        PB_ChongzhiInfo.prototype.descriptionFirstChongzhi = $util.newBuffer([]);
    
        /**
         * Creates a new PB_ChongzhiInfo instance using the specified properties.
         * @function create
         * @memberof PB_ChongzhiInfo
         * @static
         * @param {IPB_ChongzhiInfo=} [properties] Properties to set
         * @returns {PB_ChongzhiInfo} PB_ChongzhiInfo instance
         */
        PB_ChongzhiInfo.create = function create(properties) {
            return new PB_ChongzhiInfo(properties);
        };
    
        /**
         * Encodes the specified PB_ChongzhiInfo message. Does not implicitly {@link PB_ChongzhiInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_ChongzhiInfo
         * @static
         * @param {IPB_ChongzhiInfo} message PB_ChongzhiInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_ChongzhiInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.extraRewardType != null && Object.hasOwnProperty.call(message, "extraRewardType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.extraRewardType);
            if (message.addGold != null && Object.hasOwnProperty.call(message, "addGold"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.addGold);
            if (message.extraReward != null && Object.hasOwnProperty.call(message, "extraReward"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.extraReward);
            if (message.moneyShow != null && Object.hasOwnProperty.call(message, "moneyShow"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.moneyShow);
            if (message.descriptionFirstChongzhi != null && Object.hasOwnProperty.call(message, "descriptionFirstChongzhi"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.descriptionFirstChongzhi);
            return writer;
        };
    
        /**
         * Encodes the specified PB_ChongzhiInfo message, length delimited. Does not implicitly {@link PB_ChongzhiInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_ChongzhiInfo
         * @static
         * @param {IPB_ChongzhiInfo} message PB_ChongzhiInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_ChongzhiInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_ChongzhiInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_ChongzhiInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_ChongzhiInfo} PB_ChongzhiInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_ChongzhiInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_ChongzhiInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    message.extraRewardType = reader.int32();
                    break;
                case 3:
                    message.addGold = reader.int32();
                    break;
                case 4:
                    message.extraReward = reader.int32();
                    break;
                case 5:
                    message.moneyShow = reader.int32();
                    break;
                case 6:
                    message.descriptionFirstChongzhi = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_ChongzhiInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_ChongzhiInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_ChongzhiInfo} PB_ChongzhiInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_ChongzhiInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_ChongzhiInfo message.
         * @function verify
         * @memberof PB_ChongzhiInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_ChongzhiInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.extraRewardType != null && message.hasOwnProperty("extraRewardType"))
                if (!$util.isInteger(message.extraRewardType))
                    return "extraRewardType: integer expected";
            if (message.addGold != null && message.hasOwnProperty("addGold"))
                if (!$util.isInteger(message.addGold))
                    return "addGold: integer expected";
            if (message.extraReward != null && message.hasOwnProperty("extraReward"))
                if (!$util.isInteger(message.extraReward))
                    return "extraReward: integer expected";
            if (message.moneyShow != null && message.hasOwnProperty("moneyShow"))
                if (!$util.isInteger(message.moneyShow))
                    return "moneyShow: integer expected";
            if (message.descriptionFirstChongzhi != null && message.hasOwnProperty("descriptionFirstChongzhi"))
                if (!(message.descriptionFirstChongzhi && typeof message.descriptionFirstChongzhi.length === "number" || $util.isString(message.descriptionFirstChongzhi)))
                    return "descriptionFirstChongzhi: buffer expected";
            return null;
        };
    
        /**
         * Creates a PB_ChongzhiInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_ChongzhiInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_ChongzhiInfo} PB_ChongzhiInfo
         */
        PB_ChongzhiInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_ChongzhiInfo)
                return object;
            var message = new $root.PB_ChongzhiInfo();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.extraRewardType != null)
                message.extraRewardType = object.extraRewardType | 0;
            if (object.addGold != null)
                message.addGold = object.addGold | 0;
            if (object.extraReward != null)
                message.extraReward = object.extraReward | 0;
            if (object.moneyShow != null)
                message.moneyShow = object.moneyShow | 0;
            if (object.descriptionFirstChongzhi != null)
                if (typeof object.descriptionFirstChongzhi === "string")
                    $util.base64.decode(object.descriptionFirstChongzhi, message.descriptionFirstChongzhi = $util.newBuffer($util.base64.length(object.descriptionFirstChongzhi)), 0);
                else if (object.descriptionFirstChongzhi.length)
                    message.descriptionFirstChongzhi = object.descriptionFirstChongzhi;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_ChongzhiInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_ChongzhiInfo
         * @static
         * @param {PB_ChongzhiInfo} message PB_ChongzhiInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_ChongzhiInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.seq = 0;
                object.extraRewardType = 0;
                object.addGold = 0;
                object.extraReward = 0;
                object.moneyShow = 0;
                if (options.bytes === String)
                    object.descriptionFirstChongzhi = "";
                else {
                    object.descriptionFirstChongzhi = [];
                    if (options.bytes !== Array)
                        object.descriptionFirstChongzhi = $util.newBuffer(object.descriptionFirstChongzhi);
                }
            }
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.extraRewardType != null && message.hasOwnProperty("extraRewardType"))
                object.extraRewardType = message.extraRewardType;
            if (message.addGold != null && message.hasOwnProperty("addGold"))
                object.addGold = message.addGold;
            if (message.extraReward != null && message.hasOwnProperty("extraReward"))
                object.extraReward = message.extraReward;
            if (message.moneyShow != null && message.hasOwnProperty("moneyShow"))
                object.moneyShow = message.moneyShow;
            if (message.descriptionFirstChongzhi != null && message.hasOwnProperty("descriptionFirstChongzhi"))
                object.descriptionFirstChongzhi = options.bytes === String ? $util.base64.encode(message.descriptionFirstChongzhi, 0, message.descriptionFirstChongzhi.length) : options.bytes === Array ? Array.prototype.slice.call(message.descriptionFirstChongzhi) : message.descriptionFirstChongzhi;
            return object;
        };
    
        /**
         * Converts this PB_ChongzhiInfo to JSON.
         * @function toJSON
         * @memberof PB_ChongzhiInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_ChongzhiInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_ChongzhiInfo;
    })();
    
    $root.PB_SCChongZhiConfigInfo = (function() {
    
        /**
         * Properties of a PB_SCChongZhiConfigInfo.
         * @exports IPB_SCChongZhiConfigInfo
         * @interface IPB_SCChongZhiConfigInfo
         * @property {number|null} [currencyType] PB_SCChongZhiConfigInfo currencyType
         * @property {number|null} [infoCount] PB_SCChongZhiConfigInfo infoCount
         * @property {Array.<IPB_ChongzhiInfo>|null} [infoList] PB_SCChongZhiConfigInfo infoList
         */
    
        /**
         * Constructs a new PB_SCChongZhiConfigInfo.
         * @exports PB_SCChongZhiConfigInfo
         * @classdesc Represents a PB_SCChongZhiConfigInfo.
         * @implements IPB_SCChongZhiConfigInfo
         * @constructor
         * @param {IPB_SCChongZhiConfigInfo=} [properties] Properties to set
         */
        function PB_SCChongZhiConfigInfo(properties) {
            this.infoList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCChongZhiConfigInfo currencyType.
         * @member {number} currencyType
         * @memberof PB_SCChongZhiConfigInfo
         * @instance
         */
        PB_SCChongZhiConfigInfo.prototype.currencyType = 0;
    
        /**
         * PB_SCChongZhiConfigInfo infoCount.
         * @member {number} infoCount
         * @memberof PB_SCChongZhiConfigInfo
         * @instance
         */
        PB_SCChongZhiConfigInfo.prototype.infoCount = 0;
    
        /**
         * PB_SCChongZhiConfigInfo infoList.
         * @member {Array.<IPB_ChongzhiInfo>} infoList
         * @memberof PB_SCChongZhiConfigInfo
         * @instance
         */
        PB_SCChongZhiConfigInfo.prototype.infoList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCChongZhiConfigInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCChongZhiConfigInfo
         * @static
         * @param {IPB_SCChongZhiConfigInfo=} [properties] Properties to set
         * @returns {PB_SCChongZhiConfigInfo} PB_SCChongZhiConfigInfo instance
         */
        PB_SCChongZhiConfigInfo.create = function create(properties) {
            return new PB_SCChongZhiConfigInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCChongZhiConfigInfo message. Does not implicitly {@link PB_SCChongZhiConfigInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCChongZhiConfigInfo
         * @static
         * @param {IPB_SCChongZhiConfigInfo} message PB_SCChongZhiConfigInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCChongZhiConfigInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currencyType != null && Object.hasOwnProperty.call(message, "currencyType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.currencyType);
            if (message.infoCount != null && Object.hasOwnProperty.call(message, "infoCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.infoCount);
            if (message.infoList != null && message.infoList.length)
                for (var i = 0; i < message.infoList.length; ++i)
                    $root.PB_ChongzhiInfo.encode(message.infoList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCChongZhiConfigInfo message, length delimited. Does not implicitly {@link PB_SCChongZhiConfigInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCChongZhiConfigInfo
         * @static
         * @param {IPB_SCChongZhiConfigInfo} message PB_SCChongZhiConfigInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCChongZhiConfigInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCChongZhiConfigInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCChongZhiConfigInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCChongZhiConfigInfo} PB_SCChongZhiConfigInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCChongZhiConfigInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCChongZhiConfigInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currencyType = reader.int32();
                    break;
                case 2:
                    message.infoCount = reader.int32();
                    break;
                case 3:
                    if (!(message.infoList && message.infoList.length))
                        message.infoList = [];
                    message.infoList.push($root.PB_ChongzhiInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCChongZhiConfigInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCChongZhiConfigInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCChongZhiConfigInfo} PB_SCChongZhiConfigInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCChongZhiConfigInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCChongZhiConfigInfo message.
         * @function verify
         * @memberof PB_SCChongZhiConfigInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCChongZhiConfigInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currencyType != null && message.hasOwnProperty("currencyType"))
                if (!$util.isInteger(message.currencyType))
                    return "currencyType: integer expected";
            if (message.infoCount != null && message.hasOwnProperty("infoCount"))
                if (!$util.isInteger(message.infoCount))
                    return "infoCount: integer expected";
            if (message.infoList != null && message.hasOwnProperty("infoList")) {
                if (!Array.isArray(message.infoList))
                    return "infoList: array expected";
                for (var i = 0; i < message.infoList.length; ++i) {
                    var error = $root.PB_ChongzhiInfo.verify(message.infoList[i]);
                    if (error)
                        return "infoList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCChongZhiConfigInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCChongZhiConfigInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCChongZhiConfigInfo} PB_SCChongZhiConfigInfo
         */
        PB_SCChongZhiConfigInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCChongZhiConfigInfo)
                return object;
            var message = new $root.PB_SCChongZhiConfigInfo();
            if (object.currencyType != null)
                message.currencyType = object.currencyType | 0;
            if (object.infoCount != null)
                message.infoCount = object.infoCount | 0;
            if (object.infoList) {
                if (!Array.isArray(object.infoList))
                    throw TypeError(".PB_SCChongZhiConfigInfo.infoList: array expected");
                message.infoList = [];
                for (var i = 0; i < object.infoList.length; ++i) {
                    if (typeof object.infoList[i] !== "object")
                        throw TypeError(".PB_SCChongZhiConfigInfo.infoList: object expected");
                    message.infoList[i] = $root.PB_ChongzhiInfo.fromObject(object.infoList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCChongZhiConfigInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCChongZhiConfigInfo
         * @static
         * @param {PB_SCChongZhiConfigInfo} message PB_SCChongZhiConfigInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCChongZhiConfigInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.infoList = [];
            if (options.defaults) {
                object.currencyType = 0;
                object.infoCount = 0;
            }
            if (message.currencyType != null && message.hasOwnProperty("currencyType"))
                object.currencyType = message.currencyType;
            if (message.infoCount != null && message.hasOwnProperty("infoCount"))
                object.infoCount = message.infoCount;
            if (message.infoList && message.infoList.length) {
                object.infoList = [];
                for (var j = 0; j < message.infoList.length; ++j)
                    object.infoList[j] = $root.PB_ChongzhiInfo.toObject(message.infoList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCChongZhiConfigInfo to JSON.
         * @function toJSON
         * @memberof PB_SCChongZhiConfigInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCChongZhiConfigInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCChongZhiConfigInfo;
    })();
    
    $root.PB_SCRaFriendInfo = (function() {
    
        /**
         * Properties of a PB_SCRaFriendInfo.
         * @exports IPB_SCRaFriendInfo
         * @interface IPB_SCRaFriendInfo
         * @property {number|null} [friendCount] PB_SCRaFriendInfo friendCount
         * @property {number|null} [rewardFlag] PB_SCRaFriendInfo rewardFlag
         */
    
        /**
         * Constructs a new PB_SCRaFriendInfo.
         * @exports PB_SCRaFriendInfo
         * @classdesc Represents a PB_SCRaFriendInfo.
         * @implements IPB_SCRaFriendInfo
         * @constructor
         * @param {IPB_SCRaFriendInfo=} [properties] Properties to set
         */
        function PB_SCRaFriendInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaFriendInfo friendCount.
         * @member {number} friendCount
         * @memberof PB_SCRaFriendInfo
         * @instance
         */
        PB_SCRaFriendInfo.prototype.friendCount = 0;
    
        /**
         * PB_SCRaFriendInfo rewardFlag.
         * @member {number} rewardFlag
         * @memberof PB_SCRaFriendInfo
         * @instance
         */
        PB_SCRaFriendInfo.prototype.rewardFlag = 0;
    
        /**
         * Creates a new PB_SCRaFriendInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaFriendInfo
         * @static
         * @param {IPB_SCRaFriendInfo=} [properties] Properties to set
         * @returns {PB_SCRaFriendInfo} PB_SCRaFriendInfo instance
         */
        PB_SCRaFriendInfo.create = function create(properties) {
            return new PB_SCRaFriendInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaFriendInfo message. Does not implicitly {@link PB_SCRaFriendInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaFriendInfo
         * @static
         * @param {IPB_SCRaFriendInfo} message PB_SCRaFriendInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFriendInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.friendCount != null && Object.hasOwnProperty.call(message, "friendCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.friendCount);
            if (message.rewardFlag != null && Object.hasOwnProperty.call(message, "rewardFlag"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rewardFlag);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaFriendInfo message, length delimited. Does not implicitly {@link PB_SCRaFriendInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaFriendInfo
         * @static
         * @param {IPB_SCRaFriendInfo} message PB_SCRaFriendInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFriendInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaFriendInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaFriendInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaFriendInfo} PB_SCRaFriendInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFriendInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaFriendInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.friendCount = reader.int32();
                    break;
                case 2:
                    message.rewardFlag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaFriendInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaFriendInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaFriendInfo} PB_SCRaFriendInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFriendInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaFriendInfo message.
         * @function verify
         * @memberof PB_SCRaFriendInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaFriendInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.friendCount != null && message.hasOwnProperty("friendCount"))
                if (!$util.isInteger(message.friendCount))
                    return "friendCount: integer expected";
            if (message.rewardFlag != null && message.hasOwnProperty("rewardFlag"))
                if (!$util.isInteger(message.rewardFlag))
                    return "rewardFlag: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaFriendInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaFriendInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaFriendInfo} PB_SCRaFriendInfo
         */
        PB_SCRaFriendInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaFriendInfo)
                return object;
            var message = new $root.PB_SCRaFriendInfo();
            if (object.friendCount != null)
                message.friendCount = object.friendCount | 0;
            if (object.rewardFlag != null)
                message.rewardFlag = object.rewardFlag | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaFriendInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaFriendInfo
         * @static
         * @param {PB_SCRaFriendInfo} message PB_SCRaFriendInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaFriendInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.friendCount = 0;
                object.rewardFlag = 0;
            }
            if (message.friendCount != null && message.hasOwnProperty("friendCount"))
                object.friendCount = message.friendCount;
            if (message.rewardFlag != null && message.hasOwnProperty("rewardFlag"))
                object.rewardFlag = message.rewardFlag;
            return object;
        };
    
        /**
         * Converts this PB_SCRaFriendInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaFriendInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaFriendInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaFriendInfo;
    })();
    
    $root.PB_SCRaNewbeeGiftInfo = (function() {
    
        /**
         * Properties of a PB_SCRaNewbeeGiftInfo.
         * @exports IPB_SCRaNewbeeGiftInfo
         * @interface IPB_SCRaNewbeeGiftInfo
         * @property {number|null} [seq] PB_SCRaNewbeeGiftInfo seq
         */
    
        /**
         * Constructs a new PB_SCRaNewbeeGiftInfo.
         * @exports PB_SCRaNewbeeGiftInfo
         * @classdesc Represents a PB_SCRaNewbeeGiftInfo.
         * @implements IPB_SCRaNewbeeGiftInfo
         * @constructor
         * @param {IPB_SCRaNewbeeGiftInfo=} [properties] Properties to set
         */
        function PB_SCRaNewbeeGiftInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaNewbeeGiftInfo seq.
         * @member {number} seq
         * @memberof PB_SCRaNewbeeGiftInfo
         * @instance
         */
        PB_SCRaNewbeeGiftInfo.prototype.seq = 0;
    
        /**
         * Creates a new PB_SCRaNewbeeGiftInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaNewbeeGiftInfo
         * @static
         * @param {IPB_SCRaNewbeeGiftInfo=} [properties] Properties to set
         * @returns {PB_SCRaNewbeeGiftInfo} PB_SCRaNewbeeGiftInfo instance
         */
        PB_SCRaNewbeeGiftInfo.create = function create(properties) {
            return new PB_SCRaNewbeeGiftInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaNewbeeGiftInfo message. Does not implicitly {@link PB_SCRaNewbeeGiftInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaNewbeeGiftInfo
         * @static
         * @param {IPB_SCRaNewbeeGiftInfo} message PB_SCRaNewbeeGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaNewbeeGiftInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaNewbeeGiftInfo message, length delimited. Does not implicitly {@link PB_SCRaNewbeeGiftInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaNewbeeGiftInfo
         * @static
         * @param {IPB_SCRaNewbeeGiftInfo} message PB_SCRaNewbeeGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaNewbeeGiftInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaNewbeeGiftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaNewbeeGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaNewbeeGiftInfo} PB_SCRaNewbeeGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaNewbeeGiftInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaNewbeeGiftInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaNewbeeGiftInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaNewbeeGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaNewbeeGiftInfo} PB_SCRaNewbeeGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaNewbeeGiftInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaNewbeeGiftInfo message.
         * @function verify
         * @memberof PB_SCRaNewbeeGiftInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaNewbeeGiftInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaNewbeeGiftInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaNewbeeGiftInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaNewbeeGiftInfo} PB_SCRaNewbeeGiftInfo
         */
        PB_SCRaNewbeeGiftInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaNewbeeGiftInfo)
                return object;
            var message = new $root.PB_SCRaNewbeeGiftInfo();
            if (object.seq != null)
                message.seq = object.seq | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaNewbeeGiftInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaNewbeeGiftInfo
         * @static
         * @param {PB_SCRaNewbeeGiftInfo} message PB_SCRaNewbeeGiftInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaNewbeeGiftInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.seq = 0;
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            return object;
        };
    
        /**
         * Converts this PB_SCRaNewbeeGiftInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaNewbeeGiftInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaNewbeeGiftInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaNewbeeGiftInfo;
    })();
    
    $root.PB_SCRAGrowGiftNode = (function() {
    
        /**
         * Properties of a PB_SCRAGrowGiftNode.
         * @exports IPB_SCRAGrowGiftNode
         * @interface IPB_SCRAGrowGiftNode
         * @property {number|null} [seq] PB_SCRAGrowGiftNode seq
         * @property {number|null} [endTime] PB_SCRAGrowGiftNode endTime
         */
    
        /**
         * Constructs a new PB_SCRAGrowGiftNode.
         * @exports PB_SCRAGrowGiftNode
         * @classdesc Represents a PB_SCRAGrowGiftNode.
         * @implements IPB_SCRAGrowGiftNode
         * @constructor
         * @param {IPB_SCRAGrowGiftNode=} [properties] Properties to set
         */
        function PB_SCRAGrowGiftNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRAGrowGiftNode seq.
         * @member {number} seq
         * @memberof PB_SCRAGrowGiftNode
         * @instance
         */
        PB_SCRAGrowGiftNode.prototype.seq = 0;
    
        /**
         * PB_SCRAGrowGiftNode endTime.
         * @member {number} endTime
         * @memberof PB_SCRAGrowGiftNode
         * @instance
         */
        PB_SCRAGrowGiftNode.prototype.endTime = 0;
    
        /**
         * Creates a new PB_SCRAGrowGiftNode instance using the specified properties.
         * @function create
         * @memberof PB_SCRAGrowGiftNode
         * @static
         * @param {IPB_SCRAGrowGiftNode=} [properties] Properties to set
         * @returns {PB_SCRAGrowGiftNode} PB_SCRAGrowGiftNode instance
         */
        PB_SCRAGrowGiftNode.create = function create(properties) {
            return new PB_SCRAGrowGiftNode(properties);
        };
    
        /**
         * Encodes the specified PB_SCRAGrowGiftNode message. Does not implicitly {@link PB_SCRAGrowGiftNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRAGrowGiftNode
         * @static
         * @param {IPB_SCRAGrowGiftNode} message PB_SCRAGrowGiftNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRAGrowGiftNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.endTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRAGrowGiftNode message, length delimited. Does not implicitly {@link PB_SCRAGrowGiftNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRAGrowGiftNode
         * @static
         * @param {IPB_SCRAGrowGiftNode} message PB_SCRAGrowGiftNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRAGrowGiftNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRAGrowGiftNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRAGrowGiftNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRAGrowGiftNode} PB_SCRAGrowGiftNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRAGrowGiftNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRAGrowGiftNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    message.endTime = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRAGrowGiftNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRAGrowGiftNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRAGrowGiftNode} PB_SCRAGrowGiftNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRAGrowGiftNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRAGrowGiftNode message.
         * @function verify
         * @memberof PB_SCRAGrowGiftNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRAGrowGiftNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime))
                    return "endTime: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRAGrowGiftNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRAGrowGiftNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRAGrowGiftNode} PB_SCRAGrowGiftNode
         */
        PB_SCRAGrowGiftNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRAGrowGiftNode)
                return object;
            var message = new $root.PB_SCRAGrowGiftNode();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.endTime != null)
                message.endTime = object.endTime >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRAGrowGiftNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRAGrowGiftNode
         * @static
         * @param {PB_SCRAGrowGiftNode} message PB_SCRAGrowGiftNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRAGrowGiftNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.seq = 0;
                object.endTime = 0;
            }
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };
    
        /**
         * Converts this PB_SCRAGrowGiftNode to JSON.
         * @function toJSON
         * @memberof PB_SCRAGrowGiftNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRAGrowGiftNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRAGrowGiftNode;
    })();
    
    $root.PB_SCRaGrowGiftInfo = (function() {
    
        /**
         * Properties of a PB_SCRaGrowGiftInfo.
         * @exports IPB_SCRaGrowGiftInfo
         * @interface IPB_SCRaGrowGiftInfo
         * @property {Array.<IPB_SCRAGrowGiftNode>|null} [giftList] PB_SCRaGrowGiftInfo giftList
         */
    
        /**
         * Constructs a new PB_SCRaGrowGiftInfo.
         * @exports PB_SCRaGrowGiftInfo
         * @classdesc Represents a PB_SCRaGrowGiftInfo.
         * @implements IPB_SCRaGrowGiftInfo
         * @constructor
         * @param {IPB_SCRaGrowGiftInfo=} [properties] Properties to set
         */
        function PB_SCRaGrowGiftInfo(properties) {
            this.giftList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaGrowGiftInfo giftList.
         * @member {Array.<IPB_SCRAGrowGiftNode>} giftList
         * @memberof PB_SCRaGrowGiftInfo
         * @instance
         */
        PB_SCRaGrowGiftInfo.prototype.giftList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaGrowGiftInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaGrowGiftInfo
         * @static
         * @param {IPB_SCRaGrowGiftInfo=} [properties] Properties to set
         * @returns {PB_SCRaGrowGiftInfo} PB_SCRaGrowGiftInfo instance
         */
        PB_SCRaGrowGiftInfo.create = function create(properties) {
            return new PB_SCRaGrowGiftInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaGrowGiftInfo message. Does not implicitly {@link PB_SCRaGrowGiftInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaGrowGiftInfo
         * @static
         * @param {IPB_SCRaGrowGiftInfo} message PB_SCRaGrowGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaGrowGiftInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.giftList != null && message.giftList.length)
                for (var i = 0; i < message.giftList.length; ++i)
                    $root.PB_SCRAGrowGiftNode.encode(message.giftList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaGrowGiftInfo message, length delimited. Does not implicitly {@link PB_SCRaGrowGiftInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaGrowGiftInfo
         * @static
         * @param {IPB_SCRaGrowGiftInfo} message PB_SCRaGrowGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaGrowGiftInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaGrowGiftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaGrowGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaGrowGiftInfo} PB_SCRaGrowGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaGrowGiftInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaGrowGiftInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.giftList && message.giftList.length))
                        message.giftList = [];
                    message.giftList.push($root.PB_SCRAGrowGiftNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaGrowGiftInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaGrowGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaGrowGiftInfo} PB_SCRaGrowGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaGrowGiftInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaGrowGiftInfo message.
         * @function verify
         * @memberof PB_SCRaGrowGiftInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaGrowGiftInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.giftList != null && message.hasOwnProperty("giftList")) {
                if (!Array.isArray(message.giftList))
                    return "giftList: array expected";
                for (var i = 0; i < message.giftList.length; ++i) {
                    var error = $root.PB_SCRAGrowGiftNode.verify(message.giftList[i]);
                    if (error)
                        return "giftList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaGrowGiftInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaGrowGiftInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaGrowGiftInfo} PB_SCRaGrowGiftInfo
         */
        PB_SCRaGrowGiftInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaGrowGiftInfo)
                return object;
            var message = new $root.PB_SCRaGrowGiftInfo();
            if (object.giftList) {
                if (!Array.isArray(object.giftList))
                    throw TypeError(".PB_SCRaGrowGiftInfo.giftList: array expected");
                message.giftList = [];
                for (var i = 0; i < object.giftList.length; ++i) {
                    if (typeof object.giftList[i] !== "object")
                        throw TypeError(".PB_SCRaGrowGiftInfo.giftList: object expected");
                    message.giftList[i] = $root.PB_SCRAGrowGiftNode.fromObject(object.giftList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaGrowGiftInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaGrowGiftInfo
         * @static
         * @param {PB_SCRaGrowGiftInfo} message PB_SCRaGrowGiftInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaGrowGiftInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.giftList = [];
            if (message.giftList && message.giftList.length) {
                object.giftList = [];
                for (var j = 0; j < message.giftList.length; ++j)
                    object.giftList[j] = $root.PB_SCRAGrowGiftNode.toObject(message.giftList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaGrowGiftInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaGrowGiftInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaGrowGiftInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaGrowGiftInfo;
    })();
    
    $root.PB_SCRaBarrierPackInfo = (function() {
    
        /**
         * Properties of a PB_SCRaBarrierPackInfo.
         * @exports IPB_SCRaBarrierPackInfo
         * @interface IPB_SCRaBarrierPackInfo
         * @property {Array.<boolean>|null} [isBuy] PB_SCRaBarrierPackInfo isBuy
         */
    
        /**
         * Constructs a new PB_SCRaBarrierPackInfo.
         * @exports PB_SCRaBarrierPackInfo
         * @classdesc Represents a PB_SCRaBarrierPackInfo.
         * @implements IPB_SCRaBarrierPackInfo
         * @constructor
         * @param {IPB_SCRaBarrierPackInfo=} [properties] Properties to set
         */
        function PB_SCRaBarrierPackInfo(properties) {
            this.isBuy = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaBarrierPackInfo isBuy.
         * @member {Array.<boolean>} isBuy
         * @memberof PB_SCRaBarrierPackInfo
         * @instance
         */
        PB_SCRaBarrierPackInfo.prototype.isBuy = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaBarrierPackInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaBarrierPackInfo
         * @static
         * @param {IPB_SCRaBarrierPackInfo=} [properties] Properties to set
         * @returns {PB_SCRaBarrierPackInfo} PB_SCRaBarrierPackInfo instance
         */
        PB_SCRaBarrierPackInfo.create = function create(properties) {
            return new PB_SCRaBarrierPackInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaBarrierPackInfo message. Does not implicitly {@link PB_SCRaBarrierPackInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaBarrierPackInfo
         * @static
         * @param {IPB_SCRaBarrierPackInfo} message PB_SCRaBarrierPackInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaBarrierPackInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isBuy != null && message.isBuy.length)
                for (var i = 0; i < message.isBuy.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isBuy[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaBarrierPackInfo message, length delimited. Does not implicitly {@link PB_SCRaBarrierPackInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaBarrierPackInfo
         * @static
         * @param {IPB_SCRaBarrierPackInfo} message PB_SCRaBarrierPackInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaBarrierPackInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaBarrierPackInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaBarrierPackInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaBarrierPackInfo} PB_SCRaBarrierPackInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaBarrierPackInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaBarrierPackInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.isBuy && message.isBuy.length))
                        message.isBuy = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isBuy.push(reader.bool());
                    } else
                        message.isBuy.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaBarrierPackInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaBarrierPackInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaBarrierPackInfo} PB_SCRaBarrierPackInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaBarrierPackInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaBarrierPackInfo message.
         * @function verify
         * @memberof PB_SCRaBarrierPackInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaBarrierPackInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isBuy != null && message.hasOwnProperty("isBuy")) {
                if (!Array.isArray(message.isBuy))
                    return "isBuy: array expected";
                for (var i = 0; i < message.isBuy.length; ++i)
                    if (typeof message.isBuy[i] !== "boolean")
                        return "isBuy: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaBarrierPackInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaBarrierPackInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaBarrierPackInfo} PB_SCRaBarrierPackInfo
         */
        PB_SCRaBarrierPackInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaBarrierPackInfo)
                return object;
            var message = new $root.PB_SCRaBarrierPackInfo();
            if (object.isBuy) {
                if (!Array.isArray(object.isBuy))
                    throw TypeError(".PB_SCRaBarrierPackInfo.isBuy: array expected");
                message.isBuy = [];
                for (var i = 0; i < object.isBuy.length; ++i)
                    message.isBuy[i] = Boolean(object.isBuy[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaBarrierPackInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaBarrierPackInfo
         * @static
         * @param {PB_SCRaBarrierPackInfo} message PB_SCRaBarrierPackInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaBarrierPackInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isBuy = [];
            if (message.isBuy && message.isBuy.length) {
                object.isBuy = [];
                for (var j = 0; j < message.isBuy.length; ++j)
                    object.isBuy[j] = message.isBuy[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaBarrierPackInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaBarrierPackInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaBarrierPackInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaBarrierPackInfo;
    })();
    
    $root.PB_SCRaRoundPassList = (function() {
    
        /**
         * Properties of a PB_SCRaRoundPassList.
         * @exports IPB_SCRaRoundPassList
         * @interface IPB_SCRaRoundPassList
         * @property {boolean|null} [isActive] PB_SCRaRoundPassList isActive
         * @property {Array.<boolean>|null} [isFetch] PB_SCRaRoundPassList isFetch
         */
    
        /**
         * Constructs a new PB_SCRaRoundPassList.
         * @exports PB_SCRaRoundPassList
         * @classdesc Represents a PB_SCRaRoundPassList.
         * @implements IPB_SCRaRoundPassList
         * @constructor
         * @param {IPB_SCRaRoundPassList=} [properties] Properties to set
         */
        function PB_SCRaRoundPassList(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaRoundPassList isActive.
         * @member {boolean} isActive
         * @memberof PB_SCRaRoundPassList
         * @instance
         */
        PB_SCRaRoundPassList.prototype.isActive = false;
    
        /**
         * PB_SCRaRoundPassList isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCRaRoundPassList
         * @instance
         */
        PB_SCRaRoundPassList.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaRoundPassList instance using the specified properties.
         * @function create
         * @memberof PB_SCRaRoundPassList
         * @static
         * @param {IPB_SCRaRoundPassList=} [properties] Properties to set
         * @returns {PB_SCRaRoundPassList} PB_SCRaRoundPassList instance
         */
        PB_SCRaRoundPassList.create = function create(properties) {
            return new PB_SCRaRoundPassList(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaRoundPassList message. Does not implicitly {@link PB_SCRaRoundPassList.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaRoundPassList
         * @static
         * @param {IPB_SCRaRoundPassList} message PB_SCRaRoundPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaRoundPassList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isActive);
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaRoundPassList message, length delimited. Does not implicitly {@link PB_SCRaRoundPassList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaRoundPassList
         * @static
         * @param {IPB_SCRaRoundPassList} message PB_SCRaRoundPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaRoundPassList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaRoundPassList message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaRoundPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaRoundPassList} PB_SCRaRoundPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaRoundPassList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaRoundPassList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.bool();
                    break;
                case 2:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaRoundPassList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaRoundPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaRoundPassList} PB_SCRaRoundPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaRoundPassList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaRoundPassList message.
         * @function verify
         * @memberof PB_SCRaRoundPassList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaRoundPassList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (typeof message.isActive !== "boolean")
                    return "isActive: boolean expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaRoundPassList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaRoundPassList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaRoundPassList} PB_SCRaRoundPassList
         */
        PB_SCRaRoundPassList.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaRoundPassList)
                return object;
            var message = new $root.PB_SCRaRoundPassList();
            if (object.isActive != null)
                message.isActive = Boolean(object.isActive);
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCRaRoundPassList.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaRoundPassList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaRoundPassList
         * @static
         * @param {PB_SCRaRoundPassList} message PB_SCRaRoundPassList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaRoundPassList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (options.defaults)
                object.isActive = false;
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaRoundPassList to JSON.
         * @function toJSON
         * @memberof PB_SCRaRoundPassList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaRoundPassList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaRoundPassList;
    })();
    
    $root.PB_SCRaRoundPassInfo = (function() {
    
        /**
         * Properties of a PB_SCRaRoundPassInfo.
         * @exports IPB_SCRaRoundPassInfo
         * @interface IPB_SCRaRoundPassInfo
         * @property {Array.<IPB_SCRaRoundPassList>|null} [list] PB_SCRaRoundPassInfo list
         * @property {number|null} [passRound] PB_SCRaRoundPassInfo passRound
         */
    
        /**
         * Constructs a new PB_SCRaRoundPassInfo.
         * @exports PB_SCRaRoundPassInfo
         * @classdesc Represents a PB_SCRaRoundPassInfo.
         * @implements IPB_SCRaRoundPassInfo
         * @constructor
         * @param {IPB_SCRaRoundPassInfo=} [properties] Properties to set
         */
        function PB_SCRaRoundPassInfo(properties) {
            this.list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaRoundPassInfo list.
         * @member {Array.<IPB_SCRaRoundPassList>} list
         * @memberof PB_SCRaRoundPassInfo
         * @instance
         */
        PB_SCRaRoundPassInfo.prototype.list = $util.emptyArray;
    
        /**
         * PB_SCRaRoundPassInfo passRound.
         * @member {number} passRound
         * @memberof PB_SCRaRoundPassInfo
         * @instance
         */
        PB_SCRaRoundPassInfo.prototype.passRound = 0;
    
        /**
         * Creates a new PB_SCRaRoundPassInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaRoundPassInfo
         * @static
         * @param {IPB_SCRaRoundPassInfo=} [properties] Properties to set
         * @returns {PB_SCRaRoundPassInfo} PB_SCRaRoundPassInfo instance
         */
        PB_SCRaRoundPassInfo.create = function create(properties) {
            return new PB_SCRaRoundPassInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaRoundPassInfo message. Does not implicitly {@link PB_SCRaRoundPassInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaRoundPassInfo
         * @static
         * @param {IPB_SCRaRoundPassInfo} message PB_SCRaRoundPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaRoundPassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.list.length)
                for (var i = 0; i < message.list.length; ++i)
                    $root.PB_SCRaRoundPassList.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.passRound != null && Object.hasOwnProperty.call(message, "passRound"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.passRound);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaRoundPassInfo message, length delimited. Does not implicitly {@link PB_SCRaRoundPassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaRoundPassInfo
         * @static
         * @param {IPB_SCRaRoundPassInfo} message PB_SCRaRoundPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaRoundPassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaRoundPassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaRoundPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaRoundPassInfo} PB_SCRaRoundPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaRoundPassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaRoundPassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.PB_SCRaRoundPassList.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.passRound = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaRoundPassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaRoundPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaRoundPassInfo} PB_SCRaRoundPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaRoundPassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaRoundPassInfo message.
         * @function verify
         * @memberof PB_SCRaRoundPassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaRoundPassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list))
                    return "list: array expected";
                for (var i = 0; i < message.list.length; ++i) {
                    var error = $root.PB_SCRaRoundPassList.verify(message.list[i]);
                    if (error)
                        return "list." + error;
                }
            }
            if (message.passRound != null && message.hasOwnProperty("passRound"))
                if (!$util.isInteger(message.passRound))
                    return "passRound: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaRoundPassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaRoundPassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaRoundPassInfo} PB_SCRaRoundPassInfo
         */
        PB_SCRaRoundPassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaRoundPassInfo)
                return object;
            var message = new $root.PB_SCRaRoundPassInfo();
            if (object.list) {
                if (!Array.isArray(object.list))
                    throw TypeError(".PB_SCRaRoundPassInfo.list: array expected");
                message.list = [];
                for (var i = 0; i < object.list.length; ++i) {
                    if (typeof object.list[i] !== "object")
                        throw TypeError(".PB_SCRaRoundPassInfo.list: object expected");
                    message.list[i] = $root.PB_SCRaRoundPassList.fromObject(object.list[i]);
                }
            }
            if (object.passRound != null)
                message.passRound = object.passRound | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaRoundPassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaRoundPassInfo
         * @static
         * @param {PB_SCRaRoundPassInfo} message PB_SCRaRoundPassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaRoundPassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.list = [];
            if (options.defaults)
                object.passRound = 0;
            if (message.list && message.list.length) {
                object.list = [];
                for (var j = 0; j < message.list.length; ++j)
                    object.list[j] = $root.PB_SCRaRoundPassList.toObject(message.list[j], options);
            }
            if (message.passRound != null && message.hasOwnProperty("passRound"))
                object.passRound = message.passRound;
            return object;
        };
    
        /**
         * Converts this PB_SCRaRoundPassInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaRoundPassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaRoundPassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaRoundPassInfo;
    })();
    
    $root.PB_SCRaItemBuyInfo = (function() {
    
        /**
         * Properties of a PB_SCRaItemBuyInfo.
         * @exports IPB_SCRaItemBuyInfo
         * @interface IPB_SCRaItemBuyInfo
         * @property {Array.<number>|null} [itemBuyCount] PB_SCRaItemBuyInfo itemBuyCount
         */
    
        /**
         * Constructs a new PB_SCRaItemBuyInfo.
         * @exports PB_SCRaItemBuyInfo
         * @classdesc Represents a PB_SCRaItemBuyInfo.
         * @implements IPB_SCRaItemBuyInfo
         * @constructor
         * @param {IPB_SCRaItemBuyInfo=} [properties] Properties to set
         */
        function PB_SCRaItemBuyInfo(properties) {
            this.itemBuyCount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaItemBuyInfo itemBuyCount.
         * @member {Array.<number>} itemBuyCount
         * @memberof PB_SCRaItemBuyInfo
         * @instance
         */
        PB_SCRaItemBuyInfo.prototype.itemBuyCount = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaItemBuyInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaItemBuyInfo
         * @static
         * @param {IPB_SCRaItemBuyInfo=} [properties] Properties to set
         * @returns {PB_SCRaItemBuyInfo} PB_SCRaItemBuyInfo instance
         */
        PB_SCRaItemBuyInfo.create = function create(properties) {
            return new PB_SCRaItemBuyInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaItemBuyInfo message. Does not implicitly {@link PB_SCRaItemBuyInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaItemBuyInfo
         * @static
         * @param {IPB_SCRaItemBuyInfo} message PB_SCRaItemBuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaItemBuyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemBuyCount != null && message.itemBuyCount.length)
                for (var i = 0; i < message.itemBuyCount.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.itemBuyCount[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaItemBuyInfo message, length delimited. Does not implicitly {@link PB_SCRaItemBuyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaItemBuyInfo
         * @static
         * @param {IPB_SCRaItemBuyInfo} message PB_SCRaItemBuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaItemBuyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaItemBuyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaItemBuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaItemBuyInfo} PB_SCRaItemBuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaItemBuyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaItemBuyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.itemBuyCount && message.itemBuyCount.length))
                        message.itemBuyCount = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemBuyCount.push(reader.uint32());
                    } else
                        message.itemBuyCount.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaItemBuyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaItemBuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaItemBuyInfo} PB_SCRaItemBuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaItemBuyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaItemBuyInfo message.
         * @function verify
         * @memberof PB_SCRaItemBuyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaItemBuyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemBuyCount != null && message.hasOwnProperty("itemBuyCount")) {
                if (!Array.isArray(message.itemBuyCount))
                    return "itemBuyCount: array expected";
                for (var i = 0; i < message.itemBuyCount.length; ++i)
                    if (!$util.isInteger(message.itemBuyCount[i]))
                        return "itemBuyCount: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaItemBuyInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaItemBuyInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaItemBuyInfo} PB_SCRaItemBuyInfo
         */
        PB_SCRaItemBuyInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaItemBuyInfo)
                return object;
            var message = new $root.PB_SCRaItemBuyInfo();
            if (object.itemBuyCount) {
                if (!Array.isArray(object.itemBuyCount))
                    throw TypeError(".PB_SCRaItemBuyInfo.itemBuyCount: array expected");
                message.itemBuyCount = [];
                for (var i = 0; i < object.itemBuyCount.length; ++i)
                    message.itemBuyCount[i] = object.itemBuyCount[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaItemBuyInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaItemBuyInfo
         * @static
         * @param {PB_SCRaItemBuyInfo} message PB_SCRaItemBuyInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaItemBuyInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemBuyCount = [];
            if (message.itemBuyCount && message.itemBuyCount.length) {
                object.itemBuyCount = [];
                for (var j = 0; j < message.itemBuyCount.length; ++j)
                    object.itemBuyCount[j] = message.itemBuyCount[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaItemBuyInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaItemBuyInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaItemBuyInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaItemBuyInfo;
    })();
    
    $root.PB_SCRaTaskInfo = (function() {
    
        /**
         * Properties of a PB_SCRaTaskInfo.
         * @exports IPB_SCRaTaskInfo
         * @interface IPB_SCRaTaskInfo
         * @property {Array.<number>|null} [taskProgress] PB_SCRaTaskInfo taskProgress
         * @property {Array.<boolean>|null} [rewardFetch] PB_SCRaTaskInfo rewardFetch
         */
    
        /**
         * Constructs a new PB_SCRaTaskInfo.
         * @exports PB_SCRaTaskInfo
         * @classdesc Represents a PB_SCRaTaskInfo.
         * @implements IPB_SCRaTaskInfo
         * @constructor
         * @param {IPB_SCRaTaskInfo=} [properties] Properties to set
         */
        function PB_SCRaTaskInfo(properties) {
            this.taskProgress = [];
            this.rewardFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaTaskInfo taskProgress.
         * @member {Array.<number>} taskProgress
         * @memberof PB_SCRaTaskInfo
         * @instance
         */
        PB_SCRaTaskInfo.prototype.taskProgress = $util.emptyArray;
    
        /**
         * PB_SCRaTaskInfo rewardFetch.
         * @member {Array.<boolean>} rewardFetch
         * @memberof PB_SCRaTaskInfo
         * @instance
         */
        PB_SCRaTaskInfo.prototype.rewardFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaTaskInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaTaskInfo
         * @static
         * @param {IPB_SCRaTaskInfo=} [properties] Properties to set
         * @returns {PB_SCRaTaskInfo} PB_SCRaTaskInfo instance
         */
        PB_SCRaTaskInfo.create = function create(properties) {
            return new PB_SCRaTaskInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaTaskInfo message. Does not implicitly {@link PB_SCRaTaskInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaTaskInfo
         * @static
         * @param {IPB_SCRaTaskInfo} message PB_SCRaTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaTaskInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskProgress != null && message.taskProgress.length)
                for (var i = 0; i < message.taskProgress.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.taskProgress[i]);
            if (message.rewardFetch != null && message.rewardFetch.length)
                for (var i = 0; i < message.rewardFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.rewardFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaTaskInfo message, length delimited. Does not implicitly {@link PB_SCRaTaskInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaTaskInfo
         * @static
         * @param {IPB_SCRaTaskInfo} message PB_SCRaTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaTaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaTaskInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaTaskInfo} PB_SCRaTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaTaskInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaTaskInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.taskProgress && message.taskProgress.length))
                        message.taskProgress = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.taskProgress.push(reader.uint32());
                    } else
                        message.taskProgress.push(reader.uint32());
                    break;
                case 2:
                    if (!(message.rewardFetch && message.rewardFetch.length))
                        message.rewardFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rewardFetch.push(reader.bool());
                    } else
                        message.rewardFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaTaskInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaTaskInfo} PB_SCRaTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaTaskInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaTaskInfo message.
         * @function verify
         * @memberof PB_SCRaTaskInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaTaskInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskProgress != null && message.hasOwnProperty("taskProgress")) {
                if (!Array.isArray(message.taskProgress))
                    return "taskProgress: array expected";
                for (var i = 0; i < message.taskProgress.length; ++i)
                    if (!$util.isInteger(message.taskProgress[i]))
                        return "taskProgress: integer[] expected";
            }
            if (message.rewardFetch != null && message.hasOwnProperty("rewardFetch")) {
                if (!Array.isArray(message.rewardFetch))
                    return "rewardFetch: array expected";
                for (var i = 0; i < message.rewardFetch.length; ++i)
                    if (typeof message.rewardFetch[i] !== "boolean")
                        return "rewardFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaTaskInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaTaskInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaTaskInfo} PB_SCRaTaskInfo
         */
        PB_SCRaTaskInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaTaskInfo)
                return object;
            var message = new $root.PB_SCRaTaskInfo();
            if (object.taskProgress) {
                if (!Array.isArray(object.taskProgress))
                    throw TypeError(".PB_SCRaTaskInfo.taskProgress: array expected");
                message.taskProgress = [];
                for (var i = 0; i < object.taskProgress.length; ++i)
                    message.taskProgress[i] = object.taskProgress[i] >>> 0;
            }
            if (object.rewardFetch) {
                if (!Array.isArray(object.rewardFetch))
                    throw TypeError(".PB_SCRaTaskInfo.rewardFetch: array expected");
                message.rewardFetch = [];
                for (var i = 0; i < object.rewardFetch.length; ++i)
                    message.rewardFetch[i] = Boolean(object.rewardFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaTaskInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaTaskInfo
         * @static
         * @param {PB_SCRaTaskInfo} message PB_SCRaTaskInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaTaskInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.taskProgress = [];
                object.rewardFetch = [];
            }
            if (message.taskProgress && message.taskProgress.length) {
                object.taskProgress = [];
                for (var j = 0; j < message.taskProgress.length; ++j)
                    object.taskProgress[j] = message.taskProgress[j];
            }
            if (message.rewardFetch && message.rewardFetch.length) {
                object.rewardFetch = [];
                for (var j = 0; j < message.rewardFetch.length; ++j)
                    object.rewardFetch[j] = message.rewardFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaTaskInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaTaskInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaTaskInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaTaskInfo;
    })();
    
    $root.PB_SCRaTaskBuyInfo = (function() {
    
        /**
         * Properties of a PB_SCRaTaskBuyInfo.
         * @exports IPB_SCRaTaskBuyInfo
         * @interface IPB_SCRaTaskBuyInfo
         * @property {Array.<number>|null} [itemBuyNum] PB_SCRaTaskBuyInfo itemBuyNum
         */
    
        /**
         * Constructs a new PB_SCRaTaskBuyInfo.
         * @exports PB_SCRaTaskBuyInfo
         * @classdesc Represents a PB_SCRaTaskBuyInfo.
         * @implements IPB_SCRaTaskBuyInfo
         * @constructor
         * @param {IPB_SCRaTaskBuyInfo=} [properties] Properties to set
         */
        function PB_SCRaTaskBuyInfo(properties) {
            this.itemBuyNum = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaTaskBuyInfo itemBuyNum.
         * @member {Array.<number>} itemBuyNum
         * @memberof PB_SCRaTaskBuyInfo
         * @instance
         */
        PB_SCRaTaskBuyInfo.prototype.itemBuyNum = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaTaskBuyInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaTaskBuyInfo
         * @static
         * @param {IPB_SCRaTaskBuyInfo=} [properties] Properties to set
         * @returns {PB_SCRaTaskBuyInfo} PB_SCRaTaskBuyInfo instance
         */
        PB_SCRaTaskBuyInfo.create = function create(properties) {
            return new PB_SCRaTaskBuyInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaTaskBuyInfo message. Does not implicitly {@link PB_SCRaTaskBuyInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaTaskBuyInfo
         * @static
         * @param {IPB_SCRaTaskBuyInfo} message PB_SCRaTaskBuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaTaskBuyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemBuyNum != null && message.itemBuyNum.length)
                for (var i = 0; i < message.itemBuyNum.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.itemBuyNum[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaTaskBuyInfo message, length delimited. Does not implicitly {@link PB_SCRaTaskBuyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaTaskBuyInfo
         * @static
         * @param {IPB_SCRaTaskBuyInfo} message PB_SCRaTaskBuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaTaskBuyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaTaskBuyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaTaskBuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaTaskBuyInfo} PB_SCRaTaskBuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaTaskBuyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaTaskBuyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.itemBuyNum && message.itemBuyNum.length))
                        message.itemBuyNum = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemBuyNum.push(reader.uint32());
                    } else
                        message.itemBuyNum.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaTaskBuyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaTaskBuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaTaskBuyInfo} PB_SCRaTaskBuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaTaskBuyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaTaskBuyInfo message.
         * @function verify
         * @memberof PB_SCRaTaskBuyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaTaskBuyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemBuyNum != null && message.hasOwnProperty("itemBuyNum")) {
                if (!Array.isArray(message.itemBuyNum))
                    return "itemBuyNum: array expected";
                for (var i = 0; i < message.itemBuyNum.length; ++i)
                    if (!$util.isInteger(message.itemBuyNum[i]))
                        return "itemBuyNum: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaTaskBuyInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaTaskBuyInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaTaskBuyInfo} PB_SCRaTaskBuyInfo
         */
        PB_SCRaTaskBuyInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaTaskBuyInfo)
                return object;
            var message = new $root.PB_SCRaTaskBuyInfo();
            if (object.itemBuyNum) {
                if (!Array.isArray(object.itemBuyNum))
                    throw TypeError(".PB_SCRaTaskBuyInfo.itemBuyNum: array expected");
                message.itemBuyNum = [];
                for (var i = 0; i < object.itemBuyNum.length; ++i)
                    message.itemBuyNum[i] = object.itemBuyNum[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaTaskBuyInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaTaskBuyInfo
         * @static
         * @param {PB_SCRaTaskBuyInfo} message PB_SCRaTaskBuyInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaTaskBuyInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemBuyNum = [];
            if (message.itemBuyNum && message.itemBuyNum.length) {
                object.itemBuyNum = [];
                for (var j = 0; j < message.itemBuyNum.length; ++j)
                    object.itemBuyNum[j] = message.itemBuyNum[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaTaskBuyInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaTaskBuyInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaTaskBuyInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaTaskBuyInfo;
    })();
    
    $root.PB_SCRaShopGiftNode = (function() {
    
        /**
         * Properties of a PB_SCRaShopGiftNode.
         * @exports IPB_SCRaShopGiftNode
         * @interface IPB_SCRaShopGiftNode
         * @property {number|null} [seq] PB_SCRaShopGiftNode seq
         * @property {number|null} [endTime] PB_SCRaShopGiftNode endTime
         */
    
        /**
         * Constructs a new PB_SCRaShopGiftNode.
         * @exports PB_SCRaShopGiftNode
         * @classdesc Represents a PB_SCRaShopGiftNode.
         * @implements IPB_SCRaShopGiftNode
         * @constructor
         * @param {IPB_SCRaShopGiftNode=} [properties] Properties to set
         */
        function PB_SCRaShopGiftNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaShopGiftNode seq.
         * @member {number} seq
         * @memberof PB_SCRaShopGiftNode
         * @instance
         */
        PB_SCRaShopGiftNode.prototype.seq = 0;
    
        /**
         * PB_SCRaShopGiftNode endTime.
         * @member {number} endTime
         * @memberof PB_SCRaShopGiftNode
         * @instance
         */
        PB_SCRaShopGiftNode.prototype.endTime = 0;
    
        /**
         * Creates a new PB_SCRaShopGiftNode instance using the specified properties.
         * @function create
         * @memberof PB_SCRaShopGiftNode
         * @static
         * @param {IPB_SCRaShopGiftNode=} [properties] Properties to set
         * @returns {PB_SCRaShopGiftNode} PB_SCRaShopGiftNode instance
         */
        PB_SCRaShopGiftNode.create = function create(properties) {
            return new PB_SCRaShopGiftNode(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaShopGiftNode message. Does not implicitly {@link PB_SCRaShopGiftNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaShopGiftNode
         * @static
         * @param {IPB_SCRaShopGiftNode} message PB_SCRaShopGiftNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaShopGiftNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.endTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaShopGiftNode message, length delimited. Does not implicitly {@link PB_SCRaShopGiftNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaShopGiftNode
         * @static
         * @param {IPB_SCRaShopGiftNode} message PB_SCRaShopGiftNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaShopGiftNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaShopGiftNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaShopGiftNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaShopGiftNode} PB_SCRaShopGiftNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaShopGiftNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaShopGiftNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    message.endTime = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaShopGiftNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaShopGiftNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaShopGiftNode} PB_SCRaShopGiftNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaShopGiftNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaShopGiftNode message.
         * @function verify
         * @memberof PB_SCRaShopGiftNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaShopGiftNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime))
                    return "endTime: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaShopGiftNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaShopGiftNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaShopGiftNode} PB_SCRaShopGiftNode
         */
        PB_SCRaShopGiftNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaShopGiftNode)
                return object;
            var message = new $root.PB_SCRaShopGiftNode();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.endTime != null)
                message.endTime = object.endTime >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaShopGiftNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaShopGiftNode
         * @static
         * @param {PB_SCRaShopGiftNode} message PB_SCRaShopGiftNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaShopGiftNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.seq = 0;
                object.endTime = 0;
            }
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };
    
        /**
         * Converts this PB_SCRaShopGiftNode to JSON.
         * @function toJSON
         * @memberof PB_SCRaShopGiftNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaShopGiftNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaShopGiftNode;
    })();
    
    $root.PB_SCRaShopGiftInfo = (function() {
    
        /**
         * Properties of a PB_SCRaShopGiftInfo.
         * @exports IPB_SCRaShopGiftInfo
         * @interface IPB_SCRaShopGiftInfo
         * @property {Array.<IPB_SCRaShopGiftNode>|null} [shopList] PB_SCRaShopGiftInfo shopList
         */
    
        /**
         * Constructs a new PB_SCRaShopGiftInfo.
         * @exports PB_SCRaShopGiftInfo
         * @classdesc Represents a PB_SCRaShopGiftInfo.
         * @implements IPB_SCRaShopGiftInfo
         * @constructor
         * @param {IPB_SCRaShopGiftInfo=} [properties] Properties to set
         */
        function PB_SCRaShopGiftInfo(properties) {
            this.shopList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaShopGiftInfo shopList.
         * @member {Array.<IPB_SCRaShopGiftNode>} shopList
         * @memberof PB_SCRaShopGiftInfo
         * @instance
         */
        PB_SCRaShopGiftInfo.prototype.shopList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaShopGiftInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaShopGiftInfo
         * @static
         * @param {IPB_SCRaShopGiftInfo=} [properties] Properties to set
         * @returns {PB_SCRaShopGiftInfo} PB_SCRaShopGiftInfo instance
         */
        PB_SCRaShopGiftInfo.create = function create(properties) {
            return new PB_SCRaShopGiftInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaShopGiftInfo message. Does not implicitly {@link PB_SCRaShopGiftInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaShopGiftInfo
         * @static
         * @param {IPB_SCRaShopGiftInfo} message PB_SCRaShopGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaShopGiftInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shopList != null && message.shopList.length)
                for (var i = 0; i < message.shopList.length; ++i)
                    $root.PB_SCRaShopGiftNode.encode(message.shopList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaShopGiftInfo message, length delimited. Does not implicitly {@link PB_SCRaShopGiftInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaShopGiftInfo
         * @static
         * @param {IPB_SCRaShopGiftInfo} message PB_SCRaShopGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaShopGiftInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaShopGiftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaShopGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaShopGiftInfo} PB_SCRaShopGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaShopGiftInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaShopGiftInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.shopList && message.shopList.length))
                        message.shopList = [];
                    message.shopList.push($root.PB_SCRaShopGiftNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaShopGiftInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaShopGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaShopGiftInfo} PB_SCRaShopGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaShopGiftInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaShopGiftInfo message.
         * @function verify
         * @memberof PB_SCRaShopGiftInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaShopGiftInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shopList != null && message.hasOwnProperty("shopList")) {
                if (!Array.isArray(message.shopList))
                    return "shopList: array expected";
                for (var i = 0; i < message.shopList.length; ++i) {
                    var error = $root.PB_SCRaShopGiftNode.verify(message.shopList[i]);
                    if (error)
                        return "shopList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaShopGiftInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaShopGiftInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaShopGiftInfo} PB_SCRaShopGiftInfo
         */
        PB_SCRaShopGiftInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaShopGiftInfo)
                return object;
            var message = new $root.PB_SCRaShopGiftInfo();
            if (object.shopList) {
                if (!Array.isArray(object.shopList))
                    throw TypeError(".PB_SCRaShopGiftInfo.shopList: array expected");
                message.shopList = [];
                for (var i = 0; i < object.shopList.length; ++i) {
                    if (typeof object.shopList[i] !== "object")
                        throw TypeError(".PB_SCRaShopGiftInfo.shopList: object expected");
                    message.shopList[i] = $root.PB_SCRaShopGiftNode.fromObject(object.shopList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaShopGiftInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaShopGiftInfo
         * @static
         * @param {PB_SCRaShopGiftInfo} message PB_SCRaShopGiftInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaShopGiftInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shopList = [];
            if (message.shopList && message.shopList.length) {
                object.shopList = [];
                for (var j = 0; j < message.shopList.length; ++j)
                    object.shopList[j] = $root.PB_SCRaShopGiftNode.toObject(message.shopList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaShopGiftInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaShopGiftInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaShopGiftInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaShopGiftInfo;
    })();
    
    $root.PB_SCZombieGoGoGoInfo = (function() {
    
        /**
         * Properties of a PB_SCZombieGoGoGoInfo.
         * @exports IPB_SCZombieGoGoGoInfo
         * @interface IPB_SCZombieGoGoGoInfo
         * @property {Array.<number>|null} [fightCount] PB_SCZombieGoGoGoInfo fightCount
         * @property {Array.<boolean>|null} [killRewardIsFetch] PB_SCZombieGoGoGoInfo killRewardIsFetch
         * @property {number|null} [killNum] PB_SCZombieGoGoGoInfo killNum
         * @property {number|null} [dailyWeakness] PB_SCZombieGoGoGoInfo dailyWeakness
         */
    
        /**
         * Constructs a new PB_SCZombieGoGoGoInfo.
         * @exports PB_SCZombieGoGoGoInfo
         * @classdesc Represents a PB_SCZombieGoGoGoInfo.
         * @implements IPB_SCZombieGoGoGoInfo
         * @constructor
         * @param {IPB_SCZombieGoGoGoInfo=} [properties] Properties to set
         */
        function PB_SCZombieGoGoGoInfo(properties) {
            this.fightCount = [];
            this.killRewardIsFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCZombieGoGoGoInfo fightCount.
         * @member {Array.<number>} fightCount
         * @memberof PB_SCZombieGoGoGoInfo
         * @instance
         */
        PB_SCZombieGoGoGoInfo.prototype.fightCount = $util.emptyArray;
    
        /**
         * PB_SCZombieGoGoGoInfo killRewardIsFetch.
         * @member {Array.<boolean>} killRewardIsFetch
         * @memberof PB_SCZombieGoGoGoInfo
         * @instance
         */
        PB_SCZombieGoGoGoInfo.prototype.killRewardIsFetch = $util.emptyArray;
    
        /**
         * PB_SCZombieGoGoGoInfo killNum.
         * @member {number} killNum
         * @memberof PB_SCZombieGoGoGoInfo
         * @instance
         */
        PB_SCZombieGoGoGoInfo.prototype.killNum = 0;
    
        /**
         * PB_SCZombieGoGoGoInfo dailyWeakness.
         * @member {number} dailyWeakness
         * @memberof PB_SCZombieGoGoGoInfo
         * @instance
         */
        PB_SCZombieGoGoGoInfo.prototype.dailyWeakness = 0;
    
        /**
         * Creates a new PB_SCZombieGoGoGoInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCZombieGoGoGoInfo
         * @static
         * @param {IPB_SCZombieGoGoGoInfo=} [properties] Properties to set
         * @returns {PB_SCZombieGoGoGoInfo} PB_SCZombieGoGoGoInfo instance
         */
        PB_SCZombieGoGoGoInfo.create = function create(properties) {
            return new PB_SCZombieGoGoGoInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCZombieGoGoGoInfo message. Does not implicitly {@link PB_SCZombieGoGoGoInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCZombieGoGoGoInfo
         * @static
         * @param {IPB_SCZombieGoGoGoInfo} message PB_SCZombieGoGoGoInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCZombieGoGoGoInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fightCount != null && message.fightCount.length)
                for (var i = 0; i < message.fightCount.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fightCount[i]);
            if (message.killRewardIsFetch != null && message.killRewardIsFetch.length)
                for (var i = 0; i < message.killRewardIsFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.killRewardIsFetch[i]);
            if (message.killNum != null && Object.hasOwnProperty.call(message, "killNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.killNum);
            if (message.dailyWeakness != null && Object.hasOwnProperty.call(message, "dailyWeakness"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.dailyWeakness);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCZombieGoGoGoInfo message, length delimited. Does not implicitly {@link PB_SCZombieGoGoGoInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCZombieGoGoGoInfo
         * @static
         * @param {IPB_SCZombieGoGoGoInfo} message PB_SCZombieGoGoGoInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCZombieGoGoGoInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCZombieGoGoGoInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCZombieGoGoGoInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCZombieGoGoGoInfo} PB_SCZombieGoGoGoInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCZombieGoGoGoInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCZombieGoGoGoInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.fightCount && message.fightCount.length))
                        message.fightCount = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.fightCount.push(reader.int32());
                    } else
                        message.fightCount.push(reader.int32());
                    break;
                case 2:
                    if (!(message.killRewardIsFetch && message.killRewardIsFetch.length))
                        message.killRewardIsFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.killRewardIsFetch.push(reader.bool());
                    } else
                        message.killRewardIsFetch.push(reader.bool());
                    break;
                case 3:
                    message.killNum = reader.int32();
                    break;
                case 4:
                    message.dailyWeakness = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCZombieGoGoGoInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCZombieGoGoGoInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCZombieGoGoGoInfo} PB_SCZombieGoGoGoInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCZombieGoGoGoInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCZombieGoGoGoInfo message.
         * @function verify
         * @memberof PB_SCZombieGoGoGoInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCZombieGoGoGoInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fightCount != null && message.hasOwnProperty("fightCount")) {
                if (!Array.isArray(message.fightCount))
                    return "fightCount: array expected";
                for (var i = 0; i < message.fightCount.length; ++i)
                    if (!$util.isInteger(message.fightCount[i]))
                        return "fightCount: integer[] expected";
            }
            if (message.killRewardIsFetch != null && message.hasOwnProperty("killRewardIsFetch")) {
                if (!Array.isArray(message.killRewardIsFetch))
                    return "killRewardIsFetch: array expected";
                for (var i = 0; i < message.killRewardIsFetch.length; ++i)
                    if (typeof message.killRewardIsFetch[i] !== "boolean")
                        return "killRewardIsFetch: boolean[] expected";
            }
            if (message.killNum != null && message.hasOwnProperty("killNum"))
                if (!$util.isInteger(message.killNum))
                    return "killNum: integer expected";
            if (message.dailyWeakness != null && message.hasOwnProperty("dailyWeakness"))
                if (!$util.isInteger(message.dailyWeakness))
                    return "dailyWeakness: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCZombieGoGoGoInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCZombieGoGoGoInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCZombieGoGoGoInfo} PB_SCZombieGoGoGoInfo
         */
        PB_SCZombieGoGoGoInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCZombieGoGoGoInfo)
                return object;
            var message = new $root.PB_SCZombieGoGoGoInfo();
            if (object.fightCount) {
                if (!Array.isArray(object.fightCount))
                    throw TypeError(".PB_SCZombieGoGoGoInfo.fightCount: array expected");
                message.fightCount = [];
                for (var i = 0; i < object.fightCount.length; ++i)
                    message.fightCount[i] = object.fightCount[i] | 0;
            }
            if (object.killRewardIsFetch) {
                if (!Array.isArray(object.killRewardIsFetch))
                    throw TypeError(".PB_SCZombieGoGoGoInfo.killRewardIsFetch: array expected");
                message.killRewardIsFetch = [];
                for (var i = 0; i < object.killRewardIsFetch.length; ++i)
                    message.killRewardIsFetch[i] = Boolean(object.killRewardIsFetch[i]);
            }
            if (object.killNum != null)
                message.killNum = object.killNum | 0;
            if (object.dailyWeakness != null)
                message.dailyWeakness = object.dailyWeakness | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCZombieGoGoGoInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCZombieGoGoGoInfo
         * @static
         * @param {PB_SCZombieGoGoGoInfo} message PB_SCZombieGoGoGoInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCZombieGoGoGoInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fightCount = [];
                object.killRewardIsFetch = [];
            }
            if (options.defaults) {
                object.killNum = 0;
                object.dailyWeakness = 0;
            }
            if (message.fightCount && message.fightCount.length) {
                object.fightCount = [];
                for (var j = 0; j < message.fightCount.length; ++j)
                    object.fightCount[j] = message.fightCount[j];
            }
            if (message.killRewardIsFetch && message.killRewardIsFetch.length) {
                object.killRewardIsFetch = [];
                for (var j = 0; j < message.killRewardIsFetch.length; ++j)
                    object.killRewardIsFetch[j] = message.killRewardIsFetch[j];
            }
            if (message.killNum != null && message.hasOwnProperty("killNum"))
                object.killNum = message.killNum;
            if (message.dailyWeakness != null && message.hasOwnProperty("dailyWeakness"))
                object.dailyWeakness = message.dailyWeakness;
            return object;
        };
    
        /**
         * Converts this PB_SCZombieGoGoGoInfo to JSON.
         * @function toJSON
         * @memberof PB_SCZombieGoGoGoInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCZombieGoGoGoInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCZombieGoGoGoInfo;
    })();
    
    $root.PB_RALostTempleRemainsBox = (function() {
    
        /**
         * Properties of a PB_RALostTempleRemainsBox.
         * @exports IPB_RALostTempleRemainsBox
         * @interface IPB_RALostTempleRemainsBox
         * @property {Array.<number>|null} [remainsId] PB_RALostTempleRemainsBox remainsId
         * @property {Array.<number>|null} [isActive] PB_RALostTempleRemainsBox isActive
         */
    
        /**
         * Constructs a new PB_RALostTempleRemainsBox.
         * @exports PB_RALostTempleRemainsBox
         * @classdesc Represents a PB_RALostTempleRemainsBox.
         * @implements IPB_RALostTempleRemainsBox
         * @constructor
         * @param {IPB_RALostTempleRemainsBox=} [properties] Properties to set
         */
        function PB_RALostTempleRemainsBox(properties) {
            this.remainsId = [];
            this.isActive = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RALostTempleRemainsBox remainsId.
         * @member {Array.<number>} remainsId
         * @memberof PB_RALostTempleRemainsBox
         * @instance
         */
        PB_RALostTempleRemainsBox.prototype.remainsId = $util.emptyArray;
    
        /**
         * PB_RALostTempleRemainsBox isActive.
         * @member {Array.<number>} isActive
         * @memberof PB_RALostTempleRemainsBox
         * @instance
         */
        PB_RALostTempleRemainsBox.prototype.isActive = $util.emptyArray;
    
        /**
         * Creates a new PB_RALostTempleRemainsBox instance using the specified properties.
         * @function create
         * @memberof PB_RALostTempleRemainsBox
         * @static
         * @param {IPB_RALostTempleRemainsBox=} [properties] Properties to set
         * @returns {PB_RALostTempleRemainsBox} PB_RALostTempleRemainsBox instance
         */
        PB_RALostTempleRemainsBox.create = function create(properties) {
            return new PB_RALostTempleRemainsBox(properties);
        };
    
        /**
         * Encodes the specified PB_RALostTempleRemainsBox message. Does not implicitly {@link PB_RALostTempleRemainsBox.verify|verify} messages.
         * @function encode
         * @memberof PB_RALostTempleRemainsBox
         * @static
         * @param {IPB_RALostTempleRemainsBox} message PB_RALostTempleRemainsBox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTempleRemainsBox.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.remainsId != null && message.remainsId.length)
                for (var i = 0; i < message.remainsId.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.remainsId[i]);
            if (message.isActive != null && message.isActive.length)
                for (var i = 0; i < message.isActive.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isActive[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RALostTempleRemainsBox message, length delimited. Does not implicitly {@link PB_RALostTempleRemainsBox.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RALostTempleRemainsBox
         * @static
         * @param {IPB_RALostTempleRemainsBox} message PB_RALostTempleRemainsBox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTempleRemainsBox.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RALostTempleRemainsBox message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RALostTempleRemainsBox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RALostTempleRemainsBox} PB_RALostTempleRemainsBox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTempleRemainsBox.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RALostTempleRemainsBox();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.remainsId && message.remainsId.length))
                        message.remainsId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.remainsId.push(reader.int32());
                    } else
                        message.remainsId.push(reader.int32());
                    break;
                case 2:
                    if (!(message.isActive && message.isActive.length))
                        message.isActive = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isActive.push(reader.int32());
                    } else
                        message.isActive.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RALostTempleRemainsBox message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RALostTempleRemainsBox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RALostTempleRemainsBox} PB_RALostTempleRemainsBox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTempleRemainsBox.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RALostTempleRemainsBox message.
         * @function verify
         * @memberof PB_RALostTempleRemainsBox
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RALostTempleRemainsBox.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.remainsId != null && message.hasOwnProperty("remainsId")) {
                if (!Array.isArray(message.remainsId))
                    return "remainsId: array expected";
                for (var i = 0; i < message.remainsId.length; ++i)
                    if (!$util.isInteger(message.remainsId[i]))
                        return "remainsId: integer[] expected";
            }
            if (message.isActive != null && message.hasOwnProperty("isActive")) {
                if (!Array.isArray(message.isActive))
                    return "isActive: array expected";
                for (var i = 0; i < message.isActive.length; ++i)
                    if (!$util.isInteger(message.isActive[i]))
                        return "isActive: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_RALostTempleRemainsBox message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RALostTempleRemainsBox
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RALostTempleRemainsBox} PB_RALostTempleRemainsBox
         */
        PB_RALostTempleRemainsBox.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RALostTempleRemainsBox)
                return object;
            var message = new $root.PB_RALostTempleRemainsBox();
            if (object.remainsId) {
                if (!Array.isArray(object.remainsId))
                    throw TypeError(".PB_RALostTempleRemainsBox.remainsId: array expected");
                message.remainsId = [];
                for (var i = 0; i < object.remainsId.length; ++i)
                    message.remainsId[i] = object.remainsId[i] | 0;
            }
            if (object.isActive) {
                if (!Array.isArray(object.isActive))
                    throw TypeError(".PB_RALostTempleRemainsBox.isActive: array expected");
                message.isActive = [];
                for (var i = 0; i < object.isActive.length; ++i)
                    message.isActive[i] = object.isActive[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RALostTempleRemainsBox message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RALostTempleRemainsBox
         * @static
         * @param {PB_RALostTempleRemainsBox} message PB_RALostTempleRemainsBox
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RALostTempleRemainsBox.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.remainsId = [];
                object.isActive = [];
            }
            if (message.remainsId && message.remainsId.length) {
                object.remainsId = [];
                for (var j = 0; j < message.remainsId.length; ++j)
                    object.remainsId[j] = message.remainsId[j];
            }
            if (message.isActive && message.isActive.length) {
                object.isActive = [];
                for (var j = 0; j < message.isActive.length; ++j)
                    object.isActive[j] = message.isActive[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_RALostTempleRemainsBox to JSON.
         * @function toJSON
         * @memberof PB_RALostTempleRemainsBox
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RALostTempleRemainsBox.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RALostTempleRemainsBox;
    })();
    
    $root.PB_RALostTempleBonfire = (function() {
    
        /**
         * Properties of a PB_RALostTempleBonfire.
         * @exports IPB_RALostTempleBonfire
         * @interface IPB_RALostTempleBonfire
         * @property {Array.<number>|null} [isActive] PB_RALostTempleBonfire isActive
         */
    
        /**
         * Constructs a new PB_RALostTempleBonfire.
         * @exports PB_RALostTempleBonfire
         * @classdesc Represents a PB_RALostTempleBonfire.
         * @implements IPB_RALostTempleBonfire
         * @constructor
         * @param {IPB_RALostTempleBonfire=} [properties] Properties to set
         */
        function PB_RALostTempleBonfire(properties) {
            this.isActive = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RALostTempleBonfire isActive.
         * @member {Array.<number>} isActive
         * @memberof PB_RALostTempleBonfire
         * @instance
         */
        PB_RALostTempleBonfire.prototype.isActive = $util.emptyArray;
    
        /**
         * Creates a new PB_RALostTempleBonfire instance using the specified properties.
         * @function create
         * @memberof PB_RALostTempleBonfire
         * @static
         * @param {IPB_RALostTempleBonfire=} [properties] Properties to set
         * @returns {PB_RALostTempleBonfire} PB_RALostTempleBonfire instance
         */
        PB_RALostTempleBonfire.create = function create(properties) {
            return new PB_RALostTempleBonfire(properties);
        };
    
        /**
         * Encodes the specified PB_RALostTempleBonfire message. Does not implicitly {@link PB_RALostTempleBonfire.verify|verify} messages.
         * @function encode
         * @memberof PB_RALostTempleBonfire
         * @static
         * @param {IPB_RALostTempleBonfire} message PB_RALostTempleBonfire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTempleBonfire.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && message.isActive.length)
                for (var i = 0; i < message.isActive.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isActive[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RALostTempleBonfire message, length delimited. Does not implicitly {@link PB_RALostTempleBonfire.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RALostTempleBonfire
         * @static
         * @param {IPB_RALostTempleBonfire} message PB_RALostTempleBonfire message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTempleBonfire.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RALostTempleBonfire message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RALostTempleBonfire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RALostTempleBonfire} PB_RALostTempleBonfire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTempleBonfire.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RALostTempleBonfire();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.isActive && message.isActive.length))
                        message.isActive = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isActive.push(reader.int32());
                    } else
                        message.isActive.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RALostTempleBonfire message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RALostTempleBonfire
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RALostTempleBonfire} PB_RALostTempleBonfire
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTempleBonfire.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RALostTempleBonfire message.
         * @function verify
         * @memberof PB_RALostTempleBonfire
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RALostTempleBonfire.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive")) {
                if (!Array.isArray(message.isActive))
                    return "isActive: array expected";
                for (var i = 0; i < message.isActive.length; ++i)
                    if (!$util.isInteger(message.isActive[i]))
                        return "isActive: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_RALostTempleBonfire message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RALostTempleBonfire
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RALostTempleBonfire} PB_RALostTempleBonfire
         */
        PB_RALostTempleBonfire.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RALostTempleBonfire)
                return object;
            var message = new $root.PB_RALostTempleBonfire();
            if (object.isActive) {
                if (!Array.isArray(object.isActive))
                    throw TypeError(".PB_RALostTempleBonfire.isActive: array expected");
                message.isActive = [];
                for (var i = 0; i < object.isActive.length; ++i)
                    message.isActive[i] = object.isActive[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RALostTempleBonfire message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RALostTempleBonfire
         * @static
         * @param {PB_RALostTempleBonfire} message PB_RALostTempleBonfire
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RALostTempleBonfire.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isActive = [];
            if (message.isActive && message.isActive.length) {
                object.isActive = [];
                for (var j = 0; j < message.isActive.length; ++j)
                    object.isActive[j] = message.isActive[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_RALostTempleBonfire to JSON.
         * @function toJSON
         * @memberof PB_RALostTempleBonfire
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RALostTempleBonfire.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RALostTempleBonfire;
    })();
    
    $root.PB_RALostTemplePub = (function() {
    
        /**
         * Properties of a PB_RALostTemplePub.
         * @exports IPB_RALostTemplePub
         * @interface IPB_RALostTemplePub
         * @property {Array.<number>|null} [isActive] PB_RALostTemplePub isActive
         * @property {number|null} [eventId] PB_RALostTemplePub eventId
         */
    
        /**
         * Constructs a new PB_RALostTemplePub.
         * @exports PB_RALostTemplePub
         * @classdesc Represents a PB_RALostTemplePub.
         * @implements IPB_RALostTemplePub
         * @constructor
         * @param {IPB_RALostTemplePub=} [properties] Properties to set
         */
        function PB_RALostTemplePub(properties) {
            this.isActive = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RALostTemplePub isActive.
         * @member {Array.<number>} isActive
         * @memberof PB_RALostTemplePub
         * @instance
         */
        PB_RALostTemplePub.prototype.isActive = $util.emptyArray;
    
        /**
         * PB_RALostTemplePub eventId.
         * @member {number} eventId
         * @memberof PB_RALostTemplePub
         * @instance
         */
        PB_RALostTemplePub.prototype.eventId = 0;
    
        /**
         * Creates a new PB_RALostTemplePub instance using the specified properties.
         * @function create
         * @memberof PB_RALostTemplePub
         * @static
         * @param {IPB_RALostTemplePub=} [properties] Properties to set
         * @returns {PB_RALostTemplePub} PB_RALostTemplePub instance
         */
        PB_RALostTemplePub.create = function create(properties) {
            return new PB_RALostTemplePub(properties);
        };
    
        /**
         * Encodes the specified PB_RALostTemplePub message. Does not implicitly {@link PB_RALostTemplePub.verify|verify} messages.
         * @function encode
         * @memberof PB_RALostTemplePub
         * @static
         * @param {IPB_RALostTemplePub} message PB_RALostTemplePub message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTemplePub.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && message.isActive.length)
                for (var i = 0; i < message.isActive.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isActive[i]);
            if (message.eventId != null && Object.hasOwnProperty.call(message, "eventId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventId);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RALostTemplePub message, length delimited. Does not implicitly {@link PB_RALostTemplePub.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RALostTemplePub
         * @static
         * @param {IPB_RALostTemplePub} message PB_RALostTemplePub message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTemplePub.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RALostTemplePub message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RALostTemplePub
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RALostTemplePub} PB_RALostTemplePub
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTemplePub.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RALostTemplePub();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.isActive && message.isActive.length))
                        message.isActive = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isActive.push(reader.int32());
                    } else
                        message.isActive.push(reader.int32());
                    break;
                case 2:
                    message.eventId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RALostTemplePub message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RALostTemplePub
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RALostTemplePub} PB_RALostTemplePub
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTemplePub.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RALostTemplePub message.
         * @function verify
         * @memberof PB_RALostTemplePub
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RALostTemplePub.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive")) {
                if (!Array.isArray(message.isActive))
                    return "isActive: array expected";
                for (var i = 0; i < message.isActive.length; ++i)
                    if (!$util.isInteger(message.isActive[i]))
                        return "isActive: integer[] expected";
            }
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                if (!$util.isInteger(message.eventId))
                    return "eventId: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_RALostTemplePub message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RALostTemplePub
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RALostTemplePub} PB_RALostTemplePub
         */
        PB_RALostTemplePub.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RALostTemplePub)
                return object;
            var message = new $root.PB_RALostTemplePub();
            if (object.isActive) {
                if (!Array.isArray(object.isActive))
                    throw TypeError(".PB_RALostTemplePub.isActive: array expected");
                message.isActive = [];
                for (var i = 0; i < object.isActive.length; ++i)
                    message.isActive[i] = object.isActive[i] | 0;
            }
            if (object.eventId != null)
                message.eventId = object.eventId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RALostTemplePub message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RALostTemplePub
         * @static
         * @param {PB_RALostTemplePub} message PB_RALostTemplePub
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RALostTemplePub.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isActive = [];
            if (options.defaults)
                object.eventId = 0;
            if (message.isActive && message.isActive.length) {
                object.isActive = [];
                for (var j = 0; j < message.isActive.length; ++j)
                    object.isActive[j] = message.isActive[j];
            }
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                object.eventId = message.eventId;
            return object;
        };
    
        /**
         * Converts this PB_RALostTemplePub to JSON.
         * @function toJSON
         * @memberof PB_RALostTemplePub
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RALostTemplePub.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RALostTemplePub;
    })();
    
    $root.PB_RALostTempleMysteriousShop = (function() {
    
        /**
         * Properties of a PB_RALostTempleMysteriousShop.
         * @exports IPB_RALostTempleMysteriousShop
         * @interface IPB_RALostTempleMysteriousShop
         * @property {number|null} [shopIndex] PB_RALostTempleMysteriousShop shopIndex
         * @property {number|null} [eventId] PB_RALostTempleMysteriousShop eventId
         * @property {Array.<number>|null} [buyCount] PB_RALostTempleMysteriousShop buyCount
         * @property {number|null} [endTime] PB_RALostTempleMysteriousShop endTime
         */
    
        /**
         * Constructs a new PB_RALostTempleMysteriousShop.
         * @exports PB_RALostTempleMysteriousShop
         * @classdesc Represents a PB_RALostTempleMysteriousShop.
         * @implements IPB_RALostTempleMysteriousShop
         * @constructor
         * @param {IPB_RALostTempleMysteriousShop=} [properties] Properties to set
         */
        function PB_RALostTempleMysteriousShop(properties) {
            this.buyCount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RALostTempleMysteriousShop shopIndex.
         * @member {number} shopIndex
         * @memberof PB_RALostTempleMysteriousShop
         * @instance
         */
        PB_RALostTempleMysteriousShop.prototype.shopIndex = 0;
    
        /**
         * PB_RALostTempleMysteriousShop eventId.
         * @member {number} eventId
         * @memberof PB_RALostTempleMysteriousShop
         * @instance
         */
        PB_RALostTempleMysteriousShop.prototype.eventId = 0;
    
        /**
         * PB_RALostTempleMysteriousShop buyCount.
         * @member {Array.<number>} buyCount
         * @memberof PB_RALostTempleMysteriousShop
         * @instance
         */
        PB_RALostTempleMysteriousShop.prototype.buyCount = $util.emptyArray;
    
        /**
         * PB_RALostTempleMysteriousShop endTime.
         * @member {number} endTime
         * @memberof PB_RALostTempleMysteriousShop
         * @instance
         */
        PB_RALostTempleMysteriousShop.prototype.endTime = 0;
    
        /**
         * Creates a new PB_RALostTempleMysteriousShop instance using the specified properties.
         * @function create
         * @memberof PB_RALostTempleMysteriousShop
         * @static
         * @param {IPB_RALostTempleMysteriousShop=} [properties] Properties to set
         * @returns {PB_RALostTempleMysteriousShop} PB_RALostTempleMysteriousShop instance
         */
        PB_RALostTempleMysteriousShop.create = function create(properties) {
            return new PB_RALostTempleMysteriousShop(properties);
        };
    
        /**
         * Encodes the specified PB_RALostTempleMysteriousShop message. Does not implicitly {@link PB_RALostTempleMysteriousShop.verify|verify} messages.
         * @function encode
         * @memberof PB_RALostTempleMysteriousShop
         * @static
         * @param {IPB_RALostTempleMysteriousShop} message PB_RALostTempleMysteriousShop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTempleMysteriousShop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shopIndex != null && Object.hasOwnProperty.call(message, "shopIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.shopIndex);
            if (message.eventId != null && Object.hasOwnProperty.call(message, "eventId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.eventId);
            if (message.buyCount != null && message.buyCount.length)
                for (var i = 0; i < message.buyCount.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.buyCount[i]);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.endTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RALostTempleMysteriousShop message, length delimited. Does not implicitly {@link PB_RALostTempleMysteriousShop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RALostTempleMysteriousShop
         * @static
         * @param {IPB_RALostTempleMysteriousShop} message PB_RALostTempleMysteriousShop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTempleMysteriousShop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RALostTempleMysteriousShop message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RALostTempleMysteriousShop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RALostTempleMysteriousShop} PB_RALostTempleMysteriousShop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTempleMysteriousShop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RALostTempleMysteriousShop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shopIndex = reader.int32();
                    break;
                case 2:
                    message.eventId = reader.int32();
                    break;
                case 3:
                    if (!(message.buyCount && message.buyCount.length))
                        message.buyCount = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.buyCount.push(reader.int32());
                    } else
                        message.buyCount.push(reader.int32());
                    break;
                case 4:
                    message.endTime = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RALostTempleMysteriousShop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RALostTempleMysteriousShop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RALostTempleMysteriousShop} PB_RALostTempleMysteriousShop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTempleMysteriousShop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RALostTempleMysteriousShop message.
         * @function verify
         * @memberof PB_RALostTempleMysteriousShop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RALostTempleMysteriousShop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shopIndex != null && message.hasOwnProperty("shopIndex"))
                if (!$util.isInteger(message.shopIndex))
                    return "shopIndex: integer expected";
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                if (!$util.isInteger(message.eventId))
                    return "eventId: integer expected";
            if (message.buyCount != null && message.hasOwnProperty("buyCount")) {
                if (!Array.isArray(message.buyCount))
                    return "buyCount: array expected";
                for (var i = 0; i < message.buyCount.length; ++i)
                    if (!$util.isInteger(message.buyCount[i]))
                        return "buyCount: integer[] expected";
            }
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime))
                    return "endTime: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_RALostTempleMysteriousShop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RALostTempleMysteriousShop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RALostTempleMysteriousShop} PB_RALostTempleMysteriousShop
         */
        PB_RALostTempleMysteriousShop.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RALostTempleMysteriousShop)
                return object;
            var message = new $root.PB_RALostTempleMysteriousShop();
            if (object.shopIndex != null)
                message.shopIndex = object.shopIndex | 0;
            if (object.eventId != null)
                message.eventId = object.eventId | 0;
            if (object.buyCount) {
                if (!Array.isArray(object.buyCount))
                    throw TypeError(".PB_RALostTempleMysteriousShop.buyCount: array expected");
                message.buyCount = [];
                for (var i = 0; i < object.buyCount.length; ++i)
                    message.buyCount[i] = object.buyCount[i] | 0;
            }
            if (object.endTime != null)
                message.endTime = object.endTime >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RALostTempleMysteriousShop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RALostTempleMysteriousShop
         * @static
         * @param {PB_RALostTempleMysteriousShop} message PB_RALostTempleMysteriousShop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RALostTempleMysteriousShop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.buyCount = [];
            if (options.defaults) {
                object.shopIndex = 0;
                object.eventId = 0;
                object.endTime = 0;
            }
            if (message.shopIndex != null && message.hasOwnProperty("shopIndex"))
                object.shopIndex = message.shopIndex;
            if (message.eventId != null && message.hasOwnProperty("eventId"))
                object.eventId = message.eventId;
            if (message.buyCount && message.buyCount.length) {
                object.buyCount = [];
                for (var j = 0; j < message.buyCount.length; ++j)
                    object.buyCount[j] = message.buyCount[j];
            }
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };
    
        /**
         * Converts this PB_RALostTempleMysteriousShop to JSON.
         * @function toJSON
         * @memberof PB_RALostTempleMysteriousShop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RALostTempleMysteriousShop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RALostTempleMysteriousShop;
    })();
    
    $root.PB_RALostTemplePubHero = (function() {
    
        /**
         * Properties of a PB_RALostTemplePubHero.
         * @exports IPB_RALostTemplePubHero
         * @interface IPB_RALostTemplePubHero
         * @property {number|null} [heroId] PB_RALostTemplePubHero heroId
         * @property {number|null} [heroLevel] PB_RALostTemplePubHero heroLevel
         * @property {number|null} [energy] PB_RALostTemplePubHero energy
         */
    
        /**
         * Constructs a new PB_RALostTemplePubHero.
         * @exports PB_RALostTemplePubHero
         * @classdesc Represents a PB_RALostTemplePubHero.
         * @implements IPB_RALostTemplePubHero
         * @constructor
         * @param {IPB_RALostTemplePubHero=} [properties] Properties to set
         */
        function PB_RALostTemplePubHero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RALostTemplePubHero heroId.
         * @member {number} heroId
         * @memberof PB_RALostTemplePubHero
         * @instance
         */
        PB_RALostTemplePubHero.prototype.heroId = 0;
    
        /**
         * PB_RALostTemplePubHero heroLevel.
         * @member {number} heroLevel
         * @memberof PB_RALostTemplePubHero
         * @instance
         */
        PB_RALostTemplePubHero.prototype.heroLevel = 0;
    
        /**
         * PB_RALostTemplePubHero energy.
         * @member {number} energy
         * @memberof PB_RALostTemplePubHero
         * @instance
         */
        PB_RALostTemplePubHero.prototype.energy = 0;
    
        /**
         * Creates a new PB_RALostTemplePubHero instance using the specified properties.
         * @function create
         * @memberof PB_RALostTemplePubHero
         * @static
         * @param {IPB_RALostTemplePubHero=} [properties] Properties to set
         * @returns {PB_RALostTemplePubHero} PB_RALostTemplePubHero instance
         */
        PB_RALostTemplePubHero.create = function create(properties) {
            return new PB_RALostTemplePubHero(properties);
        };
    
        /**
         * Encodes the specified PB_RALostTemplePubHero message. Does not implicitly {@link PB_RALostTemplePubHero.verify|verify} messages.
         * @function encode
         * @memberof PB_RALostTemplePubHero
         * @static
         * @param {IPB_RALostTemplePubHero} message PB_RALostTemplePubHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTemplePubHero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.heroId);
            if (message.heroLevel != null && Object.hasOwnProperty.call(message, "heroLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroLevel);
            if (message.energy != null && Object.hasOwnProperty.call(message, "energy"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.energy);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RALostTemplePubHero message, length delimited. Does not implicitly {@link PB_RALostTemplePubHero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RALostTemplePubHero
         * @static
         * @param {IPB_RALostTemplePubHero} message PB_RALostTemplePubHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RALostTemplePubHero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RALostTemplePubHero message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RALostTemplePubHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RALostTemplePubHero} PB_RALostTemplePubHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTemplePubHero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RALostTemplePubHero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroId = reader.int32();
                    break;
                case 2:
                    message.heroLevel = reader.int32();
                    break;
                case 3:
                    message.energy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RALostTemplePubHero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RALostTemplePubHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RALostTemplePubHero} PB_RALostTemplePubHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RALostTemplePubHero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RALostTemplePubHero message.
         * @function verify
         * @memberof PB_RALostTemplePubHero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RALostTemplePubHero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                if (!$util.isInteger(message.heroLevel))
                    return "heroLevel: integer expected";
            if (message.energy != null && message.hasOwnProperty("energy"))
                if (!$util.isInteger(message.energy))
                    return "energy: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_RALostTemplePubHero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RALostTemplePubHero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RALostTemplePubHero} PB_RALostTemplePubHero
         */
        PB_RALostTemplePubHero.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RALostTemplePubHero)
                return object;
            var message = new $root.PB_RALostTemplePubHero();
            if (object.heroId != null)
                message.heroId = object.heroId | 0;
            if (object.heroLevel != null)
                message.heroLevel = object.heroLevel | 0;
            if (object.energy != null)
                message.energy = object.energy | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RALostTemplePubHero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RALostTemplePubHero
         * @static
         * @param {PB_RALostTemplePubHero} message PB_RALostTemplePubHero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RALostTemplePubHero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.heroId = 0;
                object.heroLevel = 0;
                object.energy = 0;
            }
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.heroLevel != null && message.hasOwnProperty("heroLevel"))
                object.heroLevel = message.heroLevel;
            if (message.energy != null && message.hasOwnProperty("energy"))
                object.energy = message.energy;
            return object;
        };
    
        /**
         * Converts this PB_RALostTemplePubHero to JSON.
         * @function toJSON
         * @memberof PB_RALostTemplePubHero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RALostTemplePubHero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RALostTemplePubHero;
    })();
    
    $root.PB_SCLostTempleInfo = (function() {
    
        /**
         * Properties of a PB_SCLostTempleInfo.
         * @exports IPB_SCLostTempleInfo
         * @interface IPB_SCLostTempleInfo
         * @property {number|null} [passDiff] PB_SCLostTempleInfo passDiff
         * @property {number|null} [energyNum] PB_SCLostTempleInfo energyNum
         * @property {number|null} [nowDiff] PB_SCLostTempleInfo nowDiff
         * @property {number|null} [nowStorey] PB_SCLostTempleInfo nowStorey
         * @property {number|null} [nowLine] PB_SCLostTempleInfo nowLine
         * @property {number|null} [nowBlock] PB_SCLostTempleInfo nowBlock
         * @property {number|null} [nowBlockPass] PB_SCLostTempleInfo nowBlockPass
         * @property {IPB_RALostTempleRemainsBox|null} [remainsBox] PB_SCLostTempleInfo remainsBox
         * @property {IPB_RALostTempleBonfire|null} [bonfire] PB_SCLostTempleInfo bonfire
         * @property {IPB_RALostTemplePub|null} [pub] PB_SCLostTempleInfo pub
         * @property {Array.<IPB_RALostTempleMysteriousShop>|null} [shopList] PB_SCLostTempleInfo shopList
         * @property {Array.<IPB_RALostTemplePubHero>|null} [pubHeroList] PB_SCLostTempleInfo pubHeroList
         * @property {Array.<number>|null} [remainsList] PB_SCLostTempleInfo remainsList
         * @property {Array.<number>|null} [fightHeroId] PB_SCLostTempleInfo fightHeroId
         * @property {Array.<number>|null} [moveBlock] PB_SCLostTempleInfo moveBlock
         */
    
        /**
         * Constructs a new PB_SCLostTempleInfo.
         * @exports PB_SCLostTempleInfo
         * @classdesc Represents a PB_SCLostTempleInfo.
         * @implements IPB_SCLostTempleInfo
         * @constructor
         * @param {IPB_SCLostTempleInfo=} [properties] Properties to set
         */
        function PB_SCLostTempleInfo(properties) {
            this.shopList = [];
            this.pubHeroList = [];
            this.remainsList = [];
            this.fightHeroId = [];
            this.moveBlock = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCLostTempleInfo passDiff.
         * @member {number} passDiff
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.passDiff = 0;
    
        /**
         * PB_SCLostTempleInfo energyNum.
         * @member {number} energyNum
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.energyNum = 0;
    
        /**
         * PB_SCLostTempleInfo nowDiff.
         * @member {number} nowDiff
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.nowDiff = 0;
    
        /**
         * PB_SCLostTempleInfo nowStorey.
         * @member {number} nowStorey
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.nowStorey = 0;
    
        /**
         * PB_SCLostTempleInfo nowLine.
         * @member {number} nowLine
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.nowLine = 0;
    
        /**
         * PB_SCLostTempleInfo nowBlock.
         * @member {number} nowBlock
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.nowBlock = 0;
    
        /**
         * PB_SCLostTempleInfo nowBlockPass.
         * @member {number} nowBlockPass
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.nowBlockPass = 0;
    
        /**
         * PB_SCLostTempleInfo remainsBox.
         * @member {IPB_RALostTempleRemainsBox|null|undefined} remainsBox
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.remainsBox = null;
    
        /**
         * PB_SCLostTempleInfo bonfire.
         * @member {IPB_RALostTempleBonfire|null|undefined} bonfire
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.bonfire = null;
    
        /**
         * PB_SCLostTempleInfo pub.
         * @member {IPB_RALostTemplePub|null|undefined} pub
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.pub = null;
    
        /**
         * PB_SCLostTempleInfo shopList.
         * @member {Array.<IPB_RALostTempleMysteriousShop>} shopList
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.shopList = $util.emptyArray;
    
        /**
         * PB_SCLostTempleInfo pubHeroList.
         * @member {Array.<IPB_RALostTemplePubHero>} pubHeroList
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.pubHeroList = $util.emptyArray;
    
        /**
         * PB_SCLostTempleInfo remainsList.
         * @member {Array.<number>} remainsList
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.remainsList = $util.emptyArray;
    
        /**
         * PB_SCLostTempleInfo fightHeroId.
         * @member {Array.<number>} fightHeroId
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.fightHeroId = $util.emptyArray;
    
        /**
         * PB_SCLostTempleInfo moveBlock.
         * @member {Array.<number>} moveBlock
         * @memberof PB_SCLostTempleInfo
         * @instance
         */
        PB_SCLostTempleInfo.prototype.moveBlock = $util.emptyArray;
    
        /**
         * Creates a new PB_SCLostTempleInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCLostTempleInfo
         * @static
         * @param {IPB_SCLostTempleInfo=} [properties] Properties to set
         * @returns {PB_SCLostTempleInfo} PB_SCLostTempleInfo instance
         */
        PB_SCLostTempleInfo.create = function create(properties) {
            return new PB_SCLostTempleInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCLostTempleInfo message. Does not implicitly {@link PB_SCLostTempleInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCLostTempleInfo
         * @static
         * @param {IPB_SCLostTempleInfo} message PB_SCLostTempleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.passDiff != null && Object.hasOwnProperty.call(message, "passDiff"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.passDiff);
            if (message.energyNum != null && Object.hasOwnProperty.call(message, "energyNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.energyNum);
            if (message.nowDiff != null && Object.hasOwnProperty.call(message, "nowDiff"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.nowDiff);
            if (message.nowStorey != null && Object.hasOwnProperty.call(message, "nowStorey"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.nowStorey);
            if (message.nowLine != null && Object.hasOwnProperty.call(message, "nowLine"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.nowLine);
            if (message.nowBlock != null && Object.hasOwnProperty.call(message, "nowBlock"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.nowBlock);
            if (message.nowBlockPass != null && Object.hasOwnProperty.call(message, "nowBlockPass"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.nowBlockPass);
            if (message.remainsBox != null && Object.hasOwnProperty.call(message, "remainsBox"))
                $root.PB_RALostTempleRemainsBox.encode(message.remainsBox, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.bonfire != null && Object.hasOwnProperty.call(message, "bonfire"))
                $root.PB_RALostTempleBonfire.encode(message.bonfire, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.pub != null && Object.hasOwnProperty.call(message, "pub"))
                $root.PB_RALostTemplePub.encode(message.pub, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.shopList != null && message.shopList.length)
                for (var i = 0; i < message.shopList.length; ++i)
                    $root.PB_RALostTempleMysteriousShop.encode(message.shopList[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.pubHeroList != null && message.pubHeroList.length)
                for (var i = 0; i < message.pubHeroList.length; ++i)
                    $root.PB_RALostTemplePubHero.encode(message.pubHeroList[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.remainsList != null && message.remainsList.length)
                for (var i = 0; i < message.remainsList.length; ++i)
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.remainsList[i]);
            if (message.fightHeroId != null && message.fightHeroId.length)
                for (var i = 0; i < message.fightHeroId.length; ++i)
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.fightHeroId[i]);
            if (message.moveBlock != null && message.moveBlock.length)
                for (var i = 0; i < message.moveBlock.length; ++i)
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.moveBlock[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCLostTempleInfo message, length delimited. Does not implicitly {@link PB_SCLostTempleInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCLostTempleInfo
         * @static
         * @param {IPB_SCLostTempleInfo} message PB_SCLostTempleInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCLostTempleInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCLostTempleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCLostTempleInfo} PB_SCLostTempleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCLostTempleInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.passDiff = reader.int32();
                    break;
                case 2:
                    message.energyNum = reader.int32();
                    break;
                case 3:
                    message.nowDiff = reader.int32();
                    break;
                case 4:
                    message.nowStorey = reader.int32();
                    break;
                case 5:
                    message.nowLine = reader.int32();
                    break;
                case 6:
                    message.nowBlock = reader.int32();
                    break;
                case 7:
                    message.nowBlockPass = reader.int32();
                    break;
                case 8:
                    message.remainsBox = $root.PB_RALostTempleRemainsBox.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.bonfire = $root.PB_RALostTempleBonfire.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.pub = $root.PB_RALostTemplePub.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.shopList && message.shopList.length))
                        message.shopList = [];
                    message.shopList.push($root.PB_RALostTempleMysteriousShop.decode(reader, reader.uint32()));
                    break;
                case 12:
                    if (!(message.pubHeroList && message.pubHeroList.length))
                        message.pubHeroList = [];
                    message.pubHeroList.push($root.PB_RALostTemplePubHero.decode(reader, reader.uint32()));
                    break;
                case 13:
                    if (!(message.remainsList && message.remainsList.length))
                        message.remainsList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.remainsList.push(reader.int32());
                    } else
                        message.remainsList.push(reader.int32());
                    break;
                case 14:
                    if (!(message.fightHeroId && message.fightHeroId.length))
                        message.fightHeroId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.fightHeroId.push(reader.int32());
                    } else
                        message.fightHeroId.push(reader.int32());
                    break;
                case 15:
                    if (!(message.moveBlock && message.moveBlock.length))
                        message.moveBlock = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.moveBlock.push(reader.int32());
                    } else
                        message.moveBlock.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCLostTempleInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCLostTempleInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCLostTempleInfo} PB_SCLostTempleInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCLostTempleInfo message.
         * @function verify
         * @memberof PB_SCLostTempleInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCLostTempleInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.passDiff != null && message.hasOwnProperty("passDiff"))
                if (!$util.isInteger(message.passDiff))
                    return "passDiff: integer expected";
            if (message.energyNum != null && message.hasOwnProperty("energyNum"))
                if (!$util.isInteger(message.energyNum))
                    return "energyNum: integer expected";
            if (message.nowDiff != null && message.hasOwnProperty("nowDiff"))
                if (!$util.isInteger(message.nowDiff))
                    return "nowDiff: integer expected";
            if (message.nowStorey != null && message.hasOwnProperty("nowStorey"))
                if (!$util.isInteger(message.nowStorey))
                    return "nowStorey: integer expected";
            if (message.nowLine != null && message.hasOwnProperty("nowLine"))
                if (!$util.isInteger(message.nowLine))
                    return "nowLine: integer expected";
            if (message.nowBlock != null && message.hasOwnProperty("nowBlock"))
                if (!$util.isInteger(message.nowBlock))
                    return "nowBlock: integer expected";
            if (message.nowBlockPass != null && message.hasOwnProperty("nowBlockPass"))
                if (!$util.isInteger(message.nowBlockPass))
                    return "nowBlockPass: integer expected";
            if (message.remainsBox != null && message.hasOwnProperty("remainsBox")) {
                var error = $root.PB_RALostTempleRemainsBox.verify(message.remainsBox);
                if (error)
                    return "remainsBox." + error;
            }
            if (message.bonfire != null && message.hasOwnProperty("bonfire")) {
                var error = $root.PB_RALostTempleBonfire.verify(message.bonfire);
                if (error)
                    return "bonfire." + error;
            }
            if (message.pub != null && message.hasOwnProperty("pub")) {
                var error = $root.PB_RALostTemplePub.verify(message.pub);
                if (error)
                    return "pub." + error;
            }
            if (message.shopList != null && message.hasOwnProperty("shopList")) {
                if (!Array.isArray(message.shopList))
                    return "shopList: array expected";
                for (var i = 0; i < message.shopList.length; ++i) {
                    var error = $root.PB_RALostTempleMysteriousShop.verify(message.shopList[i]);
                    if (error)
                        return "shopList." + error;
                }
            }
            if (message.pubHeroList != null && message.hasOwnProperty("pubHeroList")) {
                if (!Array.isArray(message.pubHeroList))
                    return "pubHeroList: array expected";
                for (var i = 0; i < message.pubHeroList.length; ++i) {
                    var error = $root.PB_RALostTemplePubHero.verify(message.pubHeroList[i]);
                    if (error)
                        return "pubHeroList." + error;
                }
            }
            if (message.remainsList != null && message.hasOwnProperty("remainsList")) {
                if (!Array.isArray(message.remainsList))
                    return "remainsList: array expected";
                for (var i = 0; i < message.remainsList.length; ++i)
                    if (!$util.isInteger(message.remainsList[i]))
                        return "remainsList: integer[] expected";
            }
            if (message.fightHeroId != null && message.hasOwnProperty("fightHeroId")) {
                if (!Array.isArray(message.fightHeroId))
                    return "fightHeroId: array expected";
                for (var i = 0; i < message.fightHeroId.length; ++i)
                    if (!$util.isInteger(message.fightHeroId[i]))
                        return "fightHeroId: integer[] expected";
            }
            if (message.moveBlock != null && message.hasOwnProperty("moveBlock")) {
                if (!Array.isArray(message.moveBlock))
                    return "moveBlock: array expected";
                for (var i = 0; i < message.moveBlock.length; ++i)
                    if (!$util.isInteger(message.moveBlock[i]))
                        return "moveBlock: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCLostTempleInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCLostTempleInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCLostTempleInfo} PB_SCLostTempleInfo
         */
        PB_SCLostTempleInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCLostTempleInfo)
                return object;
            var message = new $root.PB_SCLostTempleInfo();
            if (object.passDiff != null)
                message.passDiff = object.passDiff | 0;
            if (object.energyNum != null)
                message.energyNum = object.energyNum | 0;
            if (object.nowDiff != null)
                message.nowDiff = object.nowDiff | 0;
            if (object.nowStorey != null)
                message.nowStorey = object.nowStorey | 0;
            if (object.nowLine != null)
                message.nowLine = object.nowLine | 0;
            if (object.nowBlock != null)
                message.nowBlock = object.nowBlock | 0;
            if (object.nowBlockPass != null)
                message.nowBlockPass = object.nowBlockPass | 0;
            if (object.remainsBox != null) {
                if (typeof object.remainsBox !== "object")
                    throw TypeError(".PB_SCLostTempleInfo.remainsBox: object expected");
                message.remainsBox = $root.PB_RALostTempleRemainsBox.fromObject(object.remainsBox);
            }
            if (object.bonfire != null) {
                if (typeof object.bonfire !== "object")
                    throw TypeError(".PB_SCLostTempleInfo.bonfire: object expected");
                message.bonfire = $root.PB_RALostTempleBonfire.fromObject(object.bonfire);
            }
            if (object.pub != null) {
                if (typeof object.pub !== "object")
                    throw TypeError(".PB_SCLostTempleInfo.pub: object expected");
                message.pub = $root.PB_RALostTemplePub.fromObject(object.pub);
            }
            if (object.shopList) {
                if (!Array.isArray(object.shopList))
                    throw TypeError(".PB_SCLostTempleInfo.shopList: array expected");
                message.shopList = [];
                for (var i = 0; i < object.shopList.length; ++i) {
                    if (typeof object.shopList[i] !== "object")
                        throw TypeError(".PB_SCLostTempleInfo.shopList: object expected");
                    message.shopList[i] = $root.PB_RALostTempleMysteriousShop.fromObject(object.shopList[i]);
                }
            }
            if (object.pubHeroList) {
                if (!Array.isArray(object.pubHeroList))
                    throw TypeError(".PB_SCLostTempleInfo.pubHeroList: array expected");
                message.pubHeroList = [];
                for (var i = 0; i < object.pubHeroList.length; ++i) {
                    if (typeof object.pubHeroList[i] !== "object")
                        throw TypeError(".PB_SCLostTempleInfo.pubHeroList: object expected");
                    message.pubHeroList[i] = $root.PB_RALostTemplePubHero.fromObject(object.pubHeroList[i]);
                }
            }
            if (object.remainsList) {
                if (!Array.isArray(object.remainsList))
                    throw TypeError(".PB_SCLostTempleInfo.remainsList: array expected");
                message.remainsList = [];
                for (var i = 0; i < object.remainsList.length; ++i)
                    message.remainsList[i] = object.remainsList[i] | 0;
            }
            if (object.fightHeroId) {
                if (!Array.isArray(object.fightHeroId))
                    throw TypeError(".PB_SCLostTempleInfo.fightHeroId: array expected");
                message.fightHeroId = [];
                for (var i = 0; i < object.fightHeroId.length; ++i)
                    message.fightHeroId[i] = object.fightHeroId[i] | 0;
            }
            if (object.moveBlock) {
                if (!Array.isArray(object.moveBlock))
                    throw TypeError(".PB_SCLostTempleInfo.moveBlock: array expected");
                message.moveBlock = [];
                for (var i = 0; i < object.moveBlock.length; ++i)
                    message.moveBlock[i] = object.moveBlock[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCLostTempleInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCLostTempleInfo
         * @static
         * @param {PB_SCLostTempleInfo} message PB_SCLostTempleInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCLostTempleInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.shopList = [];
                object.pubHeroList = [];
                object.remainsList = [];
                object.fightHeroId = [];
                object.moveBlock = [];
            }
            if (options.defaults) {
                object.passDiff = 0;
                object.energyNum = 0;
                object.nowDiff = 0;
                object.nowStorey = 0;
                object.nowLine = 0;
                object.nowBlock = 0;
                object.nowBlockPass = 0;
                object.remainsBox = null;
                object.bonfire = null;
                object.pub = null;
            }
            if (message.passDiff != null && message.hasOwnProperty("passDiff"))
                object.passDiff = message.passDiff;
            if (message.energyNum != null && message.hasOwnProperty("energyNum"))
                object.energyNum = message.energyNum;
            if (message.nowDiff != null && message.hasOwnProperty("nowDiff"))
                object.nowDiff = message.nowDiff;
            if (message.nowStorey != null && message.hasOwnProperty("nowStorey"))
                object.nowStorey = message.nowStorey;
            if (message.nowLine != null && message.hasOwnProperty("nowLine"))
                object.nowLine = message.nowLine;
            if (message.nowBlock != null && message.hasOwnProperty("nowBlock"))
                object.nowBlock = message.nowBlock;
            if (message.nowBlockPass != null && message.hasOwnProperty("nowBlockPass"))
                object.nowBlockPass = message.nowBlockPass;
            if (message.remainsBox != null && message.hasOwnProperty("remainsBox"))
                object.remainsBox = $root.PB_RALostTempleRemainsBox.toObject(message.remainsBox, options);
            if (message.bonfire != null && message.hasOwnProperty("bonfire"))
                object.bonfire = $root.PB_RALostTempleBonfire.toObject(message.bonfire, options);
            if (message.pub != null && message.hasOwnProperty("pub"))
                object.pub = $root.PB_RALostTemplePub.toObject(message.pub, options);
            if (message.shopList && message.shopList.length) {
                object.shopList = [];
                for (var j = 0; j < message.shopList.length; ++j)
                    object.shopList[j] = $root.PB_RALostTempleMysteriousShop.toObject(message.shopList[j], options);
            }
            if (message.pubHeroList && message.pubHeroList.length) {
                object.pubHeroList = [];
                for (var j = 0; j < message.pubHeroList.length; ++j)
                    object.pubHeroList[j] = $root.PB_RALostTemplePubHero.toObject(message.pubHeroList[j], options);
            }
            if (message.remainsList && message.remainsList.length) {
                object.remainsList = [];
                for (var j = 0; j < message.remainsList.length; ++j)
                    object.remainsList[j] = message.remainsList[j];
            }
            if (message.fightHeroId && message.fightHeroId.length) {
                object.fightHeroId = [];
                for (var j = 0; j < message.fightHeroId.length; ++j)
                    object.fightHeroId[j] = message.fightHeroId[j];
            }
            if (message.moveBlock && message.moveBlock.length) {
                object.moveBlock = [];
                for (var j = 0; j < message.moveBlock.length; ++j)
                    object.moveBlock[j] = message.moveBlock[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCLostTempleInfo to JSON.
         * @function toJSON
         * @memberof PB_SCLostTempleInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCLostTempleInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCLostTempleInfo;
    })();
    
    $root.PB_SCLostTempleShopInfo = (function() {
    
        /**
         * Properties of a PB_SCLostTempleShopInfo.
         * @exports IPB_SCLostTempleShopInfo
         * @interface IPB_SCLostTempleShopInfo
         * @property {Array.<number>|null} [templeShopBuyCount] PB_SCLostTempleShopInfo templeShopBuyCount
         */
    
        /**
         * Constructs a new PB_SCLostTempleShopInfo.
         * @exports PB_SCLostTempleShopInfo
         * @classdesc Represents a PB_SCLostTempleShopInfo.
         * @implements IPB_SCLostTempleShopInfo
         * @constructor
         * @param {IPB_SCLostTempleShopInfo=} [properties] Properties to set
         */
        function PB_SCLostTempleShopInfo(properties) {
            this.templeShopBuyCount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCLostTempleShopInfo templeShopBuyCount.
         * @member {Array.<number>} templeShopBuyCount
         * @memberof PB_SCLostTempleShopInfo
         * @instance
         */
        PB_SCLostTempleShopInfo.prototype.templeShopBuyCount = $util.emptyArray;
    
        /**
         * Creates a new PB_SCLostTempleShopInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCLostTempleShopInfo
         * @static
         * @param {IPB_SCLostTempleShopInfo=} [properties] Properties to set
         * @returns {PB_SCLostTempleShopInfo} PB_SCLostTempleShopInfo instance
         */
        PB_SCLostTempleShopInfo.create = function create(properties) {
            return new PB_SCLostTempleShopInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCLostTempleShopInfo message. Does not implicitly {@link PB_SCLostTempleShopInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCLostTempleShopInfo
         * @static
         * @param {IPB_SCLostTempleShopInfo} message PB_SCLostTempleShopInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleShopInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.templeShopBuyCount != null && message.templeShopBuyCount.length)
                for (var i = 0; i < message.templeShopBuyCount.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.templeShopBuyCount[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCLostTempleShopInfo message, length delimited. Does not implicitly {@link PB_SCLostTempleShopInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCLostTempleShopInfo
         * @static
         * @param {IPB_SCLostTempleShopInfo} message PB_SCLostTempleShopInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleShopInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCLostTempleShopInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCLostTempleShopInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCLostTempleShopInfo} PB_SCLostTempleShopInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleShopInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCLostTempleShopInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.templeShopBuyCount && message.templeShopBuyCount.length))
                        message.templeShopBuyCount = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.templeShopBuyCount.push(reader.int32());
                    } else
                        message.templeShopBuyCount.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCLostTempleShopInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCLostTempleShopInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCLostTempleShopInfo} PB_SCLostTempleShopInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleShopInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCLostTempleShopInfo message.
         * @function verify
         * @memberof PB_SCLostTempleShopInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCLostTempleShopInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.templeShopBuyCount != null && message.hasOwnProperty("templeShopBuyCount")) {
                if (!Array.isArray(message.templeShopBuyCount))
                    return "templeShopBuyCount: array expected";
                for (var i = 0; i < message.templeShopBuyCount.length; ++i)
                    if (!$util.isInteger(message.templeShopBuyCount[i]))
                        return "templeShopBuyCount: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCLostTempleShopInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCLostTempleShopInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCLostTempleShopInfo} PB_SCLostTempleShopInfo
         */
        PB_SCLostTempleShopInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCLostTempleShopInfo)
                return object;
            var message = new $root.PB_SCLostTempleShopInfo();
            if (object.templeShopBuyCount) {
                if (!Array.isArray(object.templeShopBuyCount))
                    throw TypeError(".PB_SCLostTempleShopInfo.templeShopBuyCount: array expected");
                message.templeShopBuyCount = [];
                for (var i = 0; i < object.templeShopBuyCount.length; ++i)
                    message.templeShopBuyCount[i] = object.templeShopBuyCount[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCLostTempleShopInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCLostTempleShopInfo
         * @static
         * @param {PB_SCLostTempleShopInfo} message PB_SCLostTempleShopInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCLostTempleShopInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.templeShopBuyCount = [];
            if (message.templeShopBuyCount && message.templeShopBuyCount.length) {
                object.templeShopBuyCount = [];
                for (var j = 0; j < message.templeShopBuyCount.length; ++j)
                    object.templeShopBuyCount[j] = message.templeShopBuyCount[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCLostTempleShopInfo to JSON.
         * @function toJSON
         * @memberof PB_SCLostTempleShopInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCLostTempleShopInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCLostTempleShopInfo;
    })();
    
    $root.PB_SCLostTempleMissionInfo = (function() {
    
        /**
         * Properties of a PB_SCLostTempleMissionInfo.
         * @exports IPB_SCLostTempleMissionInfo
         * @interface IPB_SCLostTempleMissionInfo
         * @property {Array.<number>|null} [missionProgress] PB_SCLostTempleMissionInfo missionProgress
         * @property {Array.<boolean>|null} [missionFetch] PB_SCLostTempleMissionInfo missionFetch
         * @property {Array.<boolean>|null} [missionRewardFetchFlag] PB_SCLostTempleMissionInfo missionRewardFetchFlag
         */
    
        /**
         * Constructs a new PB_SCLostTempleMissionInfo.
         * @exports PB_SCLostTempleMissionInfo
         * @classdesc Represents a PB_SCLostTempleMissionInfo.
         * @implements IPB_SCLostTempleMissionInfo
         * @constructor
         * @param {IPB_SCLostTempleMissionInfo=} [properties] Properties to set
         */
        function PB_SCLostTempleMissionInfo(properties) {
            this.missionProgress = [];
            this.missionFetch = [];
            this.missionRewardFetchFlag = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCLostTempleMissionInfo missionProgress.
         * @member {Array.<number>} missionProgress
         * @memberof PB_SCLostTempleMissionInfo
         * @instance
         */
        PB_SCLostTempleMissionInfo.prototype.missionProgress = $util.emptyArray;
    
        /**
         * PB_SCLostTempleMissionInfo missionFetch.
         * @member {Array.<boolean>} missionFetch
         * @memberof PB_SCLostTempleMissionInfo
         * @instance
         */
        PB_SCLostTempleMissionInfo.prototype.missionFetch = $util.emptyArray;
    
        /**
         * PB_SCLostTempleMissionInfo missionRewardFetchFlag.
         * @member {Array.<boolean>} missionRewardFetchFlag
         * @memberof PB_SCLostTempleMissionInfo
         * @instance
         */
        PB_SCLostTempleMissionInfo.prototype.missionRewardFetchFlag = $util.emptyArray;
    
        /**
         * Creates a new PB_SCLostTempleMissionInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCLostTempleMissionInfo
         * @static
         * @param {IPB_SCLostTempleMissionInfo=} [properties] Properties to set
         * @returns {PB_SCLostTempleMissionInfo} PB_SCLostTempleMissionInfo instance
         */
        PB_SCLostTempleMissionInfo.create = function create(properties) {
            return new PB_SCLostTempleMissionInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCLostTempleMissionInfo message. Does not implicitly {@link PB_SCLostTempleMissionInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCLostTempleMissionInfo
         * @static
         * @param {IPB_SCLostTempleMissionInfo} message PB_SCLostTempleMissionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleMissionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.missionProgress != null && message.missionProgress.length)
                for (var i = 0; i < message.missionProgress.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.missionProgress[i]);
            if (message.missionFetch != null && message.missionFetch.length)
                for (var i = 0; i < message.missionFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.missionFetch[i]);
            if (message.missionRewardFetchFlag != null && message.missionRewardFetchFlag.length)
                for (var i = 0; i < message.missionRewardFetchFlag.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.missionRewardFetchFlag[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCLostTempleMissionInfo message, length delimited. Does not implicitly {@link PB_SCLostTempleMissionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCLostTempleMissionInfo
         * @static
         * @param {IPB_SCLostTempleMissionInfo} message PB_SCLostTempleMissionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleMissionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCLostTempleMissionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCLostTempleMissionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCLostTempleMissionInfo} PB_SCLostTempleMissionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleMissionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCLostTempleMissionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.missionProgress && message.missionProgress.length))
                        message.missionProgress = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.missionProgress.push(reader.int32());
                    } else
                        message.missionProgress.push(reader.int32());
                    break;
                case 2:
                    if (!(message.missionFetch && message.missionFetch.length))
                        message.missionFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.missionFetch.push(reader.bool());
                    } else
                        message.missionFetch.push(reader.bool());
                    break;
                case 3:
                    if (!(message.missionRewardFetchFlag && message.missionRewardFetchFlag.length))
                        message.missionRewardFetchFlag = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.missionRewardFetchFlag.push(reader.bool());
                    } else
                        message.missionRewardFetchFlag.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCLostTempleMissionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCLostTempleMissionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCLostTempleMissionInfo} PB_SCLostTempleMissionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleMissionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCLostTempleMissionInfo message.
         * @function verify
         * @memberof PB_SCLostTempleMissionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCLostTempleMissionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.missionProgress != null && message.hasOwnProperty("missionProgress")) {
                if (!Array.isArray(message.missionProgress))
                    return "missionProgress: array expected";
                for (var i = 0; i < message.missionProgress.length; ++i)
                    if (!$util.isInteger(message.missionProgress[i]))
                        return "missionProgress: integer[] expected";
            }
            if (message.missionFetch != null && message.hasOwnProperty("missionFetch")) {
                if (!Array.isArray(message.missionFetch))
                    return "missionFetch: array expected";
                for (var i = 0; i < message.missionFetch.length; ++i)
                    if (typeof message.missionFetch[i] !== "boolean")
                        return "missionFetch: boolean[] expected";
            }
            if (message.missionRewardFetchFlag != null && message.hasOwnProperty("missionRewardFetchFlag")) {
                if (!Array.isArray(message.missionRewardFetchFlag))
                    return "missionRewardFetchFlag: array expected";
                for (var i = 0; i < message.missionRewardFetchFlag.length; ++i)
                    if (typeof message.missionRewardFetchFlag[i] !== "boolean")
                        return "missionRewardFetchFlag: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCLostTempleMissionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCLostTempleMissionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCLostTempleMissionInfo} PB_SCLostTempleMissionInfo
         */
        PB_SCLostTempleMissionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCLostTempleMissionInfo)
                return object;
            var message = new $root.PB_SCLostTempleMissionInfo();
            if (object.missionProgress) {
                if (!Array.isArray(object.missionProgress))
                    throw TypeError(".PB_SCLostTempleMissionInfo.missionProgress: array expected");
                message.missionProgress = [];
                for (var i = 0; i < object.missionProgress.length; ++i)
                    message.missionProgress[i] = object.missionProgress[i] | 0;
            }
            if (object.missionFetch) {
                if (!Array.isArray(object.missionFetch))
                    throw TypeError(".PB_SCLostTempleMissionInfo.missionFetch: array expected");
                message.missionFetch = [];
                for (var i = 0; i < object.missionFetch.length; ++i)
                    message.missionFetch[i] = Boolean(object.missionFetch[i]);
            }
            if (object.missionRewardFetchFlag) {
                if (!Array.isArray(object.missionRewardFetchFlag))
                    throw TypeError(".PB_SCLostTempleMissionInfo.missionRewardFetchFlag: array expected");
                message.missionRewardFetchFlag = [];
                for (var i = 0; i < object.missionRewardFetchFlag.length; ++i)
                    message.missionRewardFetchFlag[i] = Boolean(object.missionRewardFetchFlag[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCLostTempleMissionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCLostTempleMissionInfo
         * @static
         * @param {PB_SCLostTempleMissionInfo} message PB_SCLostTempleMissionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCLostTempleMissionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.missionProgress = [];
                object.missionFetch = [];
                object.missionRewardFetchFlag = [];
            }
            if (message.missionProgress && message.missionProgress.length) {
                object.missionProgress = [];
                for (var j = 0; j < message.missionProgress.length; ++j)
                    object.missionProgress[j] = message.missionProgress[j];
            }
            if (message.missionFetch && message.missionFetch.length) {
                object.missionFetch = [];
                for (var j = 0; j < message.missionFetch.length; ++j)
                    object.missionFetch[j] = message.missionFetch[j];
            }
            if (message.missionRewardFetchFlag && message.missionRewardFetchFlag.length) {
                object.missionRewardFetchFlag = [];
                for (var j = 0; j < message.missionRewardFetchFlag.length; ++j)
                    object.missionRewardFetchFlag[j] = message.missionRewardFetchFlag[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCLostTempleMissionInfo to JSON.
         * @function toJSON
         * @memberof PB_SCLostTempleMissionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCLostTempleMissionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCLostTempleMissionInfo;
    })();
    
    $root.PB_SCLostTempleItemList = (function() {
    
        /**
         * Properties of a PB_SCLostTempleItemList.
         * @exports IPB_SCLostTempleItemList
         * @interface IPB_SCLostTempleItemList
         * @property {boolean|null} [isActive] PB_SCLostTempleItemList isActive
         * @property {Array.<boolean>|null} [isFetch] PB_SCLostTempleItemList isFetch
         */
    
        /**
         * Constructs a new PB_SCLostTempleItemList.
         * @exports PB_SCLostTempleItemList
         * @classdesc Represents a PB_SCLostTempleItemList.
         * @implements IPB_SCLostTempleItemList
         * @constructor
         * @param {IPB_SCLostTempleItemList=} [properties] Properties to set
         */
        function PB_SCLostTempleItemList(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCLostTempleItemList isActive.
         * @member {boolean} isActive
         * @memberof PB_SCLostTempleItemList
         * @instance
         */
        PB_SCLostTempleItemList.prototype.isActive = false;
    
        /**
         * PB_SCLostTempleItemList isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCLostTempleItemList
         * @instance
         */
        PB_SCLostTempleItemList.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCLostTempleItemList instance using the specified properties.
         * @function create
         * @memberof PB_SCLostTempleItemList
         * @static
         * @param {IPB_SCLostTempleItemList=} [properties] Properties to set
         * @returns {PB_SCLostTempleItemList} PB_SCLostTempleItemList instance
         */
        PB_SCLostTempleItemList.create = function create(properties) {
            return new PB_SCLostTempleItemList(properties);
        };
    
        /**
         * Encodes the specified PB_SCLostTempleItemList message. Does not implicitly {@link PB_SCLostTempleItemList.verify|verify} messages.
         * @function encode
         * @memberof PB_SCLostTempleItemList
         * @static
         * @param {IPB_SCLostTempleItemList} message PB_SCLostTempleItemList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleItemList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isActive);
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCLostTempleItemList message, length delimited. Does not implicitly {@link PB_SCLostTempleItemList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCLostTempleItemList
         * @static
         * @param {IPB_SCLostTempleItemList} message PB_SCLostTempleItemList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleItemList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCLostTempleItemList message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCLostTempleItemList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCLostTempleItemList} PB_SCLostTempleItemList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleItemList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCLostTempleItemList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.bool();
                    break;
                case 2:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCLostTempleItemList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCLostTempleItemList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCLostTempleItemList} PB_SCLostTempleItemList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleItemList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCLostTempleItemList message.
         * @function verify
         * @memberof PB_SCLostTempleItemList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCLostTempleItemList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (typeof message.isActive !== "boolean")
                    return "isActive: boolean expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCLostTempleItemList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCLostTempleItemList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCLostTempleItemList} PB_SCLostTempleItemList
         */
        PB_SCLostTempleItemList.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCLostTempleItemList)
                return object;
            var message = new $root.PB_SCLostTempleItemList();
            if (object.isActive != null)
                message.isActive = Boolean(object.isActive);
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCLostTempleItemList.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCLostTempleItemList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCLostTempleItemList
         * @static
         * @param {PB_SCLostTempleItemList} message PB_SCLostTempleItemList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCLostTempleItemList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (options.defaults)
                object.isActive = false;
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCLostTempleItemList to JSON.
         * @function toJSON
         * @memberof PB_SCLostTempleItemList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCLostTempleItemList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCLostTempleItemList;
    })();
    
    $root.PB_SCLostTempleItemInfo = (function() {
    
        /**
         * Properties of a PB_SCLostTempleItemInfo.
         * @exports IPB_SCLostTempleItemInfo
         * @interface IPB_SCLostTempleItemInfo
         * @property {Array.<IPB_SCLostTempleItemList>|null} [list] PB_SCLostTempleItemInfo list
         * @property {number|null} [itemNum] PB_SCLostTempleItemInfo itemNum
         */
    
        /**
         * Constructs a new PB_SCLostTempleItemInfo.
         * @exports PB_SCLostTempleItemInfo
         * @classdesc Represents a PB_SCLostTempleItemInfo.
         * @implements IPB_SCLostTempleItemInfo
         * @constructor
         * @param {IPB_SCLostTempleItemInfo=} [properties] Properties to set
         */
        function PB_SCLostTempleItemInfo(properties) {
            this.list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCLostTempleItemInfo list.
         * @member {Array.<IPB_SCLostTempleItemList>} list
         * @memberof PB_SCLostTempleItemInfo
         * @instance
         */
        PB_SCLostTempleItemInfo.prototype.list = $util.emptyArray;
    
        /**
         * PB_SCLostTempleItemInfo itemNum.
         * @member {number} itemNum
         * @memberof PB_SCLostTempleItemInfo
         * @instance
         */
        PB_SCLostTempleItemInfo.prototype.itemNum = 0;
    
        /**
         * Creates a new PB_SCLostTempleItemInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCLostTempleItemInfo
         * @static
         * @param {IPB_SCLostTempleItemInfo=} [properties] Properties to set
         * @returns {PB_SCLostTempleItemInfo} PB_SCLostTempleItemInfo instance
         */
        PB_SCLostTempleItemInfo.create = function create(properties) {
            return new PB_SCLostTempleItemInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCLostTempleItemInfo message. Does not implicitly {@link PB_SCLostTempleItemInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCLostTempleItemInfo
         * @static
         * @param {IPB_SCLostTempleItemInfo} message PB_SCLostTempleItemInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleItemInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.list.length)
                for (var i = 0; i < message.list.length; ++i)
                    $root.PB_SCLostTempleItemList.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.itemNum != null && Object.hasOwnProperty.call(message, "itemNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemNum);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCLostTempleItemInfo message, length delimited. Does not implicitly {@link PB_SCLostTempleItemInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCLostTempleItemInfo
         * @static
         * @param {IPB_SCLostTempleItemInfo} message PB_SCLostTempleItemInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCLostTempleItemInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCLostTempleItemInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCLostTempleItemInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCLostTempleItemInfo} PB_SCLostTempleItemInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleItemInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCLostTempleItemInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.PB_SCLostTempleItemList.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.itemNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCLostTempleItemInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCLostTempleItemInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCLostTempleItemInfo} PB_SCLostTempleItemInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCLostTempleItemInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCLostTempleItemInfo message.
         * @function verify
         * @memberof PB_SCLostTempleItemInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCLostTempleItemInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list))
                    return "list: array expected";
                for (var i = 0; i < message.list.length; ++i) {
                    var error = $root.PB_SCLostTempleItemList.verify(message.list[i]);
                    if (error)
                        return "list." + error;
                }
            }
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                if (!$util.isInteger(message.itemNum))
                    return "itemNum: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCLostTempleItemInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCLostTempleItemInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCLostTempleItemInfo} PB_SCLostTempleItemInfo
         */
        PB_SCLostTempleItemInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCLostTempleItemInfo)
                return object;
            var message = new $root.PB_SCLostTempleItemInfo();
            if (object.list) {
                if (!Array.isArray(object.list))
                    throw TypeError(".PB_SCLostTempleItemInfo.list: array expected");
                message.list = [];
                for (var i = 0; i < object.list.length; ++i) {
                    if (typeof object.list[i] !== "object")
                        throw TypeError(".PB_SCLostTempleItemInfo.list: object expected");
                    message.list[i] = $root.PB_SCLostTempleItemList.fromObject(object.list[i]);
                }
            }
            if (object.itemNum != null)
                message.itemNum = object.itemNum | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCLostTempleItemInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCLostTempleItemInfo
         * @static
         * @param {PB_SCLostTempleItemInfo} message PB_SCLostTempleItemInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCLostTempleItemInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.list = [];
            if (options.defaults)
                object.itemNum = 0;
            if (message.list && message.list.length) {
                object.list = [];
                for (var j = 0; j < message.list.length; ++j)
                    object.list[j] = $root.PB_SCLostTempleItemList.toObject(message.list[j], options);
            }
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                object.itemNum = message.itemNum;
            return object;
        };
    
        /**
         * Converts this PB_SCLostTempleItemInfo to JSON.
         * @function toJSON
         * @memberof PB_SCLostTempleItemInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCLostTempleItemInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCLostTempleItemInfo;
    })();
    
    $root.PB_SCHouZhaiInfo = (function() {
    
        /**
         * Properties of a PB_SCHouZhaiInfo.
         * @exports IPB_SCHouZhaiInfo
         * @interface IPB_SCHouZhaiInfo
         * @property {number|null} [passBlock] PB_SCHouZhaiInfo passBlock
         * @property {number|null} [passRound] PB_SCHouZhaiInfo passRound
         */
    
        /**
         * Constructs a new PB_SCHouZhaiInfo.
         * @exports PB_SCHouZhaiInfo
         * @classdesc Represents a PB_SCHouZhaiInfo.
         * @implements IPB_SCHouZhaiInfo
         * @constructor
         * @param {IPB_SCHouZhaiInfo=} [properties] Properties to set
         */
        function PB_SCHouZhaiInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCHouZhaiInfo passBlock.
         * @member {number} passBlock
         * @memberof PB_SCHouZhaiInfo
         * @instance
         */
        PB_SCHouZhaiInfo.prototype.passBlock = 0;
    
        /**
         * PB_SCHouZhaiInfo passRound.
         * @member {number} passRound
         * @memberof PB_SCHouZhaiInfo
         * @instance
         */
        PB_SCHouZhaiInfo.prototype.passRound = 0;
    
        /**
         * Creates a new PB_SCHouZhaiInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCHouZhaiInfo
         * @static
         * @param {IPB_SCHouZhaiInfo=} [properties] Properties to set
         * @returns {PB_SCHouZhaiInfo} PB_SCHouZhaiInfo instance
         */
        PB_SCHouZhaiInfo.create = function create(properties) {
            return new PB_SCHouZhaiInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCHouZhaiInfo message. Does not implicitly {@link PB_SCHouZhaiInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCHouZhaiInfo
         * @static
         * @param {IPB_SCHouZhaiInfo} message PB_SCHouZhaiInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHouZhaiInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.passBlock != null && Object.hasOwnProperty.call(message, "passBlock"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.passBlock);
            if (message.passRound != null && Object.hasOwnProperty.call(message, "passRound"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.passRound);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCHouZhaiInfo message, length delimited. Does not implicitly {@link PB_SCHouZhaiInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCHouZhaiInfo
         * @static
         * @param {IPB_SCHouZhaiInfo} message PB_SCHouZhaiInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHouZhaiInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCHouZhaiInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCHouZhaiInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCHouZhaiInfo} PB_SCHouZhaiInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHouZhaiInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCHouZhaiInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.passBlock = reader.int32();
                    break;
                case 2:
                    message.passRound = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCHouZhaiInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCHouZhaiInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCHouZhaiInfo} PB_SCHouZhaiInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHouZhaiInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCHouZhaiInfo message.
         * @function verify
         * @memberof PB_SCHouZhaiInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCHouZhaiInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.passBlock != null && message.hasOwnProperty("passBlock"))
                if (!$util.isInteger(message.passBlock))
                    return "passBlock: integer expected";
            if (message.passRound != null && message.hasOwnProperty("passRound"))
                if (!$util.isInteger(message.passRound))
                    return "passRound: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCHouZhaiInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCHouZhaiInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCHouZhaiInfo} PB_SCHouZhaiInfo
         */
        PB_SCHouZhaiInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCHouZhaiInfo)
                return object;
            var message = new $root.PB_SCHouZhaiInfo();
            if (object.passBlock != null)
                message.passBlock = object.passBlock | 0;
            if (object.passRound != null)
                message.passRound = object.passRound | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCHouZhaiInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCHouZhaiInfo
         * @static
         * @param {PB_SCHouZhaiInfo} message PB_SCHouZhaiInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCHouZhaiInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.passBlock = 0;
                object.passRound = 0;
            }
            if (message.passBlock != null && message.hasOwnProperty("passBlock"))
                object.passBlock = message.passBlock;
            if (message.passRound != null && message.hasOwnProperty("passRound"))
                object.passRound = message.passRound;
            return object;
        };
    
        /**
         * Converts this PB_SCHouZhaiInfo to JSON.
         * @function toJSON
         * @memberof PB_SCHouZhaiInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCHouZhaiInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCHouZhaiInfo;
    })();
    
    $root.PB_SCZombiGoGoGoPassList = (function() {
    
        /**
         * Properties of a PB_SCZombiGoGoGoPassList.
         * @exports IPB_SCZombiGoGoGoPassList
         * @interface IPB_SCZombiGoGoGoPassList
         * @property {boolean|null} [isActive] PB_SCZombiGoGoGoPassList isActive
         * @property {Array.<boolean>|null} [isFetch] PB_SCZombiGoGoGoPassList isFetch
         */
    
        /**
         * Constructs a new PB_SCZombiGoGoGoPassList.
         * @exports PB_SCZombiGoGoGoPassList
         * @classdesc Represents a PB_SCZombiGoGoGoPassList.
         * @implements IPB_SCZombiGoGoGoPassList
         * @constructor
         * @param {IPB_SCZombiGoGoGoPassList=} [properties] Properties to set
         */
        function PB_SCZombiGoGoGoPassList(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCZombiGoGoGoPassList isActive.
         * @member {boolean} isActive
         * @memberof PB_SCZombiGoGoGoPassList
         * @instance
         */
        PB_SCZombiGoGoGoPassList.prototype.isActive = false;
    
        /**
         * PB_SCZombiGoGoGoPassList isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCZombiGoGoGoPassList
         * @instance
         */
        PB_SCZombiGoGoGoPassList.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCZombiGoGoGoPassList instance using the specified properties.
         * @function create
         * @memberof PB_SCZombiGoGoGoPassList
         * @static
         * @param {IPB_SCZombiGoGoGoPassList=} [properties] Properties to set
         * @returns {PB_SCZombiGoGoGoPassList} PB_SCZombiGoGoGoPassList instance
         */
        PB_SCZombiGoGoGoPassList.create = function create(properties) {
            return new PB_SCZombiGoGoGoPassList(properties);
        };
    
        /**
         * Encodes the specified PB_SCZombiGoGoGoPassList message. Does not implicitly {@link PB_SCZombiGoGoGoPassList.verify|verify} messages.
         * @function encode
         * @memberof PB_SCZombiGoGoGoPassList
         * @static
         * @param {IPB_SCZombiGoGoGoPassList} message PB_SCZombiGoGoGoPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCZombiGoGoGoPassList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isActive);
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCZombiGoGoGoPassList message, length delimited. Does not implicitly {@link PB_SCZombiGoGoGoPassList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCZombiGoGoGoPassList
         * @static
         * @param {IPB_SCZombiGoGoGoPassList} message PB_SCZombiGoGoGoPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCZombiGoGoGoPassList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCZombiGoGoGoPassList message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCZombiGoGoGoPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCZombiGoGoGoPassList} PB_SCZombiGoGoGoPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCZombiGoGoGoPassList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCZombiGoGoGoPassList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.bool();
                    break;
                case 2:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCZombiGoGoGoPassList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCZombiGoGoGoPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCZombiGoGoGoPassList} PB_SCZombiGoGoGoPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCZombiGoGoGoPassList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCZombiGoGoGoPassList message.
         * @function verify
         * @memberof PB_SCZombiGoGoGoPassList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCZombiGoGoGoPassList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (typeof message.isActive !== "boolean")
                    return "isActive: boolean expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCZombiGoGoGoPassList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCZombiGoGoGoPassList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCZombiGoGoGoPassList} PB_SCZombiGoGoGoPassList
         */
        PB_SCZombiGoGoGoPassList.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCZombiGoGoGoPassList)
                return object;
            var message = new $root.PB_SCZombiGoGoGoPassList();
            if (object.isActive != null)
                message.isActive = Boolean(object.isActive);
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCZombiGoGoGoPassList.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCZombiGoGoGoPassList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCZombiGoGoGoPassList
         * @static
         * @param {PB_SCZombiGoGoGoPassList} message PB_SCZombiGoGoGoPassList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCZombiGoGoGoPassList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (options.defaults)
                object.isActive = false;
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCZombiGoGoGoPassList to JSON.
         * @function toJSON
         * @memberof PB_SCZombiGoGoGoPassList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCZombiGoGoGoPassList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCZombiGoGoGoPassList;
    })();
    
    $root.PB_SCZombiGoGoGoPassInfo = (function() {
    
        /**
         * Properties of a PB_SCZombiGoGoGoPassInfo.
         * @exports IPB_SCZombiGoGoGoPassInfo
         * @interface IPB_SCZombiGoGoGoPassInfo
         * @property {Array.<IPB_SCZombiGoGoGoPassList>|null} [list] PB_SCZombiGoGoGoPassInfo list
         * @property {number|null} [killNum] PB_SCZombiGoGoGoPassInfo killNum
         */
    
        /**
         * Constructs a new PB_SCZombiGoGoGoPassInfo.
         * @exports PB_SCZombiGoGoGoPassInfo
         * @classdesc Represents a PB_SCZombiGoGoGoPassInfo.
         * @implements IPB_SCZombiGoGoGoPassInfo
         * @constructor
         * @param {IPB_SCZombiGoGoGoPassInfo=} [properties] Properties to set
         */
        function PB_SCZombiGoGoGoPassInfo(properties) {
            this.list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCZombiGoGoGoPassInfo list.
         * @member {Array.<IPB_SCZombiGoGoGoPassList>} list
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @instance
         */
        PB_SCZombiGoGoGoPassInfo.prototype.list = $util.emptyArray;
    
        /**
         * PB_SCZombiGoGoGoPassInfo killNum.
         * @member {number} killNum
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @instance
         */
        PB_SCZombiGoGoGoPassInfo.prototype.killNum = 0;
    
        /**
         * Creates a new PB_SCZombiGoGoGoPassInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @static
         * @param {IPB_SCZombiGoGoGoPassInfo=} [properties] Properties to set
         * @returns {PB_SCZombiGoGoGoPassInfo} PB_SCZombiGoGoGoPassInfo instance
         */
        PB_SCZombiGoGoGoPassInfo.create = function create(properties) {
            return new PB_SCZombiGoGoGoPassInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCZombiGoGoGoPassInfo message. Does not implicitly {@link PB_SCZombiGoGoGoPassInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @static
         * @param {IPB_SCZombiGoGoGoPassInfo} message PB_SCZombiGoGoGoPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCZombiGoGoGoPassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.list.length)
                for (var i = 0; i < message.list.length; ++i)
                    $root.PB_SCZombiGoGoGoPassList.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.killNum != null && Object.hasOwnProperty.call(message, "killNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.killNum);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCZombiGoGoGoPassInfo message, length delimited. Does not implicitly {@link PB_SCZombiGoGoGoPassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @static
         * @param {IPB_SCZombiGoGoGoPassInfo} message PB_SCZombiGoGoGoPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCZombiGoGoGoPassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCZombiGoGoGoPassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCZombiGoGoGoPassInfo} PB_SCZombiGoGoGoPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCZombiGoGoGoPassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCZombiGoGoGoPassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.PB_SCZombiGoGoGoPassList.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.killNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCZombiGoGoGoPassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCZombiGoGoGoPassInfo} PB_SCZombiGoGoGoPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCZombiGoGoGoPassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCZombiGoGoGoPassInfo message.
         * @function verify
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCZombiGoGoGoPassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list))
                    return "list: array expected";
                for (var i = 0; i < message.list.length; ++i) {
                    var error = $root.PB_SCZombiGoGoGoPassList.verify(message.list[i]);
                    if (error)
                        return "list." + error;
                }
            }
            if (message.killNum != null && message.hasOwnProperty("killNum"))
                if (!$util.isInteger(message.killNum))
                    return "killNum: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCZombiGoGoGoPassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCZombiGoGoGoPassInfo} PB_SCZombiGoGoGoPassInfo
         */
        PB_SCZombiGoGoGoPassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCZombiGoGoGoPassInfo)
                return object;
            var message = new $root.PB_SCZombiGoGoGoPassInfo();
            if (object.list) {
                if (!Array.isArray(object.list))
                    throw TypeError(".PB_SCZombiGoGoGoPassInfo.list: array expected");
                message.list = [];
                for (var i = 0; i < object.list.length; ++i) {
                    if (typeof object.list[i] !== "object")
                        throw TypeError(".PB_SCZombiGoGoGoPassInfo.list: object expected");
                    message.list[i] = $root.PB_SCZombiGoGoGoPassList.fromObject(object.list[i]);
                }
            }
            if (object.killNum != null)
                message.killNum = object.killNum | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCZombiGoGoGoPassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @static
         * @param {PB_SCZombiGoGoGoPassInfo} message PB_SCZombiGoGoGoPassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCZombiGoGoGoPassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.list = [];
            if (options.defaults)
                object.killNum = 0;
            if (message.list && message.list.length) {
                object.list = [];
                for (var j = 0; j < message.list.length; ++j)
                    object.list[j] = $root.PB_SCZombiGoGoGoPassList.toObject(message.list[j], options);
            }
            if (message.killNum != null && message.hasOwnProperty("killNum"))
                object.killNum = message.killNum;
            return object;
        };
    
        /**
         * Converts this PB_SCZombiGoGoGoPassInfo to JSON.
         * @function toJSON
         * @memberof PB_SCZombiGoGoGoPassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCZombiGoGoGoPassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCZombiGoGoGoPassInfo;
    })();
    
    $root.PB_SCSevenDayGiftInfo = (function() {
    
        /**
         * Properties of a PB_SCSevenDayGiftInfo.
         * @exports IPB_SCSevenDayGiftInfo
         * @interface IPB_SCSevenDayGiftInfo
         * @property {Array.<boolean>|null} [isFetch] PB_SCSevenDayGiftInfo isFetch
         * @property {number|Long|null} [beginTime] PB_SCSevenDayGiftInfo beginTime
         */
    
        /**
         * Constructs a new PB_SCSevenDayGiftInfo.
         * @exports PB_SCSevenDayGiftInfo
         * @classdesc Represents a PB_SCSevenDayGiftInfo.
         * @implements IPB_SCSevenDayGiftInfo
         * @constructor
         * @param {IPB_SCSevenDayGiftInfo=} [properties] Properties to set
         */
        function PB_SCSevenDayGiftInfo(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCSevenDayGiftInfo isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCSevenDayGiftInfo
         * @instance
         */
        PB_SCSevenDayGiftInfo.prototype.isFetch = $util.emptyArray;
    
        /**
         * PB_SCSevenDayGiftInfo beginTime.
         * @member {number|Long} beginTime
         * @memberof PB_SCSevenDayGiftInfo
         * @instance
         */
        PB_SCSevenDayGiftInfo.prototype.beginTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCSevenDayGiftInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCSevenDayGiftInfo
         * @static
         * @param {IPB_SCSevenDayGiftInfo=} [properties] Properties to set
         * @returns {PB_SCSevenDayGiftInfo} PB_SCSevenDayGiftInfo instance
         */
        PB_SCSevenDayGiftInfo.create = function create(properties) {
            return new PB_SCSevenDayGiftInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCSevenDayGiftInfo message. Does not implicitly {@link PB_SCSevenDayGiftInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCSevenDayGiftInfo
         * @static
         * @param {IPB_SCSevenDayGiftInfo} message PB_SCSevenDayGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCSevenDayGiftInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isFetch[i]);
            if (message.beginTime != null && Object.hasOwnProperty.call(message, "beginTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.beginTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCSevenDayGiftInfo message, length delimited. Does not implicitly {@link PB_SCSevenDayGiftInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCSevenDayGiftInfo
         * @static
         * @param {IPB_SCSevenDayGiftInfo} message PB_SCSevenDayGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCSevenDayGiftInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCSevenDayGiftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCSevenDayGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCSevenDayGiftInfo} PB_SCSevenDayGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCSevenDayGiftInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCSevenDayGiftInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                case 2:
                    message.beginTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCSevenDayGiftInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCSevenDayGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCSevenDayGiftInfo} PB_SCSevenDayGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCSevenDayGiftInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCSevenDayGiftInfo message.
         * @function verify
         * @memberof PB_SCSevenDayGiftInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCSevenDayGiftInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (!$util.isInteger(message.beginTime) && !(message.beginTime && $util.isInteger(message.beginTime.low) && $util.isInteger(message.beginTime.high)))
                    return "beginTime: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCSevenDayGiftInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCSevenDayGiftInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCSevenDayGiftInfo} PB_SCSevenDayGiftInfo
         */
        PB_SCSevenDayGiftInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCSevenDayGiftInfo)
                return object;
            var message = new $root.PB_SCSevenDayGiftInfo();
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCSevenDayGiftInfo.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            if (object.beginTime != null)
                if ($util.Long)
                    (message.beginTime = $util.Long.fromValue(object.beginTime)).unsigned = false;
                else if (typeof object.beginTime === "string")
                    message.beginTime = parseInt(object.beginTime, 10);
                else if (typeof object.beginTime === "number")
                    message.beginTime = object.beginTime;
                else if (typeof object.beginTime === "object")
                    message.beginTime = new $util.LongBits(object.beginTime.low >>> 0, object.beginTime.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCSevenDayGiftInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCSevenDayGiftInfo
         * @static
         * @param {PB_SCSevenDayGiftInfo} message PB_SCSevenDayGiftInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCSevenDayGiftInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.beginTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.beginTime = options.longs === String ? "0" : 0;
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (typeof message.beginTime === "number")
                    object.beginTime = options.longs === String ? String(message.beginTime) : message.beginTime;
                else
                    object.beginTime = options.longs === String ? $util.Long.prototype.toString.call(message.beginTime) : options.longs === Number ? new $util.LongBits(message.beginTime.low >>> 0, message.beginTime.high >>> 0).toNumber() : message.beginTime;
            return object;
        };
    
        /**
         * Converts this PB_SCSevenDayGiftInfo to JSON.
         * @function toJSON
         * @memberof PB_SCSevenDayGiftInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCSevenDayGiftInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCSevenDayGiftInfo;
    })();
    
    $root.PB_SCRaGeneNewbeeGiftInfo = (function() {
    
        /**
         * Properties of a PB_SCRaGeneNewbeeGiftInfo.
         * @exports IPB_SCRaGeneNewbeeGiftInfo
         * @interface IPB_SCRaGeneNewbeeGiftInfo
         * @property {number|null} [seq] PB_SCRaGeneNewbeeGiftInfo seq
         */
    
        /**
         * Constructs a new PB_SCRaGeneNewbeeGiftInfo.
         * @exports PB_SCRaGeneNewbeeGiftInfo
         * @classdesc Represents a PB_SCRaGeneNewbeeGiftInfo.
         * @implements IPB_SCRaGeneNewbeeGiftInfo
         * @constructor
         * @param {IPB_SCRaGeneNewbeeGiftInfo=} [properties] Properties to set
         */
        function PB_SCRaGeneNewbeeGiftInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaGeneNewbeeGiftInfo seq.
         * @member {number} seq
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @instance
         */
        PB_SCRaGeneNewbeeGiftInfo.prototype.seq = 0;
    
        /**
         * Creates a new PB_SCRaGeneNewbeeGiftInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @static
         * @param {IPB_SCRaGeneNewbeeGiftInfo=} [properties] Properties to set
         * @returns {PB_SCRaGeneNewbeeGiftInfo} PB_SCRaGeneNewbeeGiftInfo instance
         */
        PB_SCRaGeneNewbeeGiftInfo.create = function create(properties) {
            return new PB_SCRaGeneNewbeeGiftInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaGeneNewbeeGiftInfo message. Does not implicitly {@link PB_SCRaGeneNewbeeGiftInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @static
         * @param {IPB_SCRaGeneNewbeeGiftInfo} message PB_SCRaGeneNewbeeGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaGeneNewbeeGiftInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaGeneNewbeeGiftInfo message, length delimited. Does not implicitly {@link PB_SCRaGeneNewbeeGiftInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @static
         * @param {IPB_SCRaGeneNewbeeGiftInfo} message PB_SCRaGeneNewbeeGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaGeneNewbeeGiftInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaGeneNewbeeGiftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaGeneNewbeeGiftInfo} PB_SCRaGeneNewbeeGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaGeneNewbeeGiftInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaGeneNewbeeGiftInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaGeneNewbeeGiftInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaGeneNewbeeGiftInfo} PB_SCRaGeneNewbeeGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaGeneNewbeeGiftInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaGeneNewbeeGiftInfo message.
         * @function verify
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaGeneNewbeeGiftInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaGeneNewbeeGiftInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaGeneNewbeeGiftInfo} PB_SCRaGeneNewbeeGiftInfo
         */
        PB_SCRaGeneNewbeeGiftInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaGeneNewbeeGiftInfo)
                return object;
            var message = new $root.PB_SCRaGeneNewbeeGiftInfo();
            if (object.seq != null)
                message.seq = object.seq | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaGeneNewbeeGiftInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @static
         * @param {PB_SCRaGeneNewbeeGiftInfo} message PB_SCRaGeneNewbeeGiftInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaGeneNewbeeGiftInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.seq = 0;
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            return object;
        };
    
        /**
         * Converts this PB_SCRaGeneNewbeeGiftInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaGeneNewbeeGiftInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaGeneNewbeeGiftInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaGeneNewbeeGiftInfo;
    })();
    
    $root.PB_SCRaTimeLimitRechargeInfo = (function() {
    
        /**
         * Properties of a PB_SCRaTimeLimitRechargeInfo.
         * @exports IPB_SCRaTimeLimitRechargeInfo
         * @interface IPB_SCRaTimeLimitRechargeInfo
         * @property {number|null} [rechargeNum] PB_SCRaTimeLimitRechargeInfo rechargeNum
         * @property {Array.<boolean>|null} [isFetch] PB_SCRaTimeLimitRechargeInfo isFetch
         */
    
        /**
         * Constructs a new PB_SCRaTimeLimitRechargeInfo.
         * @exports PB_SCRaTimeLimitRechargeInfo
         * @classdesc Represents a PB_SCRaTimeLimitRechargeInfo.
         * @implements IPB_SCRaTimeLimitRechargeInfo
         * @constructor
         * @param {IPB_SCRaTimeLimitRechargeInfo=} [properties] Properties to set
         */
        function PB_SCRaTimeLimitRechargeInfo(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaTimeLimitRechargeInfo rechargeNum.
         * @member {number} rechargeNum
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @instance
         */
        PB_SCRaTimeLimitRechargeInfo.prototype.rechargeNum = 0;
    
        /**
         * PB_SCRaTimeLimitRechargeInfo isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @instance
         */
        PB_SCRaTimeLimitRechargeInfo.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaTimeLimitRechargeInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @static
         * @param {IPB_SCRaTimeLimitRechargeInfo=} [properties] Properties to set
         * @returns {PB_SCRaTimeLimitRechargeInfo} PB_SCRaTimeLimitRechargeInfo instance
         */
        PB_SCRaTimeLimitRechargeInfo.create = function create(properties) {
            return new PB_SCRaTimeLimitRechargeInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaTimeLimitRechargeInfo message. Does not implicitly {@link PB_SCRaTimeLimitRechargeInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @static
         * @param {IPB_SCRaTimeLimitRechargeInfo} message PB_SCRaTimeLimitRechargeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaTimeLimitRechargeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rechargeNum != null && Object.hasOwnProperty.call(message, "rechargeNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rechargeNum);
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaTimeLimitRechargeInfo message, length delimited. Does not implicitly {@link PB_SCRaTimeLimitRechargeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @static
         * @param {IPB_SCRaTimeLimitRechargeInfo} message PB_SCRaTimeLimitRechargeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaTimeLimitRechargeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaTimeLimitRechargeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaTimeLimitRechargeInfo} PB_SCRaTimeLimitRechargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaTimeLimitRechargeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaTimeLimitRechargeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rechargeNum = reader.int32();
                    break;
                case 2:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaTimeLimitRechargeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaTimeLimitRechargeInfo} PB_SCRaTimeLimitRechargeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaTimeLimitRechargeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaTimeLimitRechargeInfo message.
         * @function verify
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaTimeLimitRechargeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rechargeNum != null && message.hasOwnProperty("rechargeNum"))
                if (!$util.isInteger(message.rechargeNum))
                    return "rechargeNum: integer expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaTimeLimitRechargeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaTimeLimitRechargeInfo} PB_SCRaTimeLimitRechargeInfo
         */
        PB_SCRaTimeLimitRechargeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaTimeLimitRechargeInfo)
                return object;
            var message = new $root.PB_SCRaTimeLimitRechargeInfo();
            if (object.rechargeNum != null)
                message.rechargeNum = object.rechargeNum | 0;
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCRaTimeLimitRechargeInfo.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaTimeLimitRechargeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @static
         * @param {PB_SCRaTimeLimitRechargeInfo} message PB_SCRaTimeLimitRechargeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaTimeLimitRechargeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (options.defaults)
                object.rechargeNum = 0;
            if (message.rechargeNum != null && message.hasOwnProperty("rechargeNum"))
                object.rechargeNum = message.rechargeNum;
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaTimeLimitRechargeInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaTimeLimitRechargeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaTimeLimitRechargeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaTimeLimitRechargeInfo;
    })();
    
    $root.PB_SCRaCavePassList = (function() {
    
        /**
         * Properties of a PB_SCRaCavePassList.
         * @exports IPB_SCRaCavePassList
         * @interface IPB_SCRaCavePassList
         * @property {boolean|null} [isActive] PB_SCRaCavePassList isActive
         * @property {Array.<boolean>|null} [isFetch] PB_SCRaCavePassList isFetch
         */
    
        /**
         * Constructs a new PB_SCRaCavePassList.
         * @exports PB_SCRaCavePassList
         * @classdesc Represents a PB_SCRaCavePassList.
         * @implements IPB_SCRaCavePassList
         * @constructor
         * @param {IPB_SCRaCavePassList=} [properties] Properties to set
         */
        function PB_SCRaCavePassList(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaCavePassList isActive.
         * @member {boolean} isActive
         * @memberof PB_SCRaCavePassList
         * @instance
         */
        PB_SCRaCavePassList.prototype.isActive = false;
    
        /**
         * PB_SCRaCavePassList isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCRaCavePassList
         * @instance
         */
        PB_SCRaCavePassList.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaCavePassList instance using the specified properties.
         * @function create
         * @memberof PB_SCRaCavePassList
         * @static
         * @param {IPB_SCRaCavePassList=} [properties] Properties to set
         * @returns {PB_SCRaCavePassList} PB_SCRaCavePassList instance
         */
        PB_SCRaCavePassList.create = function create(properties) {
            return new PB_SCRaCavePassList(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaCavePassList message. Does not implicitly {@link PB_SCRaCavePassList.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaCavePassList
         * @static
         * @param {IPB_SCRaCavePassList} message PB_SCRaCavePassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaCavePassList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isActive);
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaCavePassList message, length delimited. Does not implicitly {@link PB_SCRaCavePassList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaCavePassList
         * @static
         * @param {IPB_SCRaCavePassList} message PB_SCRaCavePassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaCavePassList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaCavePassList message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaCavePassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaCavePassList} PB_SCRaCavePassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaCavePassList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaCavePassList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.bool();
                    break;
                case 2:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaCavePassList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaCavePassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaCavePassList} PB_SCRaCavePassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaCavePassList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaCavePassList message.
         * @function verify
         * @memberof PB_SCRaCavePassList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaCavePassList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (typeof message.isActive !== "boolean")
                    return "isActive: boolean expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaCavePassList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaCavePassList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaCavePassList} PB_SCRaCavePassList
         */
        PB_SCRaCavePassList.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaCavePassList)
                return object;
            var message = new $root.PB_SCRaCavePassList();
            if (object.isActive != null)
                message.isActive = Boolean(object.isActive);
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCRaCavePassList.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaCavePassList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaCavePassList
         * @static
         * @param {PB_SCRaCavePassList} message PB_SCRaCavePassList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaCavePassList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (options.defaults)
                object.isActive = false;
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaCavePassList to JSON.
         * @function toJSON
         * @memberof PB_SCRaCavePassList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaCavePassList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaCavePassList;
    })();
    
    $root.PB_SCRaCavePassInfo = (function() {
    
        /**
         * Properties of a PB_SCRaCavePassInfo.
         * @exports IPB_SCRaCavePassInfo
         * @interface IPB_SCRaCavePassInfo
         * @property {Array.<IPB_SCRaRoundPassList>|null} [list] PB_SCRaCavePassInfo list
         * @property {number|null} [meters] PB_SCRaCavePassInfo meters
         * @property {number|null} [fetchExRewardCount] PB_SCRaCavePassInfo fetchExRewardCount
         */
    
        /**
         * Constructs a new PB_SCRaCavePassInfo.
         * @exports PB_SCRaCavePassInfo
         * @classdesc Represents a PB_SCRaCavePassInfo.
         * @implements IPB_SCRaCavePassInfo
         * @constructor
         * @param {IPB_SCRaCavePassInfo=} [properties] Properties to set
         */
        function PB_SCRaCavePassInfo(properties) {
            this.list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaCavePassInfo list.
         * @member {Array.<IPB_SCRaRoundPassList>} list
         * @memberof PB_SCRaCavePassInfo
         * @instance
         */
        PB_SCRaCavePassInfo.prototype.list = $util.emptyArray;
    
        /**
         * PB_SCRaCavePassInfo meters.
         * @member {number} meters
         * @memberof PB_SCRaCavePassInfo
         * @instance
         */
        PB_SCRaCavePassInfo.prototype.meters = 0;
    
        /**
         * PB_SCRaCavePassInfo fetchExRewardCount.
         * @member {number} fetchExRewardCount
         * @memberof PB_SCRaCavePassInfo
         * @instance
         */
        PB_SCRaCavePassInfo.prototype.fetchExRewardCount = 0;
    
        /**
         * Creates a new PB_SCRaCavePassInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaCavePassInfo
         * @static
         * @param {IPB_SCRaCavePassInfo=} [properties] Properties to set
         * @returns {PB_SCRaCavePassInfo} PB_SCRaCavePassInfo instance
         */
        PB_SCRaCavePassInfo.create = function create(properties) {
            return new PB_SCRaCavePassInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaCavePassInfo message. Does not implicitly {@link PB_SCRaCavePassInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaCavePassInfo
         * @static
         * @param {IPB_SCRaCavePassInfo} message PB_SCRaCavePassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaCavePassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.list.length)
                for (var i = 0; i < message.list.length; ++i)
                    $root.PB_SCRaRoundPassList.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.meters != null && Object.hasOwnProperty.call(message, "meters"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.meters);
            if (message.fetchExRewardCount != null && Object.hasOwnProperty.call(message, "fetchExRewardCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fetchExRewardCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaCavePassInfo message, length delimited. Does not implicitly {@link PB_SCRaCavePassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaCavePassInfo
         * @static
         * @param {IPB_SCRaCavePassInfo} message PB_SCRaCavePassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaCavePassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaCavePassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaCavePassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaCavePassInfo} PB_SCRaCavePassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaCavePassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaCavePassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.PB_SCRaRoundPassList.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.meters = reader.int32();
                    break;
                case 3:
                    message.fetchExRewardCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaCavePassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaCavePassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaCavePassInfo} PB_SCRaCavePassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaCavePassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaCavePassInfo message.
         * @function verify
         * @memberof PB_SCRaCavePassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaCavePassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list))
                    return "list: array expected";
                for (var i = 0; i < message.list.length; ++i) {
                    var error = $root.PB_SCRaRoundPassList.verify(message.list[i]);
                    if (error)
                        return "list." + error;
                }
            }
            if (message.meters != null && message.hasOwnProperty("meters"))
                if (!$util.isInteger(message.meters))
                    return "meters: integer expected";
            if (message.fetchExRewardCount != null && message.hasOwnProperty("fetchExRewardCount"))
                if (!$util.isInteger(message.fetchExRewardCount))
                    return "fetchExRewardCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaCavePassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaCavePassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaCavePassInfo} PB_SCRaCavePassInfo
         */
        PB_SCRaCavePassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaCavePassInfo)
                return object;
            var message = new $root.PB_SCRaCavePassInfo();
            if (object.list) {
                if (!Array.isArray(object.list))
                    throw TypeError(".PB_SCRaCavePassInfo.list: array expected");
                message.list = [];
                for (var i = 0; i < object.list.length; ++i) {
                    if (typeof object.list[i] !== "object")
                        throw TypeError(".PB_SCRaCavePassInfo.list: object expected");
                    message.list[i] = $root.PB_SCRaRoundPassList.fromObject(object.list[i]);
                }
            }
            if (object.meters != null)
                message.meters = object.meters | 0;
            if (object.fetchExRewardCount != null)
                message.fetchExRewardCount = object.fetchExRewardCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaCavePassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaCavePassInfo
         * @static
         * @param {PB_SCRaCavePassInfo} message PB_SCRaCavePassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaCavePassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.list = [];
            if (options.defaults) {
                object.meters = 0;
                object.fetchExRewardCount = 0;
            }
            if (message.list && message.list.length) {
                object.list = [];
                for (var j = 0; j < message.list.length; ++j)
                    object.list[j] = $root.PB_SCRaRoundPassList.toObject(message.list[j], options);
            }
            if (message.meters != null && message.hasOwnProperty("meters"))
                object.meters = message.meters;
            if (message.fetchExRewardCount != null && message.hasOwnProperty("fetchExRewardCount"))
                object.fetchExRewardCount = message.fetchExRewardCount;
            return object;
        };
    
        /**
         * Converts this PB_SCRaCavePassInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaCavePassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaCavePassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaCavePassInfo;
    })();
    
    $root.PB_SCRaGeneGiftInfo = (function() {
    
        /**
         * Properties of a PB_SCRaGeneGiftInfo.
         * @exports IPB_SCRaGeneGiftInfo
         * @interface IPB_SCRaGeneGiftInfo
         * @property {Array.<number>|null} [giftHeroId] PB_SCRaGeneGiftInfo giftHeroId
         * @property {Array.<number|Long>|null} [giftEndTime] PB_SCRaGeneGiftInfo giftEndTime
         */
    
        /**
         * Constructs a new PB_SCRaGeneGiftInfo.
         * @exports PB_SCRaGeneGiftInfo
         * @classdesc Represents a PB_SCRaGeneGiftInfo.
         * @implements IPB_SCRaGeneGiftInfo
         * @constructor
         * @param {IPB_SCRaGeneGiftInfo=} [properties] Properties to set
         */
        function PB_SCRaGeneGiftInfo(properties) {
            this.giftHeroId = [];
            this.giftEndTime = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaGeneGiftInfo giftHeroId.
         * @member {Array.<number>} giftHeroId
         * @memberof PB_SCRaGeneGiftInfo
         * @instance
         */
        PB_SCRaGeneGiftInfo.prototype.giftHeroId = $util.emptyArray;
    
        /**
         * PB_SCRaGeneGiftInfo giftEndTime.
         * @member {Array.<number|Long>} giftEndTime
         * @memberof PB_SCRaGeneGiftInfo
         * @instance
         */
        PB_SCRaGeneGiftInfo.prototype.giftEndTime = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaGeneGiftInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaGeneGiftInfo
         * @static
         * @param {IPB_SCRaGeneGiftInfo=} [properties] Properties to set
         * @returns {PB_SCRaGeneGiftInfo} PB_SCRaGeneGiftInfo instance
         */
        PB_SCRaGeneGiftInfo.create = function create(properties) {
            return new PB_SCRaGeneGiftInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaGeneGiftInfo message. Does not implicitly {@link PB_SCRaGeneGiftInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaGeneGiftInfo
         * @static
         * @param {IPB_SCRaGeneGiftInfo} message PB_SCRaGeneGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaGeneGiftInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.giftHeroId != null && message.giftHeroId.length)
                for (var i = 0; i < message.giftHeroId.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.giftHeroId[i]);
            if (message.giftEndTime != null && message.giftEndTime.length)
                for (var i = 0; i < message.giftEndTime.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.giftEndTime[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaGeneGiftInfo message, length delimited. Does not implicitly {@link PB_SCRaGeneGiftInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaGeneGiftInfo
         * @static
         * @param {IPB_SCRaGeneGiftInfo} message PB_SCRaGeneGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaGeneGiftInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaGeneGiftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaGeneGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaGeneGiftInfo} PB_SCRaGeneGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaGeneGiftInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaGeneGiftInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.giftHeroId && message.giftHeroId.length))
                        message.giftHeroId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.giftHeroId.push(reader.int32());
                    } else
                        message.giftHeroId.push(reader.int32());
                    break;
                case 2:
                    if (!(message.giftEndTime && message.giftEndTime.length))
                        message.giftEndTime = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.giftEndTime.push(reader.int64());
                    } else
                        message.giftEndTime.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaGeneGiftInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaGeneGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaGeneGiftInfo} PB_SCRaGeneGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaGeneGiftInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaGeneGiftInfo message.
         * @function verify
         * @memberof PB_SCRaGeneGiftInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaGeneGiftInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.giftHeroId != null && message.hasOwnProperty("giftHeroId")) {
                if (!Array.isArray(message.giftHeroId))
                    return "giftHeroId: array expected";
                for (var i = 0; i < message.giftHeroId.length; ++i)
                    if (!$util.isInteger(message.giftHeroId[i]))
                        return "giftHeroId: integer[] expected";
            }
            if (message.giftEndTime != null && message.hasOwnProperty("giftEndTime")) {
                if (!Array.isArray(message.giftEndTime))
                    return "giftEndTime: array expected";
                for (var i = 0; i < message.giftEndTime.length; ++i)
                    if (!$util.isInteger(message.giftEndTime[i]) && !(message.giftEndTime[i] && $util.isInteger(message.giftEndTime[i].low) && $util.isInteger(message.giftEndTime[i].high)))
                        return "giftEndTime: integer|Long[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaGeneGiftInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaGeneGiftInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaGeneGiftInfo} PB_SCRaGeneGiftInfo
         */
        PB_SCRaGeneGiftInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaGeneGiftInfo)
                return object;
            var message = new $root.PB_SCRaGeneGiftInfo();
            if (object.giftHeroId) {
                if (!Array.isArray(object.giftHeroId))
                    throw TypeError(".PB_SCRaGeneGiftInfo.giftHeroId: array expected");
                message.giftHeroId = [];
                for (var i = 0; i < object.giftHeroId.length; ++i)
                    message.giftHeroId[i] = object.giftHeroId[i] | 0;
            }
            if (object.giftEndTime) {
                if (!Array.isArray(object.giftEndTime))
                    throw TypeError(".PB_SCRaGeneGiftInfo.giftEndTime: array expected");
                message.giftEndTime = [];
                for (var i = 0; i < object.giftEndTime.length; ++i)
                    if ($util.Long)
                        (message.giftEndTime[i] = $util.Long.fromValue(object.giftEndTime[i])).unsigned = false;
                    else if (typeof object.giftEndTime[i] === "string")
                        message.giftEndTime[i] = parseInt(object.giftEndTime[i], 10);
                    else if (typeof object.giftEndTime[i] === "number")
                        message.giftEndTime[i] = object.giftEndTime[i];
                    else if (typeof object.giftEndTime[i] === "object")
                        message.giftEndTime[i] = new $util.LongBits(object.giftEndTime[i].low >>> 0, object.giftEndTime[i].high >>> 0).toNumber();
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaGeneGiftInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaGeneGiftInfo
         * @static
         * @param {PB_SCRaGeneGiftInfo} message PB_SCRaGeneGiftInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaGeneGiftInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.giftHeroId = [];
                object.giftEndTime = [];
            }
            if (message.giftHeroId && message.giftHeroId.length) {
                object.giftHeroId = [];
                for (var j = 0; j < message.giftHeroId.length; ++j)
                    object.giftHeroId[j] = message.giftHeroId[j];
            }
            if (message.giftEndTime && message.giftEndTime.length) {
                object.giftEndTime = [];
                for (var j = 0; j < message.giftEndTime.length; ++j)
                    if (typeof message.giftEndTime[j] === "number")
                        object.giftEndTime[j] = options.longs === String ? String(message.giftEndTime[j]) : message.giftEndTime[j];
                    else
                        object.giftEndTime[j] = options.longs === String ? $util.Long.prototype.toString.call(message.giftEndTime[j]) : options.longs === Number ? new $util.LongBits(message.giftEndTime[j].low >>> 0, message.giftEndTime[j].high >>> 0).toNumber() : message.giftEndTime[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaGeneGiftInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaGeneGiftInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaGeneGiftInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaGeneGiftInfo;
    })();
    
    $root.PB_SCRaPartsGiftInfo = (function() {
    
        /**
         * Properties of a PB_SCRaPartsGiftInfo.
         * @exports IPB_SCRaPartsGiftInfo
         * @interface IPB_SCRaPartsGiftInfo
         * @property {number|null} [giftSeq] PB_SCRaPartsGiftInfo giftSeq
         * @property {number|Long|null} [beginTime] PB_SCRaPartsGiftInfo beginTime
         * @property {number|Long|null} [endTime] PB_SCRaPartsGiftInfo endTime
         */
    
        /**
         * Constructs a new PB_SCRaPartsGiftInfo.
         * @exports PB_SCRaPartsGiftInfo
         * @classdesc Represents a PB_SCRaPartsGiftInfo.
         * @implements IPB_SCRaPartsGiftInfo
         * @constructor
         * @param {IPB_SCRaPartsGiftInfo=} [properties] Properties to set
         */
        function PB_SCRaPartsGiftInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaPartsGiftInfo giftSeq.
         * @member {number} giftSeq
         * @memberof PB_SCRaPartsGiftInfo
         * @instance
         */
        PB_SCRaPartsGiftInfo.prototype.giftSeq = 0;
    
        /**
         * PB_SCRaPartsGiftInfo beginTime.
         * @member {number|Long} beginTime
         * @memberof PB_SCRaPartsGiftInfo
         * @instance
         */
        PB_SCRaPartsGiftInfo.prototype.beginTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * PB_SCRaPartsGiftInfo endTime.
         * @member {number|Long} endTime
         * @memberof PB_SCRaPartsGiftInfo
         * @instance
         */
        PB_SCRaPartsGiftInfo.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCRaPartsGiftInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaPartsGiftInfo
         * @static
         * @param {IPB_SCRaPartsGiftInfo=} [properties] Properties to set
         * @returns {PB_SCRaPartsGiftInfo} PB_SCRaPartsGiftInfo instance
         */
        PB_SCRaPartsGiftInfo.create = function create(properties) {
            return new PB_SCRaPartsGiftInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaPartsGiftInfo message. Does not implicitly {@link PB_SCRaPartsGiftInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaPartsGiftInfo
         * @static
         * @param {IPB_SCRaPartsGiftInfo} message PB_SCRaPartsGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaPartsGiftInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.giftSeq != null && Object.hasOwnProperty.call(message, "giftSeq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.giftSeq);
            if (message.beginTime != null && Object.hasOwnProperty.call(message, "beginTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.beginTime);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.endTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaPartsGiftInfo message, length delimited. Does not implicitly {@link PB_SCRaPartsGiftInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaPartsGiftInfo
         * @static
         * @param {IPB_SCRaPartsGiftInfo} message PB_SCRaPartsGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaPartsGiftInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaPartsGiftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaPartsGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaPartsGiftInfo} PB_SCRaPartsGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaPartsGiftInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaPartsGiftInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.giftSeq = reader.int32();
                    break;
                case 2:
                    message.beginTime = reader.int64();
                    break;
                case 3:
                    message.endTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaPartsGiftInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaPartsGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaPartsGiftInfo} PB_SCRaPartsGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaPartsGiftInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaPartsGiftInfo message.
         * @function verify
         * @memberof PB_SCRaPartsGiftInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaPartsGiftInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.giftSeq != null && message.hasOwnProperty("giftSeq"))
                if (!$util.isInteger(message.giftSeq))
                    return "giftSeq: integer expected";
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (!$util.isInteger(message.beginTime) && !(message.beginTime && $util.isInteger(message.beginTime.low) && $util.isInteger(message.beginTime.high)))
                    return "beginTime: integer|Long expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaPartsGiftInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaPartsGiftInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaPartsGiftInfo} PB_SCRaPartsGiftInfo
         */
        PB_SCRaPartsGiftInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaPartsGiftInfo)
                return object;
            var message = new $root.PB_SCRaPartsGiftInfo();
            if (object.giftSeq != null)
                message.giftSeq = object.giftSeq | 0;
            if (object.beginTime != null)
                if ($util.Long)
                    (message.beginTime = $util.Long.fromValue(object.beginTime)).unsigned = false;
                else if (typeof object.beginTime === "string")
                    message.beginTime = parseInt(object.beginTime, 10);
                else if (typeof object.beginTime === "number")
                    message.beginTime = object.beginTime;
                else if (typeof object.beginTime === "object")
                    message.beginTime = new $util.LongBits(object.beginTime.low >>> 0, object.beginTime.high >>> 0).toNumber();
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = false;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaPartsGiftInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaPartsGiftInfo
         * @static
         * @param {PB_SCRaPartsGiftInfo} message PB_SCRaPartsGiftInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaPartsGiftInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.giftSeq = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.beginTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.beginTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTime = options.longs === String ? "0" : 0;
            }
            if (message.giftSeq != null && message.hasOwnProperty("giftSeq"))
                object.giftSeq = message.giftSeq;
            if (message.beginTime != null && message.hasOwnProperty("beginTime"))
                if (typeof message.beginTime === "number")
                    object.beginTime = options.longs === String ? String(message.beginTime) : message.beginTime;
                else
                    object.beginTime = options.longs === String ? $util.Long.prototype.toString.call(message.beginTime) : options.longs === Number ? new $util.LongBits(message.beginTime.low >>> 0, message.beginTime.high >>> 0).toNumber() : message.beginTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (typeof message.endTime === "number")
                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                else
                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber() : message.endTime;
            return object;
        };
    
        /**
         * Converts this PB_SCRaPartsGiftInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaPartsGiftInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaPartsGiftInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaPartsGiftInfo;
    })();
    
    $root.PB_SCRaBackYardInfo = (function() {
    
        /**
         * Properties of a PB_SCRaBackYardInfo.
         * @exports IPB_SCRaBackYardInfo
         * @interface IPB_SCRaBackYardInfo
         * @property {number|null} [fightCount] PB_SCRaBackYardInfo fightCount
         * @property {number|null} [passDay] PB_SCRaBackYardInfo passDay
         * @property {Array.<boolean>|null} [rewardFlag] PB_SCRaBackYardInfo rewardFlag
         */
    
        /**
         * Constructs a new PB_SCRaBackYardInfo.
         * @exports PB_SCRaBackYardInfo
         * @classdesc Represents a PB_SCRaBackYardInfo.
         * @implements IPB_SCRaBackYardInfo
         * @constructor
         * @param {IPB_SCRaBackYardInfo=} [properties] Properties to set
         */
        function PB_SCRaBackYardInfo(properties) {
            this.rewardFlag = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaBackYardInfo fightCount.
         * @member {number} fightCount
         * @memberof PB_SCRaBackYardInfo
         * @instance
         */
        PB_SCRaBackYardInfo.prototype.fightCount = 0;
    
        /**
         * PB_SCRaBackYardInfo passDay.
         * @member {number} passDay
         * @memberof PB_SCRaBackYardInfo
         * @instance
         */
        PB_SCRaBackYardInfo.prototype.passDay = 0;
    
        /**
         * PB_SCRaBackYardInfo rewardFlag.
         * @member {Array.<boolean>} rewardFlag
         * @memberof PB_SCRaBackYardInfo
         * @instance
         */
        PB_SCRaBackYardInfo.prototype.rewardFlag = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaBackYardInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaBackYardInfo
         * @static
         * @param {IPB_SCRaBackYardInfo=} [properties] Properties to set
         * @returns {PB_SCRaBackYardInfo} PB_SCRaBackYardInfo instance
         */
        PB_SCRaBackYardInfo.create = function create(properties) {
            return new PB_SCRaBackYardInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaBackYardInfo message. Does not implicitly {@link PB_SCRaBackYardInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaBackYardInfo
         * @static
         * @param {IPB_SCRaBackYardInfo} message PB_SCRaBackYardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaBackYardInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fightCount != null && Object.hasOwnProperty.call(message, "fightCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fightCount);
            if (message.passDay != null && Object.hasOwnProperty.call(message, "passDay"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.passDay);
            if (message.rewardFlag != null && message.rewardFlag.length)
                for (var i = 0; i < message.rewardFlag.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.rewardFlag[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaBackYardInfo message, length delimited. Does not implicitly {@link PB_SCRaBackYardInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaBackYardInfo
         * @static
         * @param {IPB_SCRaBackYardInfo} message PB_SCRaBackYardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaBackYardInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaBackYardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaBackYardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaBackYardInfo} PB_SCRaBackYardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaBackYardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaBackYardInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fightCount = reader.int32();
                    break;
                case 2:
                    message.passDay = reader.int32();
                    break;
                case 3:
                    if (!(message.rewardFlag && message.rewardFlag.length))
                        message.rewardFlag = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rewardFlag.push(reader.bool());
                    } else
                        message.rewardFlag.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaBackYardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaBackYardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaBackYardInfo} PB_SCRaBackYardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaBackYardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaBackYardInfo message.
         * @function verify
         * @memberof PB_SCRaBackYardInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaBackYardInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fightCount != null && message.hasOwnProperty("fightCount"))
                if (!$util.isInteger(message.fightCount))
                    return "fightCount: integer expected";
            if (message.passDay != null && message.hasOwnProperty("passDay"))
                if (!$util.isInteger(message.passDay))
                    return "passDay: integer expected";
            if (message.rewardFlag != null && message.hasOwnProperty("rewardFlag")) {
                if (!Array.isArray(message.rewardFlag))
                    return "rewardFlag: array expected";
                for (var i = 0; i < message.rewardFlag.length; ++i)
                    if (typeof message.rewardFlag[i] !== "boolean")
                        return "rewardFlag: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaBackYardInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaBackYardInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaBackYardInfo} PB_SCRaBackYardInfo
         */
        PB_SCRaBackYardInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaBackYardInfo)
                return object;
            var message = new $root.PB_SCRaBackYardInfo();
            if (object.fightCount != null)
                message.fightCount = object.fightCount | 0;
            if (object.passDay != null)
                message.passDay = object.passDay | 0;
            if (object.rewardFlag) {
                if (!Array.isArray(object.rewardFlag))
                    throw TypeError(".PB_SCRaBackYardInfo.rewardFlag: array expected");
                message.rewardFlag = [];
                for (var i = 0; i < object.rewardFlag.length; ++i)
                    message.rewardFlag[i] = Boolean(object.rewardFlag[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaBackYardInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaBackYardInfo
         * @static
         * @param {PB_SCRaBackYardInfo} message PB_SCRaBackYardInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaBackYardInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rewardFlag = [];
            if (options.defaults) {
                object.fightCount = 0;
                object.passDay = 0;
            }
            if (message.fightCount != null && message.hasOwnProperty("fightCount"))
                object.fightCount = message.fightCount;
            if (message.passDay != null && message.hasOwnProperty("passDay"))
                object.passDay = message.passDay;
            if (message.rewardFlag && message.rewardFlag.length) {
                object.rewardFlag = [];
                for (var j = 0; j < message.rewardFlag.length; ++j)
                    object.rewardFlag[j] = message.rewardFlag[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaBackYardInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaBackYardInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaBackYardInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaBackYardInfo;
    })();
    
    $root.PB_SCBackYardPassList = (function() {
    
        /**
         * Properties of a PB_SCBackYardPassList.
         * @exports IPB_SCBackYardPassList
         * @interface IPB_SCBackYardPassList
         * @property {boolean|null} [isActive] PB_SCBackYardPassList isActive
         * @property {Array.<boolean>|null} [isFetch] PB_SCBackYardPassList isFetch
         */
    
        /**
         * Constructs a new PB_SCBackYardPassList.
         * @exports PB_SCBackYardPassList
         * @classdesc Represents a PB_SCBackYardPassList.
         * @implements IPB_SCBackYardPassList
         * @constructor
         * @param {IPB_SCBackYardPassList=} [properties] Properties to set
         */
        function PB_SCBackYardPassList(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCBackYardPassList isActive.
         * @member {boolean} isActive
         * @memberof PB_SCBackYardPassList
         * @instance
         */
        PB_SCBackYardPassList.prototype.isActive = false;
    
        /**
         * PB_SCBackYardPassList isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCBackYardPassList
         * @instance
         */
        PB_SCBackYardPassList.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCBackYardPassList instance using the specified properties.
         * @function create
         * @memberof PB_SCBackYardPassList
         * @static
         * @param {IPB_SCBackYardPassList=} [properties] Properties to set
         * @returns {PB_SCBackYardPassList} PB_SCBackYardPassList instance
         */
        PB_SCBackYardPassList.create = function create(properties) {
            return new PB_SCBackYardPassList(properties);
        };
    
        /**
         * Encodes the specified PB_SCBackYardPassList message. Does not implicitly {@link PB_SCBackYardPassList.verify|verify} messages.
         * @function encode
         * @memberof PB_SCBackYardPassList
         * @static
         * @param {IPB_SCBackYardPassList} message PB_SCBackYardPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBackYardPassList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isActive);
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCBackYardPassList message, length delimited. Does not implicitly {@link PB_SCBackYardPassList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCBackYardPassList
         * @static
         * @param {IPB_SCBackYardPassList} message PB_SCBackYardPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCBackYardPassList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCBackYardPassList message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCBackYardPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCBackYardPassList} PB_SCBackYardPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBackYardPassList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCBackYardPassList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.bool();
                    break;
                case 2:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCBackYardPassList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCBackYardPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCBackYardPassList} PB_SCBackYardPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCBackYardPassList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCBackYardPassList message.
         * @function verify
         * @memberof PB_SCBackYardPassList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCBackYardPassList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (typeof message.isActive !== "boolean")
                    return "isActive: boolean expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCBackYardPassList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCBackYardPassList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCBackYardPassList} PB_SCBackYardPassList
         */
        PB_SCBackYardPassList.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCBackYardPassList)
                return object;
            var message = new $root.PB_SCBackYardPassList();
            if (object.isActive != null)
                message.isActive = Boolean(object.isActive);
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCBackYardPassList.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCBackYardPassList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCBackYardPassList
         * @static
         * @param {PB_SCBackYardPassList} message PB_SCBackYardPassList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCBackYardPassList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (options.defaults)
                object.isActive = false;
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCBackYardPassList to JSON.
         * @function toJSON
         * @memberof PB_SCBackYardPassList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCBackYardPassList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCBackYardPassList;
    })();
    
    $root.PB_SCRaBackYardPassInfo = (function() {
    
        /**
         * Properties of a PB_SCRaBackYardPassInfo.
         * @exports IPB_SCRaBackYardPassInfo
         * @interface IPB_SCRaBackYardPassInfo
         * @property {Array.<IPB_SCBackYardPassList>|null} [list] PB_SCRaBackYardPassInfo list
         * @property {number|null} [passDay] PB_SCRaBackYardPassInfo passDay
         */
    
        /**
         * Constructs a new PB_SCRaBackYardPassInfo.
         * @exports PB_SCRaBackYardPassInfo
         * @classdesc Represents a PB_SCRaBackYardPassInfo.
         * @implements IPB_SCRaBackYardPassInfo
         * @constructor
         * @param {IPB_SCRaBackYardPassInfo=} [properties] Properties to set
         */
        function PB_SCRaBackYardPassInfo(properties) {
            this.list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaBackYardPassInfo list.
         * @member {Array.<IPB_SCBackYardPassList>} list
         * @memberof PB_SCRaBackYardPassInfo
         * @instance
         */
        PB_SCRaBackYardPassInfo.prototype.list = $util.emptyArray;
    
        /**
         * PB_SCRaBackYardPassInfo passDay.
         * @member {number} passDay
         * @memberof PB_SCRaBackYardPassInfo
         * @instance
         */
        PB_SCRaBackYardPassInfo.prototype.passDay = 0;
    
        /**
         * Creates a new PB_SCRaBackYardPassInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaBackYardPassInfo
         * @static
         * @param {IPB_SCRaBackYardPassInfo=} [properties] Properties to set
         * @returns {PB_SCRaBackYardPassInfo} PB_SCRaBackYardPassInfo instance
         */
        PB_SCRaBackYardPassInfo.create = function create(properties) {
            return new PB_SCRaBackYardPassInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaBackYardPassInfo message. Does not implicitly {@link PB_SCRaBackYardPassInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaBackYardPassInfo
         * @static
         * @param {IPB_SCRaBackYardPassInfo} message PB_SCRaBackYardPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaBackYardPassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.list.length)
                for (var i = 0; i < message.list.length; ++i)
                    $root.PB_SCBackYardPassList.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.passDay != null && Object.hasOwnProperty.call(message, "passDay"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.passDay);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaBackYardPassInfo message, length delimited. Does not implicitly {@link PB_SCRaBackYardPassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaBackYardPassInfo
         * @static
         * @param {IPB_SCRaBackYardPassInfo} message PB_SCRaBackYardPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaBackYardPassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaBackYardPassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaBackYardPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaBackYardPassInfo} PB_SCRaBackYardPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaBackYardPassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaBackYardPassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.PB_SCBackYardPassList.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.passDay = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaBackYardPassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaBackYardPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaBackYardPassInfo} PB_SCRaBackYardPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaBackYardPassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaBackYardPassInfo message.
         * @function verify
         * @memberof PB_SCRaBackYardPassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaBackYardPassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list))
                    return "list: array expected";
                for (var i = 0; i < message.list.length; ++i) {
                    var error = $root.PB_SCBackYardPassList.verify(message.list[i]);
                    if (error)
                        return "list." + error;
                }
            }
            if (message.passDay != null && message.hasOwnProperty("passDay"))
                if (!$util.isInteger(message.passDay))
                    return "passDay: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaBackYardPassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaBackYardPassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaBackYardPassInfo} PB_SCRaBackYardPassInfo
         */
        PB_SCRaBackYardPassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaBackYardPassInfo)
                return object;
            var message = new $root.PB_SCRaBackYardPassInfo();
            if (object.list) {
                if (!Array.isArray(object.list))
                    throw TypeError(".PB_SCRaBackYardPassInfo.list: array expected");
                message.list = [];
                for (var i = 0; i < object.list.length; ++i) {
                    if (typeof object.list[i] !== "object")
                        throw TypeError(".PB_SCRaBackYardPassInfo.list: object expected");
                    message.list[i] = $root.PB_SCBackYardPassList.fromObject(object.list[i]);
                }
            }
            if (object.passDay != null)
                message.passDay = object.passDay | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaBackYardPassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaBackYardPassInfo
         * @static
         * @param {PB_SCRaBackYardPassInfo} message PB_SCRaBackYardPassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaBackYardPassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.list = [];
            if (options.defaults)
                object.passDay = 0;
            if (message.list && message.list.length) {
                object.list = [];
                for (var j = 0; j < message.list.length; ++j)
                    object.list[j] = $root.PB_SCBackYardPassList.toObject(message.list[j], options);
            }
            if (message.passDay != null && message.hasOwnProperty("passDay"))
                object.passDay = message.passDay;
            return object;
        };
    
        /**
         * Converts this PB_SCRaBackYardPassInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaBackYardPassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaBackYardPassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaBackYardPassInfo;
    })();
    
    $root.PB_SCRaFarmingTask = (function() {
    
        /**
         * Properties of a PB_SCRaFarmingTask.
         * @exports IPB_SCRaFarmingTask
         * @interface IPB_SCRaFarmingTask
         * @property {number|null} [taskSeq] PB_SCRaFarmingTask taskSeq
         * @property {number|Long|null} [taskTypeProgress] PB_SCRaFarmingTask taskTypeProgress
         */
    
        /**
         * Constructs a new PB_SCRaFarmingTask.
         * @exports PB_SCRaFarmingTask
         * @classdesc Represents a PB_SCRaFarmingTask.
         * @implements IPB_SCRaFarmingTask
         * @constructor
         * @param {IPB_SCRaFarmingTask=} [properties] Properties to set
         */
        function PB_SCRaFarmingTask(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaFarmingTask taskSeq.
         * @member {number} taskSeq
         * @memberof PB_SCRaFarmingTask
         * @instance
         */
        PB_SCRaFarmingTask.prototype.taskSeq = 0;
    
        /**
         * PB_SCRaFarmingTask taskTypeProgress.
         * @member {number|Long} taskTypeProgress
         * @memberof PB_SCRaFarmingTask
         * @instance
         */
        PB_SCRaFarmingTask.prototype.taskTypeProgress = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCRaFarmingTask instance using the specified properties.
         * @function create
         * @memberof PB_SCRaFarmingTask
         * @static
         * @param {IPB_SCRaFarmingTask=} [properties] Properties to set
         * @returns {PB_SCRaFarmingTask} PB_SCRaFarmingTask instance
         */
        PB_SCRaFarmingTask.create = function create(properties) {
            return new PB_SCRaFarmingTask(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaFarmingTask message. Does not implicitly {@link PB_SCRaFarmingTask.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaFarmingTask
         * @static
         * @param {IPB_SCRaFarmingTask} message PB_SCRaFarmingTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFarmingTask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskSeq != null && Object.hasOwnProperty.call(message, "taskSeq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskSeq);
            if (message.taskTypeProgress != null && Object.hasOwnProperty.call(message, "taskTypeProgress"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.taskTypeProgress);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaFarmingTask message, length delimited. Does not implicitly {@link PB_SCRaFarmingTask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaFarmingTask
         * @static
         * @param {IPB_SCRaFarmingTask} message PB_SCRaFarmingTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFarmingTask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaFarmingTask message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaFarmingTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaFarmingTask} PB_SCRaFarmingTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFarmingTask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaFarmingTask();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskSeq = reader.int32();
                    break;
                case 2:
                    message.taskTypeProgress = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaFarmingTask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaFarmingTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaFarmingTask} PB_SCRaFarmingTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFarmingTask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaFarmingTask message.
         * @function verify
         * @memberof PB_SCRaFarmingTask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaFarmingTask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskSeq != null && message.hasOwnProperty("taskSeq"))
                if (!$util.isInteger(message.taskSeq))
                    return "taskSeq: integer expected";
            if (message.taskTypeProgress != null && message.hasOwnProperty("taskTypeProgress"))
                if (!$util.isInteger(message.taskTypeProgress) && !(message.taskTypeProgress && $util.isInteger(message.taskTypeProgress.low) && $util.isInteger(message.taskTypeProgress.high)))
                    return "taskTypeProgress: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaFarmingTask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaFarmingTask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaFarmingTask} PB_SCRaFarmingTask
         */
        PB_SCRaFarmingTask.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaFarmingTask)
                return object;
            var message = new $root.PB_SCRaFarmingTask();
            if (object.taskSeq != null)
                message.taskSeq = object.taskSeq | 0;
            if (object.taskTypeProgress != null)
                if ($util.Long)
                    (message.taskTypeProgress = $util.Long.fromValue(object.taskTypeProgress)).unsigned = false;
                else if (typeof object.taskTypeProgress === "string")
                    message.taskTypeProgress = parseInt(object.taskTypeProgress, 10);
                else if (typeof object.taskTypeProgress === "number")
                    message.taskTypeProgress = object.taskTypeProgress;
                else if (typeof object.taskTypeProgress === "object")
                    message.taskTypeProgress = new $util.LongBits(object.taskTypeProgress.low >>> 0, object.taskTypeProgress.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaFarmingTask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaFarmingTask
         * @static
         * @param {PB_SCRaFarmingTask} message PB_SCRaFarmingTask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaFarmingTask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.taskSeq = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.taskTypeProgress = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.taskTypeProgress = options.longs === String ? "0" : 0;
            }
            if (message.taskSeq != null && message.hasOwnProperty("taskSeq"))
                object.taskSeq = message.taskSeq;
            if (message.taskTypeProgress != null && message.hasOwnProperty("taskTypeProgress"))
                if (typeof message.taskTypeProgress === "number")
                    object.taskTypeProgress = options.longs === String ? String(message.taskTypeProgress) : message.taskTypeProgress;
                else
                    object.taskTypeProgress = options.longs === String ? $util.Long.prototype.toString.call(message.taskTypeProgress) : options.longs === Number ? new $util.LongBits(message.taskTypeProgress.low >>> 0, message.taskTypeProgress.high >>> 0).toNumber() : message.taskTypeProgress;
            return object;
        };
    
        /**
         * Converts this PB_SCRaFarmingTask to JSON.
         * @function toJSON
         * @memberof PB_SCRaFarmingTask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaFarmingTask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaFarmingTask;
    })();
    
    $root.PB_SCRaFarminginfo = (function() {
    
        /**
         * Properties of a PB_SCRaFarminginfo.
         * @exports IPB_SCRaFarminginfo
         * @interface IPB_SCRaFarminginfo
         * @property {Array.<IPB_SCRaFarmingTask>|null} [taskList] PB_SCRaFarminginfo taskList
         * @property {Array.<boolean>|null} [lineRewardFlag] PB_SCRaFarminginfo lineRewardFlag
         * @property {Array.<boolean>|null} [cellList] PB_SCRaFarminginfo cellList
         * @property {Array.<number>|null} [shopBuyCount] PB_SCRaFarminginfo shopBuyCount
         * @property {number|null} [cellCount] PB_SCRaFarminginfo cellCount
         * @property {boolean|null} [cellCountIsFetch] PB_SCRaFarminginfo cellCountIsFetch
         */
    
        /**
         * Constructs a new PB_SCRaFarminginfo.
         * @exports PB_SCRaFarminginfo
         * @classdesc Represents a PB_SCRaFarminginfo.
         * @implements IPB_SCRaFarminginfo
         * @constructor
         * @param {IPB_SCRaFarminginfo=} [properties] Properties to set
         */
        function PB_SCRaFarminginfo(properties) {
            this.taskList = [];
            this.lineRewardFlag = [];
            this.cellList = [];
            this.shopBuyCount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaFarminginfo taskList.
         * @member {Array.<IPB_SCRaFarmingTask>} taskList
         * @memberof PB_SCRaFarminginfo
         * @instance
         */
        PB_SCRaFarminginfo.prototype.taskList = $util.emptyArray;
    
        /**
         * PB_SCRaFarminginfo lineRewardFlag.
         * @member {Array.<boolean>} lineRewardFlag
         * @memberof PB_SCRaFarminginfo
         * @instance
         */
        PB_SCRaFarminginfo.prototype.lineRewardFlag = $util.emptyArray;
    
        /**
         * PB_SCRaFarminginfo cellList.
         * @member {Array.<boolean>} cellList
         * @memberof PB_SCRaFarminginfo
         * @instance
         */
        PB_SCRaFarminginfo.prototype.cellList = $util.emptyArray;
    
        /**
         * PB_SCRaFarminginfo shopBuyCount.
         * @member {Array.<number>} shopBuyCount
         * @memberof PB_SCRaFarminginfo
         * @instance
         */
        PB_SCRaFarminginfo.prototype.shopBuyCount = $util.emptyArray;
    
        /**
         * PB_SCRaFarminginfo cellCount.
         * @member {number} cellCount
         * @memberof PB_SCRaFarminginfo
         * @instance
         */
        PB_SCRaFarminginfo.prototype.cellCount = 0;
    
        /**
         * PB_SCRaFarminginfo cellCountIsFetch.
         * @member {boolean} cellCountIsFetch
         * @memberof PB_SCRaFarminginfo
         * @instance
         */
        PB_SCRaFarminginfo.prototype.cellCountIsFetch = false;
    
        /**
         * Creates a new PB_SCRaFarminginfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaFarminginfo
         * @static
         * @param {IPB_SCRaFarminginfo=} [properties] Properties to set
         * @returns {PB_SCRaFarminginfo} PB_SCRaFarminginfo instance
         */
        PB_SCRaFarminginfo.create = function create(properties) {
            return new PB_SCRaFarminginfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaFarminginfo message. Does not implicitly {@link PB_SCRaFarminginfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaFarminginfo
         * @static
         * @param {IPB_SCRaFarminginfo} message PB_SCRaFarminginfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFarminginfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskList != null && message.taskList.length)
                for (var i = 0; i < message.taskList.length; ++i)
                    $root.PB_SCRaFarmingTask.encode(message.taskList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lineRewardFlag != null && message.lineRewardFlag.length)
                for (var i = 0; i < message.lineRewardFlag.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.lineRewardFlag[i]);
            if (message.cellList != null && message.cellList.length)
                for (var i = 0; i < message.cellList.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.cellList[i]);
            if (message.shopBuyCount != null && message.shopBuyCount.length)
                for (var i = 0; i < message.shopBuyCount.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.shopBuyCount[i]);
            if (message.cellCount != null && Object.hasOwnProperty.call(message, "cellCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.cellCount);
            if (message.cellCountIsFetch != null && Object.hasOwnProperty.call(message, "cellCountIsFetch"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.cellCountIsFetch);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaFarminginfo message, length delimited. Does not implicitly {@link PB_SCRaFarminginfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaFarminginfo
         * @static
         * @param {IPB_SCRaFarminginfo} message PB_SCRaFarminginfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFarminginfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaFarminginfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaFarminginfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaFarminginfo} PB_SCRaFarminginfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFarminginfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaFarminginfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.taskList && message.taskList.length))
                        message.taskList = [];
                    message.taskList.push($root.PB_SCRaFarmingTask.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.lineRewardFlag && message.lineRewardFlag.length))
                        message.lineRewardFlag = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.lineRewardFlag.push(reader.bool());
                    } else
                        message.lineRewardFlag.push(reader.bool());
                    break;
                case 3:
                    if (!(message.cellList && message.cellList.length))
                        message.cellList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.cellList.push(reader.bool());
                    } else
                        message.cellList.push(reader.bool());
                    break;
                case 4:
                    if (!(message.shopBuyCount && message.shopBuyCount.length))
                        message.shopBuyCount = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.shopBuyCount.push(reader.int32());
                    } else
                        message.shopBuyCount.push(reader.int32());
                    break;
                case 5:
                    message.cellCount = reader.int32();
                    break;
                case 6:
                    message.cellCountIsFetch = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaFarminginfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaFarminginfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaFarminginfo} PB_SCRaFarminginfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFarminginfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaFarminginfo message.
         * @function verify
         * @memberof PB_SCRaFarminginfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaFarminginfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskList != null && message.hasOwnProperty("taskList")) {
                if (!Array.isArray(message.taskList))
                    return "taskList: array expected";
                for (var i = 0; i < message.taskList.length; ++i) {
                    var error = $root.PB_SCRaFarmingTask.verify(message.taskList[i]);
                    if (error)
                        return "taskList." + error;
                }
            }
            if (message.lineRewardFlag != null && message.hasOwnProperty("lineRewardFlag")) {
                if (!Array.isArray(message.lineRewardFlag))
                    return "lineRewardFlag: array expected";
                for (var i = 0; i < message.lineRewardFlag.length; ++i)
                    if (typeof message.lineRewardFlag[i] !== "boolean")
                        return "lineRewardFlag: boolean[] expected";
            }
            if (message.cellList != null && message.hasOwnProperty("cellList")) {
                if (!Array.isArray(message.cellList))
                    return "cellList: array expected";
                for (var i = 0; i < message.cellList.length; ++i)
                    if (typeof message.cellList[i] !== "boolean")
                        return "cellList: boolean[] expected";
            }
            if (message.shopBuyCount != null && message.hasOwnProperty("shopBuyCount")) {
                if (!Array.isArray(message.shopBuyCount))
                    return "shopBuyCount: array expected";
                for (var i = 0; i < message.shopBuyCount.length; ++i)
                    if (!$util.isInteger(message.shopBuyCount[i]))
                        return "shopBuyCount: integer[] expected";
            }
            if (message.cellCount != null && message.hasOwnProperty("cellCount"))
                if (!$util.isInteger(message.cellCount))
                    return "cellCount: integer expected";
            if (message.cellCountIsFetch != null && message.hasOwnProperty("cellCountIsFetch"))
                if (typeof message.cellCountIsFetch !== "boolean")
                    return "cellCountIsFetch: boolean expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaFarminginfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaFarminginfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaFarminginfo} PB_SCRaFarminginfo
         */
        PB_SCRaFarminginfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaFarminginfo)
                return object;
            var message = new $root.PB_SCRaFarminginfo();
            if (object.taskList) {
                if (!Array.isArray(object.taskList))
                    throw TypeError(".PB_SCRaFarminginfo.taskList: array expected");
                message.taskList = [];
                for (var i = 0; i < object.taskList.length; ++i) {
                    if (typeof object.taskList[i] !== "object")
                        throw TypeError(".PB_SCRaFarminginfo.taskList: object expected");
                    message.taskList[i] = $root.PB_SCRaFarmingTask.fromObject(object.taskList[i]);
                }
            }
            if (object.lineRewardFlag) {
                if (!Array.isArray(object.lineRewardFlag))
                    throw TypeError(".PB_SCRaFarminginfo.lineRewardFlag: array expected");
                message.lineRewardFlag = [];
                for (var i = 0; i < object.lineRewardFlag.length; ++i)
                    message.lineRewardFlag[i] = Boolean(object.lineRewardFlag[i]);
            }
            if (object.cellList) {
                if (!Array.isArray(object.cellList))
                    throw TypeError(".PB_SCRaFarminginfo.cellList: array expected");
                message.cellList = [];
                for (var i = 0; i < object.cellList.length; ++i)
                    message.cellList[i] = Boolean(object.cellList[i]);
            }
            if (object.shopBuyCount) {
                if (!Array.isArray(object.shopBuyCount))
                    throw TypeError(".PB_SCRaFarminginfo.shopBuyCount: array expected");
                message.shopBuyCount = [];
                for (var i = 0; i < object.shopBuyCount.length; ++i)
                    message.shopBuyCount[i] = object.shopBuyCount[i] | 0;
            }
            if (object.cellCount != null)
                message.cellCount = object.cellCount | 0;
            if (object.cellCountIsFetch != null)
                message.cellCountIsFetch = Boolean(object.cellCountIsFetch);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaFarminginfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaFarminginfo
         * @static
         * @param {PB_SCRaFarminginfo} message PB_SCRaFarminginfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaFarminginfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.taskList = [];
                object.lineRewardFlag = [];
                object.cellList = [];
                object.shopBuyCount = [];
            }
            if (options.defaults) {
                object.cellCount = 0;
                object.cellCountIsFetch = false;
            }
            if (message.taskList && message.taskList.length) {
                object.taskList = [];
                for (var j = 0; j < message.taskList.length; ++j)
                    object.taskList[j] = $root.PB_SCRaFarmingTask.toObject(message.taskList[j], options);
            }
            if (message.lineRewardFlag && message.lineRewardFlag.length) {
                object.lineRewardFlag = [];
                for (var j = 0; j < message.lineRewardFlag.length; ++j)
                    object.lineRewardFlag[j] = message.lineRewardFlag[j];
            }
            if (message.cellList && message.cellList.length) {
                object.cellList = [];
                for (var j = 0; j < message.cellList.length; ++j)
                    object.cellList[j] = message.cellList[j];
            }
            if (message.shopBuyCount && message.shopBuyCount.length) {
                object.shopBuyCount = [];
                for (var j = 0; j < message.shopBuyCount.length; ++j)
                    object.shopBuyCount[j] = message.shopBuyCount[j];
            }
            if (message.cellCount != null && message.hasOwnProperty("cellCount"))
                object.cellCount = message.cellCount;
            if (message.cellCountIsFetch != null && message.hasOwnProperty("cellCountIsFetch"))
                object.cellCountIsFetch = message.cellCountIsFetch;
            return object;
        };
    
        /**
         * Converts this PB_SCRaFarminginfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaFarminginfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaFarminginfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaFarminginfo;
    })();
    
    $root.PB_SCArenaPassList = (function() {
    
        /**
         * Properties of a PB_SCArenaPassList.
         * @exports IPB_SCArenaPassList
         * @interface IPB_SCArenaPassList
         * @property {boolean|null} [isActive] PB_SCArenaPassList isActive
         * @property {Array.<boolean>|null} [isFetch] PB_SCArenaPassList isFetch
         */
    
        /**
         * Constructs a new PB_SCArenaPassList.
         * @exports PB_SCArenaPassList
         * @classdesc Represents a PB_SCArenaPassList.
         * @implements IPB_SCArenaPassList
         * @constructor
         * @param {IPB_SCArenaPassList=} [properties] Properties to set
         */
        function PB_SCArenaPassList(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCArenaPassList isActive.
         * @member {boolean} isActive
         * @memberof PB_SCArenaPassList
         * @instance
         */
        PB_SCArenaPassList.prototype.isActive = false;
    
        /**
         * PB_SCArenaPassList isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCArenaPassList
         * @instance
         */
        PB_SCArenaPassList.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCArenaPassList instance using the specified properties.
         * @function create
         * @memberof PB_SCArenaPassList
         * @static
         * @param {IPB_SCArenaPassList=} [properties] Properties to set
         * @returns {PB_SCArenaPassList} PB_SCArenaPassList instance
         */
        PB_SCArenaPassList.create = function create(properties) {
            return new PB_SCArenaPassList(properties);
        };
    
        /**
         * Encodes the specified PB_SCArenaPassList message. Does not implicitly {@link PB_SCArenaPassList.verify|verify} messages.
         * @function encode
         * @memberof PB_SCArenaPassList
         * @static
         * @param {IPB_SCArenaPassList} message PB_SCArenaPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaPassList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isActive);
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCArenaPassList message, length delimited. Does not implicitly {@link PB_SCArenaPassList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCArenaPassList
         * @static
         * @param {IPB_SCArenaPassList} message PB_SCArenaPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCArenaPassList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCArenaPassList message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCArenaPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCArenaPassList} PB_SCArenaPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaPassList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCArenaPassList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.bool();
                    break;
                case 2:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCArenaPassList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCArenaPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCArenaPassList} PB_SCArenaPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCArenaPassList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCArenaPassList message.
         * @function verify
         * @memberof PB_SCArenaPassList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCArenaPassList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (typeof message.isActive !== "boolean")
                    return "isActive: boolean expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCArenaPassList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCArenaPassList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCArenaPassList} PB_SCArenaPassList
         */
        PB_SCArenaPassList.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCArenaPassList)
                return object;
            var message = new $root.PB_SCArenaPassList();
            if (object.isActive != null)
                message.isActive = Boolean(object.isActive);
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCArenaPassList.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCArenaPassList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCArenaPassList
         * @static
         * @param {PB_SCArenaPassList} message PB_SCArenaPassList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCArenaPassList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (options.defaults)
                object.isActive = false;
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCArenaPassList to JSON.
         * @function toJSON
         * @memberof PB_SCArenaPassList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCArenaPassList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCArenaPassList;
    })();
    
    $root.PB_SCRaArenaPassInfo = (function() {
    
        /**
         * Properties of a PB_SCRaArenaPassInfo.
         * @exports IPB_SCRaArenaPassInfo
         * @interface IPB_SCRaArenaPassInfo
         * @property {Array.<IPB_SCBackYardPassList>|null} [list] PB_SCRaArenaPassInfo list
         * @property {number|null} [score] PB_SCRaArenaPassInfo score
         * @property {number|null} [fetchExRewardCount] PB_SCRaArenaPassInfo fetchExRewardCount
         * @property {number|null} [level] PB_SCRaArenaPassInfo level
         */
    
        /**
         * Constructs a new PB_SCRaArenaPassInfo.
         * @exports PB_SCRaArenaPassInfo
         * @classdesc Represents a PB_SCRaArenaPassInfo.
         * @implements IPB_SCRaArenaPassInfo
         * @constructor
         * @param {IPB_SCRaArenaPassInfo=} [properties] Properties to set
         */
        function PB_SCRaArenaPassInfo(properties) {
            this.list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaArenaPassInfo list.
         * @member {Array.<IPB_SCBackYardPassList>} list
         * @memberof PB_SCRaArenaPassInfo
         * @instance
         */
        PB_SCRaArenaPassInfo.prototype.list = $util.emptyArray;
    
        /**
         * PB_SCRaArenaPassInfo score.
         * @member {number} score
         * @memberof PB_SCRaArenaPassInfo
         * @instance
         */
        PB_SCRaArenaPassInfo.prototype.score = 0;
    
        /**
         * PB_SCRaArenaPassInfo fetchExRewardCount.
         * @member {number} fetchExRewardCount
         * @memberof PB_SCRaArenaPassInfo
         * @instance
         */
        PB_SCRaArenaPassInfo.prototype.fetchExRewardCount = 0;
    
        /**
         * PB_SCRaArenaPassInfo level.
         * @member {number} level
         * @memberof PB_SCRaArenaPassInfo
         * @instance
         */
        PB_SCRaArenaPassInfo.prototype.level = 0;
    
        /**
         * Creates a new PB_SCRaArenaPassInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaArenaPassInfo
         * @static
         * @param {IPB_SCRaArenaPassInfo=} [properties] Properties to set
         * @returns {PB_SCRaArenaPassInfo} PB_SCRaArenaPassInfo instance
         */
        PB_SCRaArenaPassInfo.create = function create(properties) {
            return new PB_SCRaArenaPassInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaArenaPassInfo message. Does not implicitly {@link PB_SCRaArenaPassInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaArenaPassInfo
         * @static
         * @param {IPB_SCRaArenaPassInfo} message PB_SCRaArenaPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaArenaPassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.list.length)
                for (var i = 0; i < message.list.length; ++i)
                    $root.PB_SCBackYardPassList.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.score);
            if (message.fetchExRewardCount != null && Object.hasOwnProperty.call(message, "fetchExRewardCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fetchExRewardCount);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.level);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaArenaPassInfo message, length delimited. Does not implicitly {@link PB_SCRaArenaPassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaArenaPassInfo
         * @static
         * @param {IPB_SCRaArenaPassInfo} message PB_SCRaArenaPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaArenaPassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaArenaPassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaArenaPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaArenaPassInfo} PB_SCRaArenaPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaArenaPassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaArenaPassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.PB_SCBackYardPassList.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.score = reader.int32();
                    break;
                case 3:
                    message.fetchExRewardCount = reader.int32();
                    break;
                case 4:
                    message.level = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaArenaPassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaArenaPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaArenaPassInfo} PB_SCRaArenaPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaArenaPassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaArenaPassInfo message.
         * @function verify
         * @memberof PB_SCRaArenaPassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaArenaPassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list))
                    return "list: array expected";
                for (var i = 0; i < message.list.length; ++i) {
                    var error = $root.PB_SCBackYardPassList.verify(message.list[i]);
                    if (error)
                        return "list." + error;
                }
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.fetchExRewardCount != null && message.hasOwnProperty("fetchExRewardCount"))
                if (!$util.isInteger(message.fetchExRewardCount))
                    return "fetchExRewardCount: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaArenaPassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaArenaPassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaArenaPassInfo} PB_SCRaArenaPassInfo
         */
        PB_SCRaArenaPassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaArenaPassInfo)
                return object;
            var message = new $root.PB_SCRaArenaPassInfo();
            if (object.list) {
                if (!Array.isArray(object.list))
                    throw TypeError(".PB_SCRaArenaPassInfo.list: array expected");
                message.list = [];
                for (var i = 0; i < object.list.length; ++i) {
                    if (typeof object.list[i] !== "object")
                        throw TypeError(".PB_SCRaArenaPassInfo.list: object expected");
                    message.list[i] = $root.PB_SCBackYardPassList.fromObject(object.list[i]);
                }
            }
            if (object.score != null)
                message.score = object.score | 0;
            if (object.fetchExRewardCount != null)
                message.fetchExRewardCount = object.fetchExRewardCount | 0;
            if (object.level != null)
                message.level = object.level | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaArenaPassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaArenaPassInfo
         * @static
         * @param {PB_SCRaArenaPassInfo} message PB_SCRaArenaPassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaArenaPassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.list = [];
            if (options.defaults) {
                object.score = 0;
                object.fetchExRewardCount = 0;
                object.level = 0;
            }
            if (message.list && message.list.length) {
                object.list = [];
                for (var j = 0; j < message.list.length; ++j)
                    object.list[j] = $root.PB_SCBackYardPassList.toObject(message.list[j], options);
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.fetchExRewardCount != null && message.hasOwnProperty("fetchExRewardCount"))
                object.fetchExRewardCount = message.fetchExRewardCount;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            return object;
        };
    
        /**
         * Converts this PB_SCRaArenaPassInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaArenaPassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaArenaPassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaArenaPassInfo;
    })();
    
    $root.PB_SCRaFarmingRet = (function() {
    
        /**
         * Properties of a PB_SCRaFarmingRet.
         * @exports IPB_SCRaFarmingRet
         * @interface IPB_SCRaFarmingRet
         * @property {number|null} [retType] PB_SCRaFarmingRet retType
         * @property {Array.<number>|null} [param] PB_SCRaFarmingRet param
         */
    
        /**
         * Constructs a new PB_SCRaFarmingRet.
         * @exports PB_SCRaFarmingRet
         * @classdesc Represents a PB_SCRaFarmingRet.
         * @implements IPB_SCRaFarmingRet
         * @constructor
         * @param {IPB_SCRaFarmingRet=} [properties] Properties to set
         */
        function PB_SCRaFarmingRet(properties) {
            this.param = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaFarmingRet retType.
         * @member {number} retType
         * @memberof PB_SCRaFarmingRet
         * @instance
         */
        PB_SCRaFarmingRet.prototype.retType = 0;
    
        /**
         * PB_SCRaFarmingRet param.
         * @member {Array.<number>} param
         * @memberof PB_SCRaFarmingRet
         * @instance
         */
        PB_SCRaFarmingRet.prototype.param = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaFarmingRet instance using the specified properties.
         * @function create
         * @memberof PB_SCRaFarmingRet
         * @static
         * @param {IPB_SCRaFarmingRet=} [properties] Properties to set
         * @returns {PB_SCRaFarmingRet} PB_SCRaFarmingRet instance
         */
        PB_SCRaFarmingRet.create = function create(properties) {
            return new PB_SCRaFarmingRet(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaFarmingRet message. Does not implicitly {@link PB_SCRaFarmingRet.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaFarmingRet
         * @static
         * @param {IPB_SCRaFarmingRet} message PB_SCRaFarmingRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFarmingRet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retType != null && Object.hasOwnProperty.call(message, "retType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.retType);
            if (message.param != null && message.param.length)
                for (var i = 0; i < message.param.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.param[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaFarmingRet message, length delimited. Does not implicitly {@link PB_SCRaFarmingRet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaFarmingRet
         * @static
         * @param {IPB_SCRaFarmingRet} message PB_SCRaFarmingRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFarmingRet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaFarmingRet message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaFarmingRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaFarmingRet} PB_SCRaFarmingRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFarmingRet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaFarmingRet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.retType = reader.int32();
                    break;
                case 2:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaFarmingRet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaFarmingRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaFarmingRet} PB_SCRaFarmingRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFarmingRet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaFarmingRet message.
         * @function verify
         * @memberof PB_SCRaFarmingRet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaFarmingRet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.retType != null && message.hasOwnProperty("retType"))
                if (!$util.isInteger(message.retType))
                    return "retType: integer expected";
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (var i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaFarmingRet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaFarmingRet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaFarmingRet} PB_SCRaFarmingRet
         */
        PB_SCRaFarmingRet.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaFarmingRet)
                return object;
            var message = new $root.PB_SCRaFarmingRet();
            if (object.retType != null)
                message.retType = object.retType | 0;
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".PB_SCRaFarmingRet.param: array expected");
                message.param = [];
                for (var i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaFarmingRet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaFarmingRet
         * @static
         * @param {PB_SCRaFarmingRet} message PB_SCRaFarmingRet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaFarmingRet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.param = [];
            if (options.defaults)
                object.retType = 0;
            if (message.retType != null && message.hasOwnProperty("retType"))
                object.retType = message.retType;
            if (message.param && message.param.length) {
                object.param = [];
                for (var j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaFarmingRet to JSON.
         * @function toJSON
         * @memberof PB_SCRaFarmingRet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaFarmingRet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaFarmingRet;
    })();
    
    $root.PB_SCRaFishPassList = (function() {
    
        /**
         * Properties of a PB_SCRaFishPassList.
         * @exports IPB_SCRaFishPassList
         * @interface IPB_SCRaFishPassList
         * @property {boolean|null} [isActive] PB_SCRaFishPassList isActive
         * @property {Array.<boolean>|null} [isFetch] PB_SCRaFishPassList isFetch
         */
    
        /**
         * Constructs a new PB_SCRaFishPassList.
         * @exports PB_SCRaFishPassList
         * @classdesc Represents a PB_SCRaFishPassList.
         * @implements IPB_SCRaFishPassList
         * @constructor
         * @param {IPB_SCRaFishPassList=} [properties] Properties to set
         */
        function PB_SCRaFishPassList(properties) {
            this.isFetch = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaFishPassList isActive.
         * @member {boolean} isActive
         * @memberof PB_SCRaFishPassList
         * @instance
         */
        PB_SCRaFishPassList.prototype.isActive = false;
    
        /**
         * PB_SCRaFishPassList isFetch.
         * @member {Array.<boolean>} isFetch
         * @memberof PB_SCRaFishPassList
         * @instance
         */
        PB_SCRaFishPassList.prototype.isFetch = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaFishPassList instance using the specified properties.
         * @function create
         * @memberof PB_SCRaFishPassList
         * @static
         * @param {IPB_SCRaFishPassList=} [properties] Properties to set
         * @returns {PB_SCRaFishPassList} PB_SCRaFishPassList instance
         */
        PB_SCRaFishPassList.create = function create(properties) {
            return new PB_SCRaFishPassList(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaFishPassList message. Does not implicitly {@link PB_SCRaFishPassList.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaFishPassList
         * @static
         * @param {IPB_SCRaFishPassList} message PB_SCRaFishPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFishPassList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isActive);
            if (message.isFetch != null && message.isFetch.length)
                for (var i = 0; i < message.isFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isFetch[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaFishPassList message, length delimited. Does not implicitly {@link PB_SCRaFishPassList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaFishPassList
         * @static
         * @param {IPB_SCRaFishPassList} message PB_SCRaFishPassList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFishPassList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaFishPassList message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaFishPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaFishPassList} PB_SCRaFishPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFishPassList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaFishPassList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.bool();
                    break;
                case 2:
                    if (!(message.isFetch && message.isFetch.length))
                        message.isFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.isFetch.push(reader.bool());
                    } else
                        message.isFetch.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaFishPassList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaFishPassList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaFishPassList} PB_SCRaFishPassList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFishPassList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaFishPassList message.
         * @function verify
         * @memberof PB_SCRaFishPassList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaFishPassList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (typeof message.isActive !== "boolean")
                    return "isActive: boolean expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch")) {
                if (!Array.isArray(message.isFetch))
                    return "isFetch: array expected";
                for (var i = 0; i < message.isFetch.length; ++i)
                    if (typeof message.isFetch[i] !== "boolean")
                        return "isFetch: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaFishPassList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaFishPassList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaFishPassList} PB_SCRaFishPassList
         */
        PB_SCRaFishPassList.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaFishPassList)
                return object;
            var message = new $root.PB_SCRaFishPassList();
            if (object.isActive != null)
                message.isActive = Boolean(object.isActive);
            if (object.isFetch) {
                if (!Array.isArray(object.isFetch))
                    throw TypeError(".PB_SCRaFishPassList.isFetch: array expected");
                message.isFetch = [];
                for (var i = 0; i < object.isFetch.length; ++i)
                    message.isFetch[i] = Boolean(object.isFetch[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaFishPassList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaFishPassList
         * @static
         * @param {PB_SCRaFishPassList} message PB_SCRaFishPassList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaFishPassList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.isFetch = [];
            if (options.defaults)
                object.isActive = false;
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            if (message.isFetch && message.isFetch.length) {
                object.isFetch = [];
                for (var j = 0; j < message.isFetch.length; ++j)
                    object.isFetch[j] = message.isFetch[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaFishPassList to JSON.
         * @function toJSON
         * @memberof PB_SCRaFishPassList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaFishPassList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaFishPassList;
    })();
    
    $root.PB_SCRaFishPassInfo = (function() {
    
        /**
         * Properties of a PB_SCRaFishPassInfo.
         * @exports IPB_SCRaFishPassInfo
         * @interface IPB_SCRaFishPassInfo
         * @property {Array.<IPB_SCRaRoundPassList>|null} [list] PB_SCRaFishPassInfo list
         * @property {number|null} [meters] PB_SCRaFishPassInfo meters
         * @property {number|null} [fetchExRewardCount] PB_SCRaFishPassInfo fetchExRewardCount
         */
    
        /**
         * Constructs a new PB_SCRaFishPassInfo.
         * @exports PB_SCRaFishPassInfo
         * @classdesc Represents a PB_SCRaFishPassInfo.
         * @implements IPB_SCRaFishPassInfo
         * @constructor
         * @param {IPB_SCRaFishPassInfo=} [properties] Properties to set
         */
        function PB_SCRaFishPassInfo(properties) {
            this.list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaFishPassInfo list.
         * @member {Array.<IPB_SCRaRoundPassList>} list
         * @memberof PB_SCRaFishPassInfo
         * @instance
         */
        PB_SCRaFishPassInfo.prototype.list = $util.emptyArray;
    
        /**
         * PB_SCRaFishPassInfo meters.
         * @member {number} meters
         * @memberof PB_SCRaFishPassInfo
         * @instance
         */
        PB_SCRaFishPassInfo.prototype.meters = 0;
    
        /**
         * PB_SCRaFishPassInfo fetchExRewardCount.
         * @member {number} fetchExRewardCount
         * @memberof PB_SCRaFishPassInfo
         * @instance
         */
        PB_SCRaFishPassInfo.prototype.fetchExRewardCount = 0;
    
        /**
         * Creates a new PB_SCRaFishPassInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaFishPassInfo
         * @static
         * @param {IPB_SCRaFishPassInfo=} [properties] Properties to set
         * @returns {PB_SCRaFishPassInfo} PB_SCRaFishPassInfo instance
         */
        PB_SCRaFishPassInfo.create = function create(properties) {
            return new PB_SCRaFishPassInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaFishPassInfo message. Does not implicitly {@link PB_SCRaFishPassInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaFishPassInfo
         * @static
         * @param {IPB_SCRaFishPassInfo} message PB_SCRaFishPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFishPassInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.list.length)
                for (var i = 0; i < message.list.length; ++i)
                    $root.PB_SCRaRoundPassList.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.meters != null && Object.hasOwnProperty.call(message, "meters"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.meters);
            if (message.fetchExRewardCount != null && Object.hasOwnProperty.call(message, "fetchExRewardCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fetchExRewardCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaFishPassInfo message, length delimited. Does not implicitly {@link PB_SCRaFishPassInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaFishPassInfo
         * @static
         * @param {IPB_SCRaFishPassInfo} message PB_SCRaFishPassInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaFishPassInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaFishPassInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaFishPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaFishPassInfo} PB_SCRaFishPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFishPassInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaFishPassInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push($root.PB_SCRaRoundPassList.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.meters = reader.int32();
                    break;
                case 3:
                    message.fetchExRewardCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaFishPassInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaFishPassInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaFishPassInfo} PB_SCRaFishPassInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaFishPassInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaFishPassInfo message.
         * @function verify
         * @memberof PB_SCRaFishPassInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaFishPassInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list))
                    return "list: array expected";
                for (var i = 0; i < message.list.length; ++i) {
                    var error = $root.PB_SCRaRoundPassList.verify(message.list[i]);
                    if (error)
                        return "list." + error;
                }
            }
            if (message.meters != null && message.hasOwnProperty("meters"))
                if (!$util.isInteger(message.meters))
                    return "meters: integer expected";
            if (message.fetchExRewardCount != null && message.hasOwnProperty("fetchExRewardCount"))
                if (!$util.isInteger(message.fetchExRewardCount))
                    return "fetchExRewardCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaFishPassInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaFishPassInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaFishPassInfo} PB_SCRaFishPassInfo
         */
        PB_SCRaFishPassInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaFishPassInfo)
                return object;
            var message = new $root.PB_SCRaFishPassInfo();
            if (object.list) {
                if (!Array.isArray(object.list))
                    throw TypeError(".PB_SCRaFishPassInfo.list: array expected");
                message.list = [];
                for (var i = 0; i < object.list.length; ++i) {
                    if (typeof object.list[i] !== "object")
                        throw TypeError(".PB_SCRaFishPassInfo.list: object expected");
                    message.list[i] = $root.PB_SCRaRoundPassList.fromObject(object.list[i]);
                }
            }
            if (object.meters != null)
                message.meters = object.meters | 0;
            if (object.fetchExRewardCount != null)
                message.fetchExRewardCount = object.fetchExRewardCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaFishPassInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaFishPassInfo
         * @static
         * @param {PB_SCRaFishPassInfo} message PB_SCRaFishPassInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaFishPassInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.list = [];
            if (options.defaults) {
                object.meters = 0;
                object.fetchExRewardCount = 0;
            }
            if (message.list && message.list.length) {
                object.list = [];
                for (var j = 0; j < message.list.length; ++j)
                    object.list[j] = $root.PB_SCRaRoundPassList.toObject(message.list[j], options);
            }
            if (message.meters != null && message.hasOwnProperty("meters"))
                object.meters = message.meters;
            if (message.fetchExRewardCount != null && message.hasOwnProperty("fetchExRewardCount"))
                object.fetchExRewardCount = message.fetchExRewardCount;
            return object;
        };
    
        /**
         * Converts this PB_SCRaFishPassInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaFishPassInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaFishPassInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaFishPassInfo;
    })();
    
    $root.PB_SCRaPickUpInfo = (function() {
    
        /**
         * Properties of a PB_SCRaPickUpInfo.
         * @exports IPB_SCRaPickUpInfo
         * @interface IPB_SCRaPickUpInfo
         * @property {Array.<number>|null} [taskProgress] PB_SCRaPickUpInfo taskProgress
         * @property {Array.<boolean>|null} [taskFetch] PB_SCRaPickUpInfo taskFetch
         * @property {Array.<number>|null} [giftBuyCount] PB_SCRaPickUpInfo giftBuyCount
         * @property {number|null} [drawCount] PB_SCRaPickUpInfo drawCount
         */
    
        /**
         * Constructs a new PB_SCRaPickUpInfo.
         * @exports PB_SCRaPickUpInfo
         * @classdesc Represents a PB_SCRaPickUpInfo.
         * @implements IPB_SCRaPickUpInfo
         * @constructor
         * @param {IPB_SCRaPickUpInfo=} [properties] Properties to set
         */
        function PB_SCRaPickUpInfo(properties) {
            this.taskProgress = [];
            this.taskFetch = [];
            this.giftBuyCount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaPickUpInfo taskProgress.
         * @member {Array.<number>} taskProgress
         * @memberof PB_SCRaPickUpInfo
         * @instance
         */
        PB_SCRaPickUpInfo.prototype.taskProgress = $util.emptyArray;
    
        /**
         * PB_SCRaPickUpInfo taskFetch.
         * @member {Array.<boolean>} taskFetch
         * @memberof PB_SCRaPickUpInfo
         * @instance
         */
        PB_SCRaPickUpInfo.prototype.taskFetch = $util.emptyArray;
    
        /**
         * PB_SCRaPickUpInfo giftBuyCount.
         * @member {Array.<number>} giftBuyCount
         * @memberof PB_SCRaPickUpInfo
         * @instance
         */
        PB_SCRaPickUpInfo.prototype.giftBuyCount = $util.emptyArray;
    
        /**
         * PB_SCRaPickUpInfo drawCount.
         * @member {number} drawCount
         * @memberof PB_SCRaPickUpInfo
         * @instance
         */
        PB_SCRaPickUpInfo.prototype.drawCount = 0;
    
        /**
         * Creates a new PB_SCRaPickUpInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaPickUpInfo
         * @static
         * @param {IPB_SCRaPickUpInfo=} [properties] Properties to set
         * @returns {PB_SCRaPickUpInfo} PB_SCRaPickUpInfo instance
         */
        PB_SCRaPickUpInfo.create = function create(properties) {
            return new PB_SCRaPickUpInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaPickUpInfo message. Does not implicitly {@link PB_SCRaPickUpInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaPickUpInfo
         * @static
         * @param {IPB_SCRaPickUpInfo} message PB_SCRaPickUpInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaPickUpInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskProgress != null && message.taskProgress.length)
                for (var i = 0; i < message.taskProgress.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskProgress[i]);
            if (message.taskFetch != null && message.taskFetch.length)
                for (var i = 0; i < message.taskFetch.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.taskFetch[i]);
            if (message.giftBuyCount != null && message.giftBuyCount.length)
                for (var i = 0; i < message.giftBuyCount.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.giftBuyCount[i]);
            if (message.drawCount != null && Object.hasOwnProperty.call(message, "drawCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.drawCount);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaPickUpInfo message, length delimited. Does not implicitly {@link PB_SCRaPickUpInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaPickUpInfo
         * @static
         * @param {IPB_SCRaPickUpInfo} message PB_SCRaPickUpInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaPickUpInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaPickUpInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaPickUpInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaPickUpInfo} PB_SCRaPickUpInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaPickUpInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaPickUpInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.taskProgress && message.taskProgress.length))
                        message.taskProgress = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.taskProgress.push(reader.int32());
                    } else
                        message.taskProgress.push(reader.int32());
                    break;
                case 2:
                    if (!(message.taskFetch && message.taskFetch.length))
                        message.taskFetch = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.taskFetch.push(reader.bool());
                    } else
                        message.taskFetch.push(reader.bool());
                    break;
                case 3:
                    if (!(message.giftBuyCount && message.giftBuyCount.length))
                        message.giftBuyCount = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.giftBuyCount.push(reader.int32());
                    } else
                        message.giftBuyCount.push(reader.int32());
                    break;
                case 4:
                    message.drawCount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaPickUpInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaPickUpInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaPickUpInfo} PB_SCRaPickUpInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaPickUpInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaPickUpInfo message.
         * @function verify
         * @memberof PB_SCRaPickUpInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaPickUpInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskProgress != null && message.hasOwnProperty("taskProgress")) {
                if (!Array.isArray(message.taskProgress))
                    return "taskProgress: array expected";
                for (var i = 0; i < message.taskProgress.length; ++i)
                    if (!$util.isInteger(message.taskProgress[i]))
                        return "taskProgress: integer[] expected";
            }
            if (message.taskFetch != null && message.hasOwnProperty("taskFetch")) {
                if (!Array.isArray(message.taskFetch))
                    return "taskFetch: array expected";
                for (var i = 0; i < message.taskFetch.length; ++i)
                    if (typeof message.taskFetch[i] !== "boolean")
                        return "taskFetch: boolean[] expected";
            }
            if (message.giftBuyCount != null && message.hasOwnProperty("giftBuyCount")) {
                if (!Array.isArray(message.giftBuyCount))
                    return "giftBuyCount: array expected";
                for (var i = 0; i < message.giftBuyCount.length; ++i)
                    if (!$util.isInteger(message.giftBuyCount[i]))
                        return "giftBuyCount: integer[] expected";
            }
            if (message.drawCount != null && message.hasOwnProperty("drawCount"))
                if (!$util.isInteger(message.drawCount))
                    return "drawCount: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRaPickUpInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaPickUpInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaPickUpInfo} PB_SCRaPickUpInfo
         */
        PB_SCRaPickUpInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaPickUpInfo)
                return object;
            var message = new $root.PB_SCRaPickUpInfo();
            if (object.taskProgress) {
                if (!Array.isArray(object.taskProgress))
                    throw TypeError(".PB_SCRaPickUpInfo.taskProgress: array expected");
                message.taskProgress = [];
                for (var i = 0; i < object.taskProgress.length; ++i)
                    message.taskProgress[i] = object.taskProgress[i] | 0;
            }
            if (object.taskFetch) {
                if (!Array.isArray(object.taskFetch))
                    throw TypeError(".PB_SCRaPickUpInfo.taskFetch: array expected");
                message.taskFetch = [];
                for (var i = 0; i < object.taskFetch.length; ++i)
                    message.taskFetch[i] = Boolean(object.taskFetch[i]);
            }
            if (object.giftBuyCount) {
                if (!Array.isArray(object.giftBuyCount))
                    throw TypeError(".PB_SCRaPickUpInfo.giftBuyCount: array expected");
                message.giftBuyCount = [];
                for (var i = 0; i < object.giftBuyCount.length; ++i)
                    message.giftBuyCount[i] = object.giftBuyCount[i] | 0;
            }
            if (object.drawCount != null)
                message.drawCount = object.drawCount | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaPickUpInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaPickUpInfo
         * @static
         * @param {PB_SCRaPickUpInfo} message PB_SCRaPickUpInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaPickUpInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.taskProgress = [];
                object.taskFetch = [];
                object.giftBuyCount = [];
            }
            if (options.defaults)
                object.drawCount = 0;
            if (message.taskProgress && message.taskProgress.length) {
                object.taskProgress = [];
                for (var j = 0; j < message.taskProgress.length; ++j)
                    object.taskProgress[j] = message.taskProgress[j];
            }
            if (message.taskFetch && message.taskFetch.length) {
                object.taskFetch = [];
                for (var j = 0; j < message.taskFetch.length; ++j)
                    object.taskFetch[j] = message.taskFetch[j];
            }
            if (message.giftBuyCount && message.giftBuyCount.length) {
                object.giftBuyCount = [];
                for (var j = 0; j < message.giftBuyCount.length; ++j)
                    object.giftBuyCount[j] = message.giftBuyCount[j];
            }
            if (message.drawCount != null && message.hasOwnProperty("drawCount"))
                object.drawCount = message.drawCount;
            return object;
        };
    
        /**
         * Converts this PB_SCRaPickUpInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaPickUpInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaPickUpInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaPickUpInfo;
    })();
    
    $root.PB_SCRaArenaDailyGiftInfo = (function() {
    
        /**
         * Properties of a PB_SCRaArenaDailyGiftInfo.
         * @exports IPB_SCRaArenaDailyGiftInfo
         * @interface IPB_SCRaArenaDailyGiftInfo
         * @property {Array.<number>|null} [giftBuyCount] PB_SCRaArenaDailyGiftInfo giftBuyCount
         */
    
        /**
         * Constructs a new PB_SCRaArenaDailyGiftInfo.
         * @exports PB_SCRaArenaDailyGiftInfo
         * @classdesc Represents a PB_SCRaArenaDailyGiftInfo.
         * @implements IPB_SCRaArenaDailyGiftInfo
         * @constructor
         * @param {IPB_SCRaArenaDailyGiftInfo=} [properties] Properties to set
         */
        function PB_SCRaArenaDailyGiftInfo(properties) {
            this.giftBuyCount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaArenaDailyGiftInfo giftBuyCount.
         * @member {Array.<number>} giftBuyCount
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @instance
         */
        PB_SCRaArenaDailyGiftInfo.prototype.giftBuyCount = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaArenaDailyGiftInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @static
         * @param {IPB_SCRaArenaDailyGiftInfo=} [properties] Properties to set
         * @returns {PB_SCRaArenaDailyGiftInfo} PB_SCRaArenaDailyGiftInfo instance
         */
        PB_SCRaArenaDailyGiftInfo.create = function create(properties) {
            return new PB_SCRaArenaDailyGiftInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaArenaDailyGiftInfo message. Does not implicitly {@link PB_SCRaArenaDailyGiftInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @static
         * @param {IPB_SCRaArenaDailyGiftInfo} message PB_SCRaArenaDailyGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaArenaDailyGiftInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.giftBuyCount != null && message.giftBuyCount.length)
                for (var i = 0; i < message.giftBuyCount.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.giftBuyCount[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaArenaDailyGiftInfo message, length delimited. Does not implicitly {@link PB_SCRaArenaDailyGiftInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @static
         * @param {IPB_SCRaArenaDailyGiftInfo} message PB_SCRaArenaDailyGiftInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaArenaDailyGiftInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaArenaDailyGiftInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaArenaDailyGiftInfo} PB_SCRaArenaDailyGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaArenaDailyGiftInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaArenaDailyGiftInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.giftBuyCount && message.giftBuyCount.length))
                        message.giftBuyCount = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.giftBuyCount.push(reader.int32());
                    } else
                        message.giftBuyCount.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaArenaDailyGiftInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaArenaDailyGiftInfo} PB_SCRaArenaDailyGiftInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaArenaDailyGiftInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaArenaDailyGiftInfo message.
         * @function verify
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaArenaDailyGiftInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.giftBuyCount != null && message.hasOwnProperty("giftBuyCount")) {
                if (!Array.isArray(message.giftBuyCount))
                    return "giftBuyCount: array expected";
                for (var i = 0; i < message.giftBuyCount.length; ++i)
                    if (!$util.isInteger(message.giftBuyCount[i]))
                        return "giftBuyCount: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaArenaDailyGiftInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaArenaDailyGiftInfo} PB_SCRaArenaDailyGiftInfo
         */
        PB_SCRaArenaDailyGiftInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaArenaDailyGiftInfo)
                return object;
            var message = new $root.PB_SCRaArenaDailyGiftInfo();
            if (object.giftBuyCount) {
                if (!Array.isArray(object.giftBuyCount))
                    throw TypeError(".PB_SCRaArenaDailyGiftInfo.giftBuyCount: array expected");
                message.giftBuyCount = [];
                for (var i = 0; i < object.giftBuyCount.length; ++i)
                    message.giftBuyCount[i] = object.giftBuyCount[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaArenaDailyGiftInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @static
         * @param {PB_SCRaArenaDailyGiftInfo} message PB_SCRaArenaDailyGiftInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaArenaDailyGiftInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.giftBuyCount = [];
            if (message.giftBuyCount && message.giftBuyCount.length) {
                object.giftBuyCount = [];
                for (var j = 0; j < message.giftBuyCount.length; ++j)
                    object.giftBuyCount[j] = message.giftBuyCount[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaArenaDailyGiftInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaArenaDailyGiftInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaArenaDailyGiftInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaArenaDailyGiftInfo;
    })();
    
    $root.PB_SCRankNode = (function() {
    
        /**
         * Properties of a PB_SCRankNode.
         * @exports IPB_SCRankNode
         * @interface IPB_SCRankNode
         * @property {IPB_RoleInfo|null} [roleInfo] PB_SCRankNode roleInfo
         * @property {number|null} [rankLevel] PB_SCRankNode rankLevel
         */
    
        /**
         * Constructs a new PB_SCRankNode.
         * @exports PB_SCRankNode
         * @classdesc Represents a PB_SCRankNode.
         * @implements IPB_SCRankNode
         * @constructor
         * @param {IPB_SCRankNode=} [properties] Properties to set
         */
        function PB_SCRankNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRankNode roleInfo.
         * @member {IPB_RoleInfo|null|undefined} roleInfo
         * @memberof PB_SCRankNode
         * @instance
         */
        PB_SCRankNode.prototype.roleInfo = null;
    
        /**
         * PB_SCRankNode rankLevel.
         * @member {number} rankLevel
         * @memberof PB_SCRankNode
         * @instance
         */
        PB_SCRankNode.prototype.rankLevel = 0;
    
        /**
         * Creates a new PB_SCRankNode instance using the specified properties.
         * @function create
         * @memberof PB_SCRankNode
         * @static
         * @param {IPB_SCRankNode=} [properties] Properties to set
         * @returns {PB_SCRankNode} PB_SCRankNode instance
         */
        PB_SCRankNode.create = function create(properties) {
            return new PB_SCRankNode(properties);
        };
    
        /**
         * Encodes the specified PB_SCRankNode message. Does not implicitly {@link PB_SCRankNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRankNode
         * @static
         * @param {IPB_SCRankNode} message PB_SCRankNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRankNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleInfo != null && Object.hasOwnProperty.call(message, "roleInfo"))
                $root.PB_RoleInfo.encode(message.roleInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rankLevel != null && Object.hasOwnProperty.call(message, "rankLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rankLevel);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRankNode message, length delimited. Does not implicitly {@link PB_SCRankNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRankNode
         * @static
         * @param {IPB_SCRankNode} message PB_SCRankNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRankNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRankNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRankNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRankNode} PB_SCRankNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRankNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRankNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.rankLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRankNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRankNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRankNode} PB_SCRankNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRankNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRankNode message.
         * @function verify
         * @memberof PB_SCRankNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRankNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleInfo);
                if (error)
                    return "roleInfo." + error;
            }
            if (message.rankLevel != null && message.hasOwnProperty("rankLevel"))
                if (!$util.isInteger(message.rankLevel))
                    return "rankLevel: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRankNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRankNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRankNode} PB_SCRankNode
         */
        PB_SCRankNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRankNode)
                return object;
            var message = new $root.PB_SCRankNode();
            if (object.roleInfo != null) {
                if (typeof object.roleInfo !== "object")
                    throw TypeError(".PB_SCRankNode.roleInfo: object expected");
                message.roleInfo = $root.PB_RoleInfo.fromObject(object.roleInfo);
            }
            if (object.rankLevel != null)
                message.rankLevel = object.rankLevel | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRankNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRankNode
         * @static
         * @param {PB_SCRankNode} message PB_SCRankNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRankNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roleInfo = null;
                object.rankLevel = 0;
            }
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo"))
                object.roleInfo = $root.PB_RoleInfo.toObject(message.roleInfo, options);
            if (message.rankLevel != null && message.hasOwnProperty("rankLevel"))
                object.rankLevel = message.rankLevel;
            return object;
        };
    
        /**
         * Converts this PB_SCRankNode to JSON.
         * @function toJSON
         * @memberof PB_SCRankNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRankNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRankNode;
    })();
    
    $root.PB_SCRankList = (function() {
    
        /**
         * Properties of a PB_SCRankList.
         * @exports IPB_SCRankList
         * @interface IPB_SCRankList
         * @property {number|null} [type] PB_SCRankList type
         * @property {number|null} [listBegin] PB_SCRankList listBegin
         * @property {Array.<IPB_SCRankNode>|null} [ranklist] PB_SCRankList ranklist
         * @property {number|null} [myRank] PB_SCRankList myRank
         * @property {number|Long|null} [myRankValue] PB_SCRankList myRankValue
         */
    
        /**
         * Constructs a new PB_SCRankList.
         * @exports PB_SCRankList
         * @classdesc Represents a PB_SCRankList.
         * @implements IPB_SCRankList
         * @constructor
         * @param {IPB_SCRankList=} [properties] Properties to set
         */
        function PB_SCRankList(properties) {
            this.ranklist = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRankList type.
         * @member {number} type
         * @memberof PB_SCRankList
         * @instance
         */
        PB_SCRankList.prototype.type = 0;
    
        /**
         * PB_SCRankList listBegin.
         * @member {number} listBegin
         * @memberof PB_SCRankList
         * @instance
         */
        PB_SCRankList.prototype.listBegin = 0;
    
        /**
         * PB_SCRankList ranklist.
         * @member {Array.<IPB_SCRankNode>} ranklist
         * @memberof PB_SCRankList
         * @instance
         */
        PB_SCRankList.prototype.ranklist = $util.emptyArray;
    
        /**
         * PB_SCRankList myRank.
         * @member {number} myRank
         * @memberof PB_SCRankList
         * @instance
         */
        PB_SCRankList.prototype.myRank = 0;
    
        /**
         * PB_SCRankList myRankValue.
         * @member {number|Long} myRankValue
         * @memberof PB_SCRankList
         * @instance
         */
        PB_SCRankList.prototype.myRankValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new PB_SCRankList instance using the specified properties.
         * @function create
         * @memberof PB_SCRankList
         * @static
         * @param {IPB_SCRankList=} [properties] Properties to set
         * @returns {PB_SCRankList} PB_SCRankList instance
         */
        PB_SCRankList.create = function create(properties) {
            return new PB_SCRankList(properties);
        };
    
        /**
         * Encodes the specified PB_SCRankList message. Does not implicitly {@link PB_SCRankList.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRankList
         * @static
         * @param {IPB_SCRankList} message PB_SCRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRankList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.listBegin != null && Object.hasOwnProperty.call(message, "listBegin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.listBegin);
            if (message.ranklist != null && message.ranklist.length)
                for (var i = 0; i < message.ranklist.length; ++i)
                    $root.PB_SCRankNode.encode(message.ranklist[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.myRank != null && Object.hasOwnProperty.call(message, "myRank"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.myRank);
            if (message.myRankValue != null && Object.hasOwnProperty.call(message, "myRankValue"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.myRankValue);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRankList message, length delimited. Does not implicitly {@link PB_SCRankList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRankList
         * @static
         * @param {IPB_SCRankList} message PB_SCRankList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRankList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRankList message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRankList} PB_SCRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRankList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRankList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.listBegin = reader.int32();
                    break;
                case 3:
                    if (!(message.ranklist && message.ranklist.length))
                        message.ranklist = [];
                    message.ranklist.push($root.PB_SCRankNode.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.myRank = reader.int32();
                    break;
                case 5:
                    message.myRankValue = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRankList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRankList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRankList} PB_SCRankList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRankList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRankList message.
         * @function verify
         * @memberof PB_SCRankList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRankList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.listBegin != null && message.hasOwnProperty("listBegin"))
                if (!$util.isInteger(message.listBegin))
                    return "listBegin: integer expected";
            if (message.ranklist != null && message.hasOwnProperty("ranklist")) {
                if (!Array.isArray(message.ranklist))
                    return "ranklist: array expected";
                for (var i = 0; i < message.ranklist.length; ++i) {
                    var error = $root.PB_SCRankNode.verify(message.ranklist[i]);
                    if (error)
                        return "ranklist." + error;
                }
            }
            if (message.myRank != null && message.hasOwnProperty("myRank"))
                if (!$util.isInteger(message.myRank))
                    return "myRank: integer expected";
            if (message.myRankValue != null && message.hasOwnProperty("myRankValue"))
                if (!$util.isInteger(message.myRankValue) && !(message.myRankValue && $util.isInteger(message.myRankValue.low) && $util.isInteger(message.myRankValue.high)))
                    return "myRankValue: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRankList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRankList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRankList} PB_SCRankList
         */
        PB_SCRankList.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRankList)
                return object;
            var message = new $root.PB_SCRankList();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.listBegin != null)
                message.listBegin = object.listBegin | 0;
            if (object.ranklist) {
                if (!Array.isArray(object.ranklist))
                    throw TypeError(".PB_SCRankList.ranklist: array expected");
                message.ranklist = [];
                for (var i = 0; i < object.ranklist.length; ++i) {
                    if (typeof object.ranklist[i] !== "object")
                        throw TypeError(".PB_SCRankList.ranklist: object expected");
                    message.ranklist[i] = $root.PB_SCRankNode.fromObject(object.ranklist[i]);
                }
            }
            if (object.myRank != null)
                message.myRank = object.myRank | 0;
            if (object.myRankValue != null)
                if ($util.Long)
                    (message.myRankValue = $util.Long.fromValue(object.myRankValue)).unsigned = false;
                else if (typeof object.myRankValue === "string")
                    message.myRankValue = parseInt(object.myRankValue, 10);
                else if (typeof object.myRankValue === "number")
                    message.myRankValue = object.myRankValue;
                else if (typeof object.myRankValue === "object")
                    message.myRankValue = new $util.LongBits(object.myRankValue.low >>> 0, object.myRankValue.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRankList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRankList
         * @static
         * @param {PB_SCRankList} message PB_SCRankList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRankList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ranklist = [];
            if (options.defaults) {
                object.type = 0;
                object.listBegin = 0;
                object.myRank = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.myRankValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.myRankValue = options.longs === String ? "0" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.listBegin != null && message.hasOwnProperty("listBegin"))
                object.listBegin = message.listBegin;
            if (message.ranklist && message.ranklist.length) {
                object.ranklist = [];
                for (var j = 0; j < message.ranklist.length; ++j)
                    object.ranklist[j] = $root.PB_SCRankNode.toObject(message.ranklist[j], options);
            }
            if (message.myRank != null && message.hasOwnProperty("myRank"))
                object.myRank = message.myRank;
            if (message.myRankValue != null && message.hasOwnProperty("myRankValue"))
                if (typeof message.myRankValue === "number")
                    object.myRankValue = options.longs === String ? String(message.myRankValue) : message.myRankValue;
                else
                    object.myRankValue = options.longs === String ? $util.Long.prototype.toString.call(message.myRankValue) : options.longs === Number ? new $util.LongBits(message.myRankValue.low >>> 0, message.myRankValue.high >>> 0).toNumber() : message.myRankValue;
            return object;
        };
    
        /**
         * Converts this PB_SCRankList to JSON.
         * @function toJSON
         * @memberof PB_SCRankList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRankList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRankList;
    })();
    
    $root.PB_CSRankReq = (function() {
    
        /**
         * Properties of a PB_CSRankReq.
         * @exports IPB_CSRankReq
         * @interface IPB_CSRankReq
         * @property {number|null} [type] PB_CSRankReq type
         * @property {number|null} [listBegin] PB_CSRankReq listBegin
         */
    
        /**
         * Constructs a new PB_CSRankReq.
         * @exports PB_CSRankReq
         * @classdesc Represents a PB_CSRankReq.
         * @implements IPB_CSRankReq
         * @constructor
         * @param {IPB_CSRankReq=} [properties] Properties to set
         */
        function PB_CSRankReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSRankReq type.
         * @member {number} type
         * @memberof PB_CSRankReq
         * @instance
         */
        PB_CSRankReq.prototype.type = 0;
    
        /**
         * PB_CSRankReq listBegin.
         * @member {number} listBegin
         * @memberof PB_CSRankReq
         * @instance
         */
        PB_CSRankReq.prototype.listBegin = 0;
    
        /**
         * Creates a new PB_CSRankReq instance using the specified properties.
         * @function create
         * @memberof PB_CSRankReq
         * @static
         * @param {IPB_CSRankReq=} [properties] Properties to set
         * @returns {PB_CSRankReq} PB_CSRankReq instance
         */
        PB_CSRankReq.create = function create(properties) {
            return new PB_CSRankReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSRankReq message. Does not implicitly {@link PB_CSRankReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSRankReq
         * @static
         * @param {IPB_CSRankReq} message PB_CSRankReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRankReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.listBegin != null && Object.hasOwnProperty.call(message, "listBegin"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.listBegin);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSRankReq message, length delimited. Does not implicitly {@link PB_CSRankReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSRankReq
         * @static
         * @param {IPB_CSRankReq} message PB_CSRankReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRankReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSRankReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSRankReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSRankReq} PB_CSRankReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRankReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSRankReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.listBegin = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSRankReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSRankReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSRankReq} PB_CSRankReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRankReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSRankReq message.
         * @function verify
         * @memberof PB_CSRankReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSRankReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.listBegin != null && message.hasOwnProperty("listBegin"))
                if (!$util.isInteger(message.listBegin))
                    return "listBegin: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSRankReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSRankReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSRankReq} PB_CSRankReq
         */
        PB_CSRankReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSRankReq)
                return object;
            var message = new $root.PB_CSRankReq();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.listBegin != null)
                message.listBegin = object.listBegin | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSRankReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSRankReq
         * @static
         * @param {PB_CSRankReq} message PB_CSRankReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSRankReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.listBegin = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.listBegin != null && message.hasOwnProperty("listBegin"))
                object.listBegin = message.listBegin;
            return object;
        };
    
        /**
         * Converts this PB_CSRankReq to JSON.
         * @function toJSON
         * @memberof PB_CSRankReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSRankReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSRankReq;
    })();
    
    $root.PassCheckFetchInfo = (function() {
    
        /**
         * Properties of a PassCheckFetchInfo.
         * @exports IPassCheckFetchInfo
         * @interface IPassCheckFetchInfo
         * @property {Array.<boolean>|null} [fetchFlag] PassCheckFetchInfo fetchFlag
         */
    
        /**
         * Constructs a new PassCheckFetchInfo.
         * @exports PassCheckFetchInfo
         * @classdesc Represents a PassCheckFetchInfo.
         * @implements IPassCheckFetchInfo
         * @constructor
         * @param {IPassCheckFetchInfo=} [properties] Properties to set
         */
        function PassCheckFetchInfo(properties) {
            this.fetchFlag = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PassCheckFetchInfo fetchFlag.
         * @member {Array.<boolean>} fetchFlag
         * @memberof PassCheckFetchInfo
         * @instance
         */
        PassCheckFetchInfo.prototype.fetchFlag = $util.emptyArray;
    
        /**
         * Creates a new PassCheckFetchInfo instance using the specified properties.
         * @function create
         * @memberof PassCheckFetchInfo
         * @static
         * @param {IPassCheckFetchInfo=} [properties] Properties to set
         * @returns {PassCheckFetchInfo} PassCheckFetchInfo instance
         */
        PassCheckFetchInfo.create = function create(properties) {
            return new PassCheckFetchInfo(properties);
        };
    
        /**
         * Encodes the specified PassCheckFetchInfo message. Does not implicitly {@link PassCheckFetchInfo.verify|verify} messages.
         * @function encode
         * @memberof PassCheckFetchInfo
         * @static
         * @param {IPassCheckFetchInfo} message PassCheckFetchInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PassCheckFetchInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fetchFlag != null && message.fetchFlag.length)
                for (var i = 0; i < message.fetchFlag.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.fetchFlag[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PassCheckFetchInfo message, length delimited. Does not implicitly {@link PassCheckFetchInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PassCheckFetchInfo
         * @static
         * @param {IPassCheckFetchInfo} message PassCheckFetchInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PassCheckFetchInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PassCheckFetchInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PassCheckFetchInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PassCheckFetchInfo} PassCheckFetchInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PassCheckFetchInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PassCheckFetchInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.fetchFlag && message.fetchFlag.length))
                        message.fetchFlag = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.fetchFlag.push(reader.bool());
                    } else
                        message.fetchFlag.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PassCheckFetchInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PassCheckFetchInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PassCheckFetchInfo} PassCheckFetchInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PassCheckFetchInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PassCheckFetchInfo message.
         * @function verify
         * @memberof PassCheckFetchInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PassCheckFetchInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fetchFlag != null && message.hasOwnProperty("fetchFlag")) {
                if (!Array.isArray(message.fetchFlag))
                    return "fetchFlag: array expected";
                for (var i = 0; i < message.fetchFlag.length; ++i)
                    if (typeof message.fetchFlag[i] !== "boolean")
                        return "fetchFlag: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PassCheckFetchInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PassCheckFetchInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PassCheckFetchInfo} PassCheckFetchInfo
         */
        PassCheckFetchInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PassCheckFetchInfo)
                return object;
            var message = new $root.PassCheckFetchInfo();
            if (object.fetchFlag) {
                if (!Array.isArray(object.fetchFlag))
                    throw TypeError(".PassCheckFetchInfo.fetchFlag: array expected");
                message.fetchFlag = [];
                for (var i = 0; i < object.fetchFlag.length; ++i)
                    message.fetchFlag[i] = Boolean(object.fetchFlag[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PassCheckFetchInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PassCheckFetchInfo
         * @static
         * @param {PassCheckFetchInfo} message PassCheckFetchInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PassCheckFetchInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fetchFlag = [];
            if (message.fetchFlag && message.fetchFlag.length) {
                object.fetchFlag = [];
                for (var j = 0; j < message.fetchFlag.length; ++j)
                    object.fetchFlag[j] = message.fetchFlag[j];
            }
            return object;
        };
    
        /**
         * Converts this PassCheckFetchInfo to JSON.
         * @function toJSON
         * @memberof PassCheckFetchInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PassCheckFetchInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PassCheckFetchInfo;
    })();
    
    $root.PB_SCRaPassCheckInfo = (function() {
    
        /**
         * Properties of a PB_SCRaPassCheckInfo.
         * @exports IPB_SCRaPassCheckInfo
         * @interface IPB_SCRaPassCheckInfo
         * @property {number|null} [isActive] PB_SCRaPassCheckInfo isActive
         * @property {number|null} [passCheckLevel] PB_SCRaPassCheckInfo passCheckLevel
         * @property {number|null} [passCheckExp] PB_SCRaPassCheckInfo passCheckExp
         * @property {Array.<IPassCheckFetchInfo>|null} [fetchFlagList] PB_SCRaPassCheckInfo fetchFlagList
         */
    
        /**
         * Constructs a new PB_SCRaPassCheckInfo.
         * @exports PB_SCRaPassCheckInfo
         * @classdesc Represents a PB_SCRaPassCheckInfo.
         * @implements IPB_SCRaPassCheckInfo
         * @constructor
         * @param {IPB_SCRaPassCheckInfo=} [properties] Properties to set
         */
        function PB_SCRaPassCheckInfo(properties) {
            this.fetchFlagList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRaPassCheckInfo isActive.
         * @member {number} isActive
         * @memberof PB_SCRaPassCheckInfo
         * @instance
         */
        PB_SCRaPassCheckInfo.prototype.isActive = 0;
    
        /**
         * PB_SCRaPassCheckInfo passCheckLevel.
         * @member {number} passCheckLevel
         * @memberof PB_SCRaPassCheckInfo
         * @instance
         */
        PB_SCRaPassCheckInfo.prototype.passCheckLevel = 0;
    
        /**
         * PB_SCRaPassCheckInfo passCheckExp.
         * @member {number} passCheckExp
         * @memberof PB_SCRaPassCheckInfo
         * @instance
         */
        PB_SCRaPassCheckInfo.prototype.passCheckExp = 0;
    
        /**
         * PB_SCRaPassCheckInfo fetchFlagList.
         * @member {Array.<IPassCheckFetchInfo>} fetchFlagList
         * @memberof PB_SCRaPassCheckInfo
         * @instance
         */
        PB_SCRaPassCheckInfo.prototype.fetchFlagList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRaPassCheckInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRaPassCheckInfo
         * @static
         * @param {IPB_SCRaPassCheckInfo=} [properties] Properties to set
         * @returns {PB_SCRaPassCheckInfo} PB_SCRaPassCheckInfo instance
         */
        PB_SCRaPassCheckInfo.create = function create(properties) {
            return new PB_SCRaPassCheckInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRaPassCheckInfo message. Does not implicitly {@link PB_SCRaPassCheckInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRaPassCheckInfo
         * @static
         * @param {IPB_SCRaPassCheckInfo} message PB_SCRaPassCheckInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaPassCheckInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isActive != null && Object.hasOwnProperty.call(message, "isActive"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isActive);
            if (message.passCheckLevel != null && Object.hasOwnProperty.call(message, "passCheckLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.passCheckLevel);
            if (message.passCheckExp != null && Object.hasOwnProperty.call(message, "passCheckExp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.passCheckExp);
            if (message.fetchFlagList != null && message.fetchFlagList.length)
                for (var i = 0; i < message.fetchFlagList.length; ++i)
                    $root.PassCheckFetchInfo.encode(message.fetchFlagList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRaPassCheckInfo message, length delimited. Does not implicitly {@link PB_SCRaPassCheckInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRaPassCheckInfo
         * @static
         * @param {IPB_SCRaPassCheckInfo} message PB_SCRaPassCheckInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRaPassCheckInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRaPassCheckInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRaPassCheckInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRaPassCheckInfo} PB_SCRaPassCheckInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaPassCheckInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRaPassCheckInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isActive = reader.int32();
                    break;
                case 2:
                    message.passCheckLevel = reader.int32();
                    break;
                case 3:
                    message.passCheckExp = reader.int32();
                    break;
                case 4:
                    if (!(message.fetchFlagList && message.fetchFlagList.length))
                        message.fetchFlagList = [];
                    message.fetchFlagList.push($root.PassCheckFetchInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRaPassCheckInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRaPassCheckInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRaPassCheckInfo} PB_SCRaPassCheckInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRaPassCheckInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRaPassCheckInfo message.
         * @function verify
         * @memberof PB_SCRaPassCheckInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRaPassCheckInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                if (!$util.isInteger(message.isActive))
                    return "isActive: integer expected";
            if (message.passCheckLevel != null && message.hasOwnProperty("passCheckLevel"))
                if (!$util.isInteger(message.passCheckLevel))
                    return "passCheckLevel: integer expected";
            if (message.passCheckExp != null && message.hasOwnProperty("passCheckExp"))
                if (!$util.isInteger(message.passCheckExp))
                    return "passCheckExp: integer expected";
            if (message.fetchFlagList != null && message.hasOwnProperty("fetchFlagList")) {
                if (!Array.isArray(message.fetchFlagList))
                    return "fetchFlagList: array expected";
                for (var i = 0; i < message.fetchFlagList.length; ++i) {
                    var error = $root.PassCheckFetchInfo.verify(message.fetchFlagList[i]);
                    if (error)
                        return "fetchFlagList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRaPassCheckInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRaPassCheckInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRaPassCheckInfo} PB_SCRaPassCheckInfo
         */
        PB_SCRaPassCheckInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRaPassCheckInfo)
                return object;
            var message = new $root.PB_SCRaPassCheckInfo();
            if (object.isActive != null)
                message.isActive = object.isActive | 0;
            if (object.passCheckLevel != null)
                message.passCheckLevel = object.passCheckLevel | 0;
            if (object.passCheckExp != null)
                message.passCheckExp = object.passCheckExp | 0;
            if (object.fetchFlagList) {
                if (!Array.isArray(object.fetchFlagList))
                    throw TypeError(".PB_SCRaPassCheckInfo.fetchFlagList: array expected");
                message.fetchFlagList = [];
                for (var i = 0; i < object.fetchFlagList.length; ++i) {
                    if (typeof object.fetchFlagList[i] !== "object")
                        throw TypeError(".PB_SCRaPassCheckInfo.fetchFlagList: object expected");
                    message.fetchFlagList[i] = $root.PassCheckFetchInfo.fromObject(object.fetchFlagList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRaPassCheckInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRaPassCheckInfo
         * @static
         * @param {PB_SCRaPassCheckInfo} message PB_SCRaPassCheckInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRaPassCheckInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.fetchFlagList = [];
            if (options.defaults) {
                object.isActive = 0;
                object.passCheckLevel = 0;
                object.passCheckExp = 0;
            }
            if (message.isActive != null && message.hasOwnProperty("isActive"))
                object.isActive = message.isActive;
            if (message.passCheckLevel != null && message.hasOwnProperty("passCheckLevel"))
                object.passCheckLevel = message.passCheckLevel;
            if (message.passCheckExp != null && message.hasOwnProperty("passCheckExp"))
                object.passCheckExp = message.passCheckExp;
            if (message.fetchFlagList && message.fetchFlagList.length) {
                object.fetchFlagList = [];
                for (var j = 0; j < message.fetchFlagList.length; ++j)
                    object.fetchFlagList[j] = $root.PassCheckFetchInfo.toObject(message.fetchFlagList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRaPassCheckInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRaPassCheckInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRaPassCheckInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRaPassCheckInfo;
    })();
    
    $root.PB_CSRoleFishReq = (function() {
    
        /**
         * Properties of a PB_CSRoleFishReq.
         * @exports IPB_CSRoleFishReq
         * @interface IPB_CSRoleFishReq
         * @property {number|null} [reqType] PB_CSRoleFishReq reqType
         * @property {number|null} [p1] PB_CSRoleFishReq p1
         * @property {number|null} [p2] PB_CSRoleFishReq p2
         * @property {number|null} [p3] PB_CSRoleFishReq p3
         */
    
        /**
         * Constructs a new PB_CSRoleFishReq.
         * @exports PB_CSRoleFishReq
         * @classdesc Represents a PB_CSRoleFishReq.
         * @implements IPB_CSRoleFishReq
         * @constructor
         * @param {IPB_CSRoleFishReq=} [properties] Properties to set
         */
        function PB_CSRoleFishReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSRoleFishReq reqType.
         * @member {number} reqType
         * @memberof PB_CSRoleFishReq
         * @instance
         */
        PB_CSRoleFishReq.prototype.reqType = 0;
    
        /**
         * PB_CSRoleFishReq p1.
         * @member {number} p1
         * @memberof PB_CSRoleFishReq
         * @instance
         */
        PB_CSRoleFishReq.prototype.p1 = 0;
    
        /**
         * PB_CSRoleFishReq p2.
         * @member {number} p2
         * @memberof PB_CSRoleFishReq
         * @instance
         */
        PB_CSRoleFishReq.prototype.p2 = 0;
    
        /**
         * PB_CSRoleFishReq p3.
         * @member {number} p3
         * @memberof PB_CSRoleFishReq
         * @instance
         */
        PB_CSRoleFishReq.prototype.p3 = 0;
    
        /**
         * Creates a new PB_CSRoleFishReq instance using the specified properties.
         * @function create
         * @memberof PB_CSRoleFishReq
         * @static
         * @param {IPB_CSRoleFishReq=} [properties] Properties to set
         * @returns {PB_CSRoleFishReq} PB_CSRoleFishReq instance
         */
        PB_CSRoleFishReq.create = function create(properties) {
            return new PB_CSRoleFishReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSRoleFishReq message. Does not implicitly {@link PB_CSRoleFishReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSRoleFishReq
         * @static
         * @param {IPB_CSRoleFishReq} message PB_CSRoleFishReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleFishReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.p1);
            if (message.p2 != null && Object.hasOwnProperty.call(message, "p2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.p2);
            if (message.p3 != null && Object.hasOwnProperty.call(message, "p3"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.p3);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSRoleFishReq message, length delimited. Does not implicitly {@link PB_CSRoleFishReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSRoleFishReq
         * @static
         * @param {IPB_CSRoleFishReq} message PB_CSRoleFishReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSRoleFishReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSRoleFishReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSRoleFishReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSRoleFishReq} PB_CSRoleFishReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleFishReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSRoleFishReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    message.p1 = reader.int32();
                    break;
                case 3:
                    message.p2 = reader.int32();
                    break;
                case 4:
                    message.p3 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSRoleFishReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSRoleFishReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSRoleFishReq} PB_CSRoleFishReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSRoleFishReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSRoleFishReq message.
         * @function verify
         * @memberof PB_CSRoleFishReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSRoleFishReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.p1 != null && message.hasOwnProperty("p1"))
                if (!$util.isInteger(message.p1))
                    return "p1: integer expected";
            if (message.p2 != null && message.hasOwnProperty("p2"))
                if (!$util.isInteger(message.p2))
                    return "p2: integer expected";
            if (message.p3 != null && message.hasOwnProperty("p3"))
                if (!$util.isInteger(message.p3))
                    return "p3: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSRoleFishReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSRoleFishReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSRoleFishReq} PB_CSRoleFishReq
         */
        PB_CSRoleFishReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSRoleFishReq)
                return object;
            var message = new $root.PB_CSRoleFishReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.p1 != null)
                message.p1 = object.p1 | 0;
            if (object.p2 != null)
                message.p2 = object.p2 | 0;
            if (object.p3 != null)
                message.p3 = object.p3 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSRoleFishReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSRoleFishReq
         * @static
         * @param {PB_CSRoleFishReq} message PB_CSRoleFishReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSRoleFishReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reqType = 0;
                object.p1 = 0;
                object.p2 = 0;
                object.p3 = 0;
            }
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = message.p1;
            if (message.p2 != null && message.hasOwnProperty("p2"))
                object.p2 = message.p2;
            if (message.p3 != null && message.hasOwnProperty("p3"))
                object.p3 = message.p3;
            return object;
        };
    
        /**
         * Converts this PB_CSRoleFishReq to JSON.
         * @function toJSON
         * @memberof PB_CSRoleFishReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSRoleFishReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSRoleFishReq;
    })();
    
    $root.PB_RoleFishFish = (function() {
    
        /**
         * Properties of a PB_RoleFishFish.
         * @exports IPB_RoleFishFish
         * @interface IPB_RoleFishFish
         * @property {number|null} [fishId] PB_RoleFishFish fishId
         * @property {number|null} [fishLen] PB_RoleFishFish fishLen
         */
    
        /**
         * Constructs a new PB_RoleFishFish.
         * @exports PB_RoleFishFish
         * @classdesc Represents a PB_RoleFishFish.
         * @implements IPB_RoleFishFish
         * @constructor
         * @param {IPB_RoleFishFish=} [properties] Properties to set
         */
        function PB_RoleFishFish(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RoleFishFish fishId.
         * @member {number} fishId
         * @memberof PB_RoleFishFish
         * @instance
         */
        PB_RoleFishFish.prototype.fishId = 0;
    
        /**
         * PB_RoleFishFish fishLen.
         * @member {number} fishLen
         * @memberof PB_RoleFishFish
         * @instance
         */
        PB_RoleFishFish.prototype.fishLen = 0;
    
        /**
         * Creates a new PB_RoleFishFish instance using the specified properties.
         * @function create
         * @memberof PB_RoleFishFish
         * @static
         * @param {IPB_RoleFishFish=} [properties] Properties to set
         * @returns {PB_RoleFishFish} PB_RoleFishFish instance
         */
        PB_RoleFishFish.create = function create(properties) {
            return new PB_RoleFishFish(properties);
        };
    
        /**
         * Encodes the specified PB_RoleFishFish message. Does not implicitly {@link PB_RoleFishFish.verify|verify} messages.
         * @function encode
         * @memberof PB_RoleFishFish
         * @static
         * @param {IPB_RoleFishFish} message PB_RoleFishFish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleFishFish.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fishId != null && Object.hasOwnProperty.call(message, "fishId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fishId);
            if (message.fishLen != null && Object.hasOwnProperty.call(message, "fishLen"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fishLen);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RoleFishFish message, length delimited. Does not implicitly {@link PB_RoleFishFish.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RoleFishFish
         * @static
         * @param {IPB_RoleFishFish} message PB_RoleFishFish message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleFishFish.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RoleFishFish message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RoleFishFish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RoleFishFish} PB_RoleFishFish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleFishFish.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RoleFishFish();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fishId = reader.int32();
                    break;
                case 2:
                    message.fishLen = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RoleFishFish message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RoleFishFish
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RoleFishFish} PB_RoleFishFish
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleFishFish.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RoleFishFish message.
         * @function verify
         * @memberof PB_RoleFishFish
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RoleFishFish.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fishId != null && message.hasOwnProperty("fishId"))
                if (!$util.isInteger(message.fishId))
                    return "fishId: integer expected";
            if (message.fishLen != null && message.hasOwnProperty("fishLen"))
                if (!$util.isInteger(message.fishLen))
                    return "fishLen: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_RoleFishFish message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RoleFishFish
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RoleFishFish} PB_RoleFishFish
         */
        PB_RoleFishFish.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RoleFishFish)
                return object;
            var message = new $root.PB_RoleFishFish();
            if (object.fishId != null)
                message.fishId = object.fishId | 0;
            if (object.fishLen != null)
                message.fishLen = object.fishLen | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RoleFishFish message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RoleFishFish
         * @static
         * @param {PB_RoleFishFish} message PB_RoleFishFish
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RoleFishFish.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fishId = 0;
                object.fishLen = 0;
            }
            if (message.fishId != null && message.hasOwnProperty("fishId"))
                object.fishId = message.fishId;
            if (message.fishLen != null && message.hasOwnProperty("fishLen"))
                object.fishLen = message.fishLen;
            return object;
        };
    
        /**
         * Converts this PB_RoleFishFish to JSON.
         * @function toJSON
         * @memberof PB_RoleFishFish
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RoleFishFish.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RoleFishFish;
    })();
    
    $root.PB_RoleFishTaskInfo = (function() {
    
        /**
         * Properties of a PB_RoleFishTaskInfo.
         * @exports IPB_RoleFishTaskInfo
         * @interface IPB_RoleFishTaskInfo
         * @property {number|null} [taskId] PB_RoleFishTaskInfo taskId
         * @property {number|null} [processNum] PB_RoleFishTaskInfo processNum
         * @property {number|null} [isFetch] PB_RoleFishTaskInfo isFetch
         */
    
        /**
         * Constructs a new PB_RoleFishTaskInfo.
         * @exports PB_RoleFishTaskInfo
         * @classdesc Represents a PB_RoleFishTaskInfo.
         * @implements IPB_RoleFishTaskInfo
         * @constructor
         * @param {IPB_RoleFishTaskInfo=} [properties] Properties to set
         */
        function PB_RoleFishTaskInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RoleFishTaskInfo taskId.
         * @member {number} taskId
         * @memberof PB_RoleFishTaskInfo
         * @instance
         */
        PB_RoleFishTaskInfo.prototype.taskId = 0;
    
        /**
         * PB_RoleFishTaskInfo processNum.
         * @member {number} processNum
         * @memberof PB_RoleFishTaskInfo
         * @instance
         */
        PB_RoleFishTaskInfo.prototype.processNum = 0;
    
        /**
         * PB_RoleFishTaskInfo isFetch.
         * @member {number} isFetch
         * @memberof PB_RoleFishTaskInfo
         * @instance
         */
        PB_RoleFishTaskInfo.prototype.isFetch = 0;
    
        /**
         * Creates a new PB_RoleFishTaskInfo instance using the specified properties.
         * @function create
         * @memberof PB_RoleFishTaskInfo
         * @static
         * @param {IPB_RoleFishTaskInfo=} [properties] Properties to set
         * @returns {PB_RoleFishTaskInfo} PB_RoleFishTaskInfo instance
         */
        PB_RoleFishTaskInfo.create = function create(properties) {
            return new PB_RoleFishTaskInfo(properties);
        };
    
        /**
         * Encodes the specified PB_RoleFishTaskInfo message. Does not implicitly {@link PB_RoleFishTaskInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_RoleFishTaskInfo
         * @static
         * @param {IPB_RoleFishTaskInfo} message PB_RoleFishTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleFishTaskInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
            if (message.processNum != null && Object.hasOwnProperty.call(message, "processNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.processNum);
            if (message.isFetch != null && Object.hasOwnProperty.call(message, "isFetch"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isFetch);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RoleFishTaskInfo message, length delimited. Does not implicitly {@link PB_RoleFishTaskInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RoleFishTaskInfo
         * @static
         * @param {IPB_RoleFishTaskInfo} message PB_RoleFishTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleFishTaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RoleFishTaskInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RoleFishTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RoleFishTaskInfo} PB_RoleFishTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleFishTaskInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RoleFishTaskInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskId = reader.int32();
                    break;
                case 2:
                    message.processNum = reader.int32();
                    break;
                case 3:
                    message.isFetch = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RoleFishTaskInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RoleFishTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RoleFishTaskInfo} PB_RoleFishTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleFishTaskInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RoleFishTaskInfo message.
         * @function verify
         * @memberof PB_RoleFishTaskInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RoleFishTaskInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                if (!$util.isInteger(message.taskId))
                    return "taskId: integer expected";
            if (message.processNum != null && message.hasOwnProperty("processNum"))
                if (!$util.isInteger(message.processNum))
                    return "processNum: integer expected";
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                if (!$util.isInteger(message.isFetch))
                    return "isFetch: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_RoleFishTaskInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RoleFishTaskInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RoleFishTaskInfo} PB_RoleFishTaskInfo
         */
        PB_RoleFishTaskInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RoleFishTaskInfo)
                return object;
            var message = new $root.PB_RoleFishTaskInfo();
            if (object.taskId != null)
                message.taskId = object.taskId | 0;
            if (object.processNum != null)
                message.processNum = object.processNum | 0;
            if (object.isFetch != null)
                message.isFetch = object.isFetch | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RoleFishTaskInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RoleFishTaskInfo
         * @static
         * @param {PB_RoleFishTaskInfo} message PB_RoleFishTaskInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RoleFishTaskInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.taskId = 0;
                object.processNum = 0;
                object.isFetch = 0;
            }
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                object.taskId = message.taskId;
            if (message.processNum != null && message.hasOwnProperty("processNum"))
                object.processNum = message.processNum;
            if (message.isFetch != null && message.hasOwnProperty("isFetch"))
                object.isFetch = message.isFetch;
            return object;
        };
    
        /**
         * Converts this PB_RoleFishTaskInfo to JSON.
         * @function toJSON
         * @memberof PB_RoleFishTaskInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RoleFishTaskInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RoleFishTaskInfo;
    })();
    
    $root.PB_RoleFishToolInfo = (function() {
    
        /**
         * Properties of a PB_RoleFishToolInfo.
         * @exports IPB_RoleFishToolInfo
         * @interface IPB_RoleFishToolInfo
         * @property {number|null} [level] PB_RoleFishToolInfo level
         * @property {number|null} [huanHuaId] PB_RoleFishToolInfo huanHuaId
         */
    
        /**
         * Constructs a new PB_RoleFishToolInfo.
         * @exports PB_RoleFishToolInfo
         * @classdesc Represents a PB_RoleFishToolInfo.
         * @implements IPB_RoleFishToolInfo
         * @constructor
         * @param {IPB_RoleFishToolInfo=} [properties] Properties to set
         */
        function PB_RoleFishToolInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RoleFishToolInfo level.
         * @member {number} level
         * @memberof PB_RoleFishToolInfo
         * @instance
         */
        PB_RoleFishToolInfo.prototype.level = 0;
    
        /**
         * PB_RoleFishToolInfo huanHuaId.
         * @member {number} huanHuaId
         * @memberof PB_RoleFishToolInfo
         * @instance
         */
        PB_RoleFishToolInfo.prototype.huanHuaId = 0;
    
        /**
         * Creates a new PB_RoleFishToolInfo instance using the specified properties.
         * @function create
         * @memberof PB_RoleFishToolInfo
         * @static
         * @param {IPB_RoleFishToolInfo=} [properties] Properties to set
         * @returns {PB_RoleFishToolInfo} PB_RoleFishToolInfo instance
         */
        PB_RoleFishToolInfo.create = function create(properties) {
            return new PB_RoleFishToolInfo(properties);
        };
    
        /**
         * Encodes the specified PB_RoleFishToolInfo message. Does not implicitly {@link PB_RoleFishToolInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_RoleFishToolInfo
         * @static
         * @param {IPB_RoleFishToolInfo} message PB_RoleFishToolInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleFishToolInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
            if (message.huanHuaId != null && Object.hasOwnProperty.call(message, "huanHuaId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.huanHuaId);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RoleFishToolInfo message, length delimited. Does not implicitly {@link PB_RoleFishToolInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RoleFishToolInfo
         * @static
         * @param {IPB_RoleFishToolInfo} message PB_RoleFishToolInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleFishToolInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RoleFishToolInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RoleFishToolInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RoleFishToolInfo} PB_RoleFishToolInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleFishToolInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RoleFishToolInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.level = reader.int32();
                    break;
                case 2:
                    message.huanHuaId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RoleFishToolInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RoleFishToolInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RoleFishToolInfo} PB_RoleFishToolInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleFishToolInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RoleFishToolInfo message.
         * @function verify
         * @memberof PB_RoleFishToolInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RoleFishToolInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.huanHuaId != null && message.hasOwnProperty("huanHuaId"))
                if (!$util.isInteger(message.huanHuaId))
                    return "huanHuaId: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_RoleFishToolInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RoleFishToolInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RoleFishToolInfo} PB_RoleFishToolInfo
         */
        PB_RoleFishToolInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RoleFishToolInfo)
                return object;
            var message = new $root.PB_RoleFishToolInfo();
            if (object.level != null)
                message.level = object.level | 0;
            if (object.huanHuaId != null)
                message.huanHuaId = object.huanHuaId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RoleFishToolInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RoleFishToolInfo
         * @static
         * @param {PB_RoleFishToolInfo} message PB_RoleFishToolInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RoleFishToolInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.level = 0;
                object.huanHuaId = 0;
            }
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.huanHuaId != null && message.hasOwnProperty("huanHuaId"))
                object.huanHuaId = message.huanHuaId;
            return object;
        };
    
        /**
         * Converts this PB_RoleFishToolInfo to JSON.
         * @function toJSON
         * @memberof PB_RoleFishToolInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RoleFishToolInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RoleFishToolInfo;
    })();
    
    $root.PB_RoleFishHistoryInfo = (function() {
    
        /**
         * Properties of a PB_RoleFishHistoryInfo.
         * @exports IPB_RoleFishHistoryInfo
         * @interface IPB_RoleFishHistoryInfo
         * @property {number|null} [fishHistoryLen] PB_RoleFishHistoryInfo fishHistoryLen
         */
    
        /**
         * Constructs a new PB_RoleFishHistoryInfo.
         * @exports PB_RoleFishHistoryInfo
         * @classdesc Represents a PB_RoleFishHistoryInfo.
         * @implements IPB_RoleFishHistoryInfo
         * @constructor
         * @param {IPB_RoleFishHistoryInfo=} [properties] Properties to set
         */
        function PB_RoleFishHistoryInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_RoleFishHistoryInfo fishHistoryLen.
         * @member {number} fishHistoryLen
         * @memberof PB_RoleFishHistoryInfo
         * @instance
         */
        PB_RoleFishHistoryInfo.prototype.fishHistoryLen = 0;
    
        /**
         * Creates a new PB_RoleFishHistoryInfo instance using the specified properties.
         * @function create
         * @memberof PB_RoleFishHistoryInfo
         * @static
         * @param {IPB_RoleFishHistoryInfo=} [properties] Properties to set
         * @returns {PB_RoleFishHistoryInfo} PB_RoleFishHistoryInfo instance
         */
        PB_RoleFishHistoryInfo.create = function create(properties) {
            return new PB_RoleFishHistoryInfo(properties);
        };
    
        /**
         * Encodes the specified PB_RoleFishHistoryInfo message. Does not implicitly {@link PB_RoleFishHistoryInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_RoleFishHistoryInfo
         * @static
         * @param {IPB_RoleFishHistoryInfo} message PB_RoleFishHistoryInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleFishHistoryInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fishHistoryLen != null && Object.hasOwnProperty.call(message, "fishHistoryLen"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fishHistoryLen);
            return writer;
        };
    
        /**
         * Encodes the specified PB_RoleFishHistoryInfo message, length delimited. Does not implicitly {@link PB_RoleFishHistoryInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_RoleFishHistoryInfo
         * @static
         * @param {IPB_RoleFishHistoryInfo} message PB_RoleFishHistoryInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_RoleFishHistoryInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_RoleFishHistoryInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_RoleFishHistoryInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_RoleFishHistoryInfo} PB_RoleFishHistoryInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleFishHistoryInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_RoleFishHistoryInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fishHistoryLen = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_RoleFishHistoryInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_RoleFishHistoryInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_RoleFishHistoryInfo} PB_RoleFishHistoryInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_RoleFishHistoryInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_RoleFishHistoryInfo message.
         * @function verify
         * @memberof PB_RoleFishHistoryInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_RoleFishHistoryInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fishHistoryLen != null && message.hasOwnProperty("fishHistoryLen"))
                if (!$util.isInteger(message.fishHistoryLen))
                    return "fishHistoryLen: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_RoleFishHistoryInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_RoleFishHistoryInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_RoleFishHistoryInfo} PB_RoleFishHistoryInfo
         */
        PB_RoleFishHistoryInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_RoleFishHistoryInfo)
                return object;
            var message = new $root.PB_RoleFishHistoryInfo();
            if (object.fishHistoryLen != null)
                message.fishHistoryLen = object.fishHistoryLen | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_RoleFishHistoryInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_RoleFishHistoryInfo
         * @static
         * @param {PB_RoleFishHistoryInfo} message PB_RoleFishHistoryInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_RoleFishHistoryInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.fishHistoryLen = 0;
            if (message.fishHistoryLen != null && message.hasOwnProperty("fishHistoryLen"))
                object.fishHistoryLen = message.fishHistoryLen;
            return object;
        };
    
        /**
         * Converts this PB_RoleFishHistoryInfo to JSON.
         * @function toJSON
         * @memberof PB_RoleFishHistoryInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_RoleFishHistoryInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_RoleFishHistoryInfo;
    })();
    
    $root.PB_SCRoleFishInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishInfo.
         * @exports IPB_SCRoleFishInfo
         * @interface IPB_SCRoleFishInfo
         * @property {number|null} [power] PB_SCRoleFishInfo power
         * @property {number|null} [nextPowerTime] PB_SCRoleFishInfo nextPowerTime
         * @property {number|null} [level] PB_SCRoleFishInfo level
         * @property {number|null} [exp] PB_SCRoleFishInfo exp
         * @property {number|Long|null} [huanHuaActiveFlag] PB_SCRoleFishInfo huanHuaActiveFlag
         * @property {Array.<number>|null} [buyTimes] PB_SCRoleFishInfo buyTimes
         * @property {Array.<boolean>|null} [bookRewardFetchFlag] PB_SCRoleFishInfo bookRewardFetchFlag
         * @property {IPB_RoleFishFish|null} [fish] PB_SCRoleFishInfo fish
         * @property {Array.<IPB_RoleFishFish>|null} [fishList] PB_SCRoleFishInfo fishList
         * @property {Array.<IPB_RoleFishTaskInfo>|null} [taskInfo] PB_SCRoleFishInfo taskInfo
         * @property {Array.<IPB_RoleFishToolInfo>|null} [toolInfo] PB_SCRoleFishInfo toolInfo
         * @property {Array.<IPB_RoleFishHistoryInfo>|null} [historyInfo] PB_SCRoleFishInfo historyInfo
         * @property {number|null} [fishCardTime] PB_SCRoleFishInfo fishCardTime
         * @property {number|null} [isFetchCardReward] PB_SCRoleFishInfo isFetchCardReward
         * @property {number|null} [areaId] PB_SCRoleFishInfo areaId
         * @property {number|null} [baitId] PB_SCRoleFishInfo baitId
         */
    
        /**
         * Constructs a new PB_SCRoleFishInfo.
         * @exports PB_SCRoleFishInfo
         * @classdesc Represents a PB_SCRoleFishInfo.
         * @implements IPB_SCRoleFishInfo
         * @constructor
         * @param {IPB_SCRoleFishInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishInfo(properties) {
            this.buyTimes = [];
            this.bookRewardFetchFlag = [];
            this.fishList = [];
            this.taskInfo = [];
            this.toolInfo = [];
            this.historyInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishInfo power.
         * @member {number} power
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.power = 0;
    
        /**
         * PB_SCRoleFishInfo nextPowerTime.
         * @member {number} nextPowerTime
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.nextPowerTime = 0;
    
        /**
         * PB_SCRoleFishInfo level.
         * @member {number} level
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.level = 0;
    
        /**
         * PB_SCRoleFishInfo exp.
         * @member {number} exp
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.exp = 0;
    
        /**
         * PB_SCRoleFishInfo huanHuaActiveFlag.
         * @member {number|Long} huanHuaActiveFlag
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.huanHuaActiveFlag = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * PB_SCRoleFishInfo buyTimes.
         * @member {Array.<number>} buyTimes
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.buyTimes = $util.emptyArray;
    
        /**
         * PB_SCRoleFishInfo bookRewardFetchFlag.
         * @member {Array.<boolean>} bookRewardFetchFlag
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.bookRewardFetchFlag = $util.emptyArray;
    
        /**
         * PB_SCRoleFishInfo fish.
         * @member {IPB_RoleFishFish|null|undefined} fish
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.fish = null;
    
        /**
         * PB_SCRoleFishInfo fishList.
         * @member {Array.<IPB_RoleFishFish>} fishList
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.fishList = $util.emptyArray;
    
        /**
         * PB_SCRoleFishInfo taskInfo.
         * @member {Array.<IPB_RoleFishTaskInfo>} taskInfo
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.taskInfo = $util.emptyArray;
    
        /**
         * PB_SCRoleFishInfo toolInfo.
         * @member {Array.<IPB_RoleFishToolInfo>} toolInfo
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.toolInfo = $util.emptyArray;
    
        /**
         * PB_SCRoleFishInfo historyInfo.
         * @member {Array.<IPB_RoleFishHistoryInfo>} historyInfo
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.historyInfo = $util.emptyArray;
    
        /**
         * PB_SCRoleFishInfo fishCardTime.
         * @member {number} fishCardTime
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.fishCardTime = 0;
    
        /**
         * PB_SCRoleFishInfo isFetchCardReward.
         * @member {number} isFetchCardReward
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.isFetchCardReward = 0;
    
        /**
         * PB_SCRoleFishInfo areaId.
         * @member {number} areaId
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.areaId = 0;
    
        /**
         * PB_SCRoleFishInfo baitId.
         * @member {number} baitId
         * @memberof PB_SCRoleFishInfo
         * @instance
         */
        PB_SCRoleFishInfo.prototype.baitId = 0;
    
        /**
         * Creates a new PB_SCRoleFishInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishInfo
         * @static
         * @param {IPB_SCRoleFishInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishInfo} PB_SCRoleFishInfo instance
         */
        PB_SCRoleFishInfo.create = function create(properties) {
            return new PB_SCRoleFishInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishInfo message. Does not implicitly {@link PB_SCRoleFishInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishInfo
         * @static
         * @param {IPB_SCRoleFishInfo} message PB_SCRoleFishInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.power);
            if (message.nextPowerTime != null && Object.hasOwnProperty.call(message, "nextPowerTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nextPowerTime);
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.exp);
            if (message.huanHuaActiveFlag != null && Object.hasOwnProperty.call(message, "huanHuaActiveFlag"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.huanHuaActiveFlag);
            if (message.buyTimes != null && message.buyTimes.length)
                for (var i = 0; i < message.buyTimes.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.buyTimes[i]);
            if (message.bookRewardFetchFlag != null && message.bookRewardFetchFlag.length)
                for (var i = 0; i < message.bookRewardFetchFlag.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.bookRewardFetchFlag[i]);
            if (message.fish != null && Object.hasOwnProperty.call(message, "fish"))
                $root.PB_RoleFishFish.encode(message.fish, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.fishList != null && message.fishList.length)
                for (var i = 0; i < message.fishList.length; ++i)
                    $root.PB_RoleFishFish.encode(message.fishList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.taskInfo != null && message.taskInfo.length)
                for (var i = 0; i < message.taskInfo.length; ++i)
                    $root.PB_RoleFishTaskInfo.encode(message.taskInfo[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.toolInfo != null && message.toolInfo.length)
                for (var i = 0; i < message.toolInfo.length; ++i)
                    $root.PB_RoleFishToolInfo.encode(message.toolInfo[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.historyInfo != null && message.historyInfo.length)
                for (var i = 0; i < message.historyInfo.length; ++i)
                    $root.PB_RoleFishHistoryInfo.encode(message.historyInfo[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.fishCardTime != null && Object.hasOwnProperty.call(message, "fishCardTime"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.fishCardTime);
            if (message.isFetchCardReward != null && Object.hasOwnProperty.call(message, "isFetchCardReward"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.isFetchCardReward);
            if (message.areaId != null && Object.hasOwnProperty.call(message, "areaId"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.areaId);
            if (message.baitId != null && Object.hasOwnProperty.call(message, "baitId"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.baitId);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishInfo
         * @static
         * @param {IPB_SCRoleFishInfo} message PB_SCRoleFishInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishInfo} PB_SCRoleFishInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.power = reader.int32();
                    break;
                case 2:
                    message.nextPowerTime = reader.int32();
                    break;
                case 3:
                    message.level = reader.int32();
                    break;
                case 4:
                    message.exp = reader.int32();
                    break;
                case 5:
                    message.huanHuaActiveFlag = reader.uint64();
                    break;
                case 6:
                    if (!(message.buyTimes && message.buyTimes.length))
                        message.buyTimes = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.buyTimes.push(reader.int32());
                    } else
                        message.buyTimes.push(reader.int32());
                    break;
                case 7:
                    if (!(message.bookRewardFetchFlag && message.bookRewardFetchFlag.length))
                        message.bookRewardFetchFlag = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bookRewardFetchFlag.push(reader.bool());
                    } else
                        message.bookRewardFetchFlag.push(reader.bool());
                    break;
                case 8:
                    message.fish = $root.PB_RoleFishFish.decode(reader, reader.uint32());
                    break;
                case 9:
                    if (!(message.fishList && message.fishList.length))
                        message.fishList = [];
                    message.fishList.push($root.PB_RoleFishFish.decode(reader, reader.uint32()));
                    break;
                case 10:
                    if (!(message.taskInfo && message.taskInfo.length))
                        message.taskInfo = [];
                    message.taskInfo.push($root.PB_RoleFishTaskInfo.decode(reader, reader.uint32()));
                    break;
                case 11:
                    if (!(message.toolInfo && message.toolInfo.length))
                        message.toolInfo = [];
                    message.toolInfo.push($root.PB_RoleFishToolInfo.decode(reader, reader.uint32()));
                    break;
                case 12:
                    if (!(message.historyInfo && message.historyInfo.length))
                        message.historyInfo = [];
                    message.historyInfo.push($root.PB_RoleFishHistoryInfo.decode(reader, reader.uint32()));
                    break;
                case 13:
                    message.fishCardTime = reader.uint32();
                    break;
                case 14:
                    message.isFetchCardReward = reader.int32();
                    break;
                case 15:
                    message.areaId = reader.int32();
                    break;
                case 16:
                    message.baitId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishInfo} PB_SCRoleFishInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishInfo message.
         * @function verify
         * @memberof PB_SCRoleFishInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power))
                    return "power: integer expected";
            if (message.nextPowerTime != null && message.hasOwnProperty("nextPowerTime"))
                if (!$util.isInteger(message.nextPowerTime))
                    return "nextPowerTime: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
            if (message.huanHuaActiveFlag != null && message.hasOwnProperty("huanHuaActiveFlag"))
                if (!$util.isInteger(message.huanHuaActiveFlag) && !(message.huanHuaActiveFlag && $util.isInteger(message.huanHuaActiveFlag.low) && $util.isInteger(message.huanHuaActiveFlag.high)))
                    return "huanHuaActiveFlag: integer|Long expected";
            if (message.buyTimes != null && message.hasOwnProperty("buyTimes")) {
                if (!Array.isArray(message.buyTimes))
                    return "buyTimes: array expected";
                for (var i = 0; i < message.buyTimes.length; ++i)
                    if (!$util.isInteger(message.buyTimes[i]))
                        return "buyTimes: integer[] expected";
            }
            if (message.bookRewardFetchFlag != null && message.hasOwnProperty("bookRewardFetchFlag")) {
                if (!Array.isArray(message.bookRewardFetchFlag))
                    return "bookRewardFetchFlag: array expected";
                for (var i = 0; i < message.bookRewardFetchFlag.length; ++i)
                    if (typeof message.bookRewardFetchFlag[i] !== "boolean")
                        return "bookRewardFetchFlag: boolean[] expected";
            }
            if (message.fish != null && message.hasOwnProperty("fish")) {
                var error = $root.PB_RoleFishFish.verify(message.fish);
                if (error)
                    return "fish." + error;
            }
            if (message.fishList != null && message.hasOwnProperty("fishList")) {
                if (!Array.isArray(message.fishList))
                    return "fishList: array expected";
                for (var i = 0; i < message.fishList.length; ++i) {
                    var error = $root.PB_RoleFishFish.verify(message.fishList[i]);
                    if (error)
                        return "fishList." + error;
                }
            }
            if (message.taskInfo != null && message.hasOwnProperty("taskInfo")) {
                if (!Array.isArray(message.taskInfo))
                    return "taskInfo: array expected";
                for (var i = 0; i < message.taskInfo.length; ++i) {
                    var error = $root.PB_RoleFishTaskInfo.verify(message.taskInfo[i]);
                    if (error)
                        return "taskInfo." + error;
                }
            }
            if (message.toolInfo != null && message.hasOwnProperty("toolInfo")) {
                if (!Array.isArray(message.toolInfo))
                    return "toolInfo: array expected";
                for (var i = 0; i < message.toolInfo.length; ++i) {
                    var error = $root.PB_RoleFishToolInfo.verify(message.toolInfo[i]);
                    if (error)
                        return "toolInfo." + error;
                }
            }
            if (message.historyInfo != null && message.hasOwnProperty("historyInfo")) {
                if (!Array.isArray(message.historyInfo))
                    return "historyInfo: array expected";
                for (var i = 0; i < message.historyInfo.length; ++i) {
                    var error = $root.PB_RoleFishHistoryInfo.verify(message.historyInfo[i]);
                    if (error)
                        return "historyInfo." + error;
                }
            }
            if (message.fishCardTime != null && message.hasOwnProperty("fishCardTime"))
                if (!$util.isInteger(message.fishCardTime))
                    return "fishCardTime: integer expected";
            if (message.isFetchCardReward != null && message.hasOwnProperty("isFetchCardReward"))
                if (!$util.isInteger(message.isFetchCardReward))
                    return "isFetchCardReward: integer expected";
            if (message.areaId != null && message.hasOwnProperty("areaId"))
                if (!$util.isInteger(message.areaId))
                    return "areaId: integer expected";
            if (message.baitId != null && message.hasOwnProperty("baitId"))
                if (!$util.isInteger(message.baitId))
                    return "baitId: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishInfo} PB_SCRoleFishInfo
         */
        PB_SCRoleFishInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishInfo)
                return object;
            var message = new $root.PB_SCRoleFishInfo();
            if (object.power != null)
                message.power = object.power | 0;
            if (object.nextPowerTime != null)
                message.nextPowerTime = object.nextPowerTime | 0;
            if (object.level != null)
                message.level = object.level | 0;
            if (object.exp != null)
                message.exp = object.exp | 0;
            if (object.huanHuaActiveFlag != null)
                if ($util.Long)
                    (message.huanHuaActiveFlag = $util.Long.fromValue(object.huanHuaActiveFlag)).unsigned = true;
                else if (typeof object.huanHuaActiveFlag === "string")
                    message.huanHuaActiveFlag = parseInt(object.huanHuaActiveFlag, 10);
                else if (typeof object.huanHuaActiveFlag === "number")
                    message.huanHuaActiveFlag = object.huanHuaActiveFlag;
                else if (typeof object.huanHuaActiveFlag === "object")
                    message.huanHuaActiveFlag = new $util.LongBits(object.huanHuaActiveFlag.low >>> 0, object.huanHuaActiveFlag.high >>> 0).toNumber(true);
            if (object.buyTimes) {
                if (!Array.isArray(object.buyTimes))
                    throw TypeError(".PB_SCRoleFishInfo.buyTimes: array expected");
                message.buyTimes = [];
                for (var i = 0; i < object.buyTimes.length; ++i)
                    message.buyTimes[i] = object.buyTimes[i] | 0;
            }
            if (object.bookRewardFetchFlag) {
                if (!Array.isArray(object.bookRewardFetchFlag))
                    throw TypeError(".PB_SCRoleFishInfo.bookRewardFetchFlag: array expected");
                message.bookRewardFetchFlag = [];
                for (var i = 0; i < object.bookRewardFetchFlag.length; ++i)
                    message.bookRewardFetchFlag[i] = Boolean(object.bookRewardFetchFlag[i]);
            }
            if (object.fish != null) {
                if (typeof object.fish !== "object")
                    throw TypeError(".PB_SCRoleFishInfo.fish: object expected");
                message.fish = $root.PB_RoleFishFish.fromObject(object.fish);
            }
            if (object.fishList) {
                if (!Array.isArray(object.fishList))
                    throw TypeError(".PB_SCRoleFishInfo.fishList: array expected");
                message.fishList = [];
                for (var i = 0; i < object.fishList.length; ++i) {
                    if (typeof object.fishList[i] !== "object")
                        throw TypeError(".PB_SCRoleFishInfo.fishList: object expected");
                    message.fishList[i] = $root.PB_RoleFishFish.fromObject(object.fishList[i]);
                }
            }
            if (object.taskInfo) {
                if (!Array.isArray(object.taskInfo))
                    throw TypeError(".PB_SCRoleFishInfo.taskInfo: array expected");
                message.taskInfo = [];
                for (var i = 0; i < object.taskInfo.length; ++i) {
                    if (typeof object.taskInfo[i] !== "object")
                        throw TypeError(".PB_SCRoleFishInfo.taskInfo: object expected");
                    message.taskInfo[i] = $root.PB_RoleFishTaskInfo.fromObject(object.taskInfo[i]);
                }
            }
            if (object.toolInfo) {
                if (!Array.isArray(object.toolInfo))
                    throw TypeError(".PB_SCRoleFishInfo.toolInfo: array expected");
                message.toolInfo = [];
                for (var i = 0; i < object.toolInfo.length; ++i) {
                    if (typeof object.toolInfo[i] !== "object")
                        throw TypeError(".PB_SCRoleFishInfo.toolInfo: object expected");
                    message.toolInfo[i] = $root.PB_RoleFishToolInfo.fromObject(object.toolInfo[i]);
                }
            }
            if (object.historyInfo) {
                if (!Array.isArray(object.historyInfo))
                    throw TypeError(".PB_SCRoleFishInfo.historyInfo: array expected");
                message.historyInfo = [];
                for (var i = 0; i < object.historyInfo.length; ++i) {
                    if (typeof object.historyInfo[i] !== "object")
                        throw TypeError(".PB_SCRoleFishInfo.historyInfo: object expected");
                    message.historyInfo[i] = $root.PB_RoleFishHistoryInfo.fromObject(object.historyInfo[i]);
                }
            }
            if (object.fishCardTime != null)
                message.fishCardTime = object.fishCardTime >>> 0;
            if (object.isFetchCardReward != null)
                message.isFetchCardReward = object.isFetchCardReward | 0;
            if (object.areaId != null)
                message.areaId = object.areaId | 0;
            if (object.baitId != null)
                message.baitId = object.baitId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishInfo
         * @static
         * @param {PB_SCRoleFishInfo} message PB_SCRoleFishInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.buyTimes = [];
                object.bookRewardFetchFlag = [];
                object.fishList = [];
                object.taskInfo = [];
                object.toolInfo = [];
                object.historyInfo = [];
            }
            if (options.defaults) {
                object.power = 0;
                object.nextPowerTime = 0;
                object.level = 0;
                object.exp = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.huanHuaActiveFlag = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.huanHuaActiveFlag = options.longs === String ? "0" : 0;
                object.fish = null;
                object.fishCardTime = 0;
                object.isFetchCardReward = 0;
                object.areaId = 0;
                object.baitId = 0;
            }
            if (message.power != null && message.hasOwnProperty("power"))
                object.power = message.power;
            if (message.nextPowerTime != null && message.hasOwnProperty("nextPowerTime"))
                object.nextPowerTime = message.nextPowerTime;
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.exp != null && message.hasOwnProperty("exp"))
                object.exp = message.exp;
            if (message.huanHuaActiveFlag != null && message.hasOwnProperty("huanHuaActiveFlag"))
                if (typeof message.huanHuaActiveFlag === "number")
                    object.huanHuaActiveFlag = options.longs === String ? String(message.huanHuaActiveFlag) : message.huanHuaActiveFlag;
                else
                    object.huanHuaActiveFlag = options.longs === String ? $util.Long.prototype.toString.call(message.huanHuaActiveFlag) : options.longs === Number ? new $util.LongBits(message.huanHuaActiveFlag.low >>> 0, message.huanHuaActiveFlag.high >>> 0).toNumber(true) : message.huanHuaActiveFlag;
            if (message.buyTimes && message.buyTimes.length) {
                object.buyTimes = [];
                for (var j = 0; j < message.buyTimes.length; ++j)
                    object.buyTimes[j] = message.buyTimes[j];
            }
            if (message.bookRewardFetchFlag && message.bookRewardFetchFlag.length) {
                object.bookRewardFetchFlag = [];
                for (var j = 0; j < message.bookRewardFetchFlag.length; ++j)
                    object.bookRewardFetchFlag[j] = message.bookRewardFetchFlag[j];
            }
            if (message.fish != null && message.hasOwnProperty("fish"))
                object.fish = $root.PB_RoleFishFish.toObject(message.fish, options);
            if (message.fishList && message.fishList.length) {
                object.fishList = [];
                for (var j = 0; j < message.fishList.length; ++j)
                    object.fishList[j] = $root.PB_RoleFishFish.toObject(message.fishList[j], options);
            }
            if (message.taskInfo && message.taskInfo.length) {
                object.taskInfo = [];
                for (var j = 0; j < message.taskInfo.length; ++j)
                    object.taskInfo[j] = $root.PB_RoleFishTaskInfo.toObject(message.taskInfo[j], options);
            }
            if (message.toolInfo && message.toolInfo.length) {
                object.toolInfo = [];
                for (var j = 0; j < message.toolInfo.length; ++j)
                    object.toolInfo[j] = $root.PB_RoleFishToolInfo.toObject(message.toolInfo[j], options);
            }
            if (message.historyInfo && message.historyInfo.length) {
                object.historyInfo = [];
                for (var j = 0; j < message.historyInfo.length; ++j)
                    object.historyInfo[j] = $root.PB_RoleFishHistoryInfo.toObject(message.historyInfo[j], options);
            }
            if (message.fishCardTime != null && message.hasOwnProperty("fishCardTime"))
                object.fishCardTime = message.fishCardTime;
            if (message.isFetchCardReward != null && message.hasOwnProperty("isFetchCardReward"))
                object.isFetchCardReward = message.isFetchCardReward;
            if (message.areaId != null && message.hasOwnProperty("areaId"))
                object.areaId = message.areaId;
            if (message.baitId != null && message.hasOwnProperty("baitId"))
                object.baitId = message.baitId;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishInfo;
    })();
    
    $root.PB_SCRoleFishPowerInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishPowerInfo.
         * @exports IPB_SCRoleFishPowerInfo
         * @interface IPB_SCRoleFishPowerInfo
         * @property {number|null} [power] PB_SCRoleFishPowerInfo power
         * @property {number|null} [nextPowerTime] PB_SCRoleFishPowerInfo nextPowerTime
         */
    
        /**
         * Constructs a new PB_SCRoleFishPowerInfo.
         * @exports PB_SCRoleFishPowerInfo
         * @classdesc Represents a PB_SCRoleFishPowerInfo.
         * @implements IPB_SCRoleFishPowerInfo
         * @constructor
         * @param {IPB_SCRoleFishPowerInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishPowerInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishPowerInfo power.
         * @member {number} power
         * @memberof PB_SCRoleFishPowerInfo
         * @instance
         */
        PB_SCRoleFishPowerInfo.prototype.power = 0;
    
        /**
         * PB_SCRoleFishPowerInfo nextPowerTime.
         * @member {number} nextPowerTime
         * @memberof PB_SCRoleFishPowerInfo
         * @instance
         */
        PB_SCRoleFishPowerInfo.prototype.nextPowerTime = 0;
    
        /**
         * Creates a new PB_SCRoleFishPowerInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishPowerInfo
         * @static
         * @param {IPB_SCRoleFishPowerInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishPowerInfo} PB_SCRoleFishPowerInfo instance
         */
        PB_SCRoleFishPowerInfo.create = function create(properties) {
            return new PB_SCRoleFishPowerInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishPowerInfo message. Does not implicitly {@link PB_SCRoleFishPowerInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishPowerInfo
         * @static
         * @param {IPB_SCRoleFishPowerInfo} message PB_SCRoleFishPowerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishPowerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.power);
            if (message.nextPowerTime != null && Object.hasOwnProperty.call(message, "nextPowerTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nextPowerTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishPowerInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishPowerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishPowerInfo
         * @static
         * @param {IPB_SCRoleFishPowerInfo} message PB_SCRoleFishPowerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishPowerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishPowerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishPowerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishPowerInfo} PB_SCRoleFishPowerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishPowerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishPowerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.power = reader.int32();
                    break;
                case 2:
                    message.nextPowerTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishPowerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishPowerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishPowerInfo} PB_SCRoleFishPowerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishPowerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishPowerInfo message.
         * @function verify
         * @memberof PB_SCRoleFishPowerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishPowerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power))
                    return "power: integer expected";
            if (message.nextPowerTime != null && message.hasOwnProperty("nextPowerTime"))
                if (!$util.isInteger(message.nextPowerTime))
                    return "nextPowerTime: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishPowerInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishPowerInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishPowerInfo} PB_SCRoleFishPowerInfo
         */
        PB_SCRoleFishPowerInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishPowerInfo)
                return object;
            var message = new $root.PB_SCRoleFishPowerInfo();
            if (object.power != null)
                message.power = object.power | 0;
            if (object.nextPowerTime != null)
                message.nextPowerTime = object.nextPowerTime | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishPowerInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishPowerInfo
         * @static
         * @param {PB_SCRoleFishPowerInfo} message PB_SCRoleFishPowerInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishPowerInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.power = 0;
                object.nextPowerTime = 0;
            }
            if (message.power != null && message.hasOwnProperty("power"))
                object.power = message.power;
            if (message.nextPowerTime != null && message.hasOwnProperty("nextPowerTime"))
                object.nextPowerTime = message.nextPowerTime;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishPowerInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishPowerInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishPowerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishPowerInfo;
    })();
    
    $root.PB_SCRoleFishCommonInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishCommonInfo.
         * @exports IPB_SCRoleFishCommonInfo
         * @interface IPB_SCRoleFishCommonInfo
         * @property {number|null} [fishCardTime] PB_SCRoleFishCommonInfo fishCardTime
         * @property {number|null} [isFetchCardReward] PB_SCRoleFishCommonInfo isFetchCardReward
         * @property {number|null} [areaId] PB_SCRoleFishCommonInfo areaId
         * @property {number|null} [baitId] PB_SCRoleFishCommonInfo baitId
         */
    
        /**
         * Constructs a new PB_SCRoleFishCommonInfo.
         * @exports PB_SCRoleFishCommonInfo
         * @classdesc Represents a PB_SCRoleFishCommonInfo.
         * @implements IPB_SCRoleFishCommonInfo
         * @constructor
         * @param {IPB_SCRoleFishCommonInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishCommonInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishCommonInfo fishCardTime.
         * @member {number} fishCardTime
         * @memberof PB_SCRoleFishCommonInfo
         * @instance
         */
        PB_SCRoleFishCommonInfo.prototype.fishCardTime = 0;
    
        /**
         * PB_SCRoleFishCommonInfo isFetchCardReward.
         * @member {number} isFetchCardReward
         * @memberof PB_SCRoleFishCommonInfo
         * @instance
         */
        PB_SCRoleFishCommonInfo.prototype.isFetchCardReward = 0;
    
        /**
         * PB_SCRoleFishCommonInfo areaId.
         * @member {number} areaId
         * @memberof PB_SCRoleFishCommonInfo
         * @instance
         */
        PB_SCRoleFishCommonInfo.prototype.areaId = 0;
    
        /**
         * PB_SCRoleFishCommonInfo baitId.
         * @member {number} baitId
         * @memberof PB_SCRoleFishCommonInfo
         * @instance
         */
        PB_SCRoleFishCommonInfo.prototype.baitId = 0;
    
        /**
         * Creates a new PB_SCRoleFishCommonInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishCommonInfo
         * @static
         * @param {IPB_SCRoleFishCommonInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishCommonInfo} PB_SCRoleFishCommonInfo instance
         */
        PB_SCRoleFishCommonInfo.create = function create(properties) {
            return new PB_SCRoleFishCommonInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishCommonInfo message. Does not implicitly {@link PB_SCRoleFishCommonInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishCommonInfo
         * @static
         * @param {IPB_SCRoleFishCommonInfo} message PB_SCRoleFishCommonInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishCommonInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fishCardTime != null && Object.hasOwnProperty.call(message, "fishCardTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fishCardTime);
            if (message.isFetchCardReward != null && Object.hasOwnProperty.call(message, "isFetchCardReward"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isFetchCardReward);
            if (message.areaId != null && Object.hasOwnProperty.call(message, "areaId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.areaId);
            if (message.baitId != null && Object.hasOwnProperty.call(message, "baitId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.baitId);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishCommonInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishCommonInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishCommonInfo
         * @static
         * @param {IPB_SCRoleFishCommonInfo} message PB_SCRoleFishCommonInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishCommonInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishCommonInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishCommonInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishCommonInfo} PB_SCRoleFishCommonInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishCommonInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishCommonInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fishCardTime = reader.int32();
                    break;
                case 2:
                    message.isFetchCardReward = reader.int32();
                    break;
                case 3:
                    message.areaId = reader.int32();
                    break;
                case 4:
                    message.baitId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishCommonInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishCommonInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishCommonInfo} PB_SCRoleFishCommonInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishCommonInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishCommonInfo message.
         * @function verify
         * @memberof PB_SCRoleFishCommonInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishCommonInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fishCardTime != null && message.hasOwnProperty("fishCardTime"))
                if (!$util.isInteger(message.fishCardTime))
                    return "fishCardTime: integer expected";
            if (message.isFetchCardReward != null && message.hasOwnProperty("isFetchCardReward"))
                if (!$util.isInteger(message.isFetchCardReward))
                    return "isFetchCardReward: integer expected";
            if (message.areaId != null && message.hasOwnProperty("areaId"))
                if (!$util.isInteger(message.areaId))
                    return "areaId: integer expected";
            if (message.baitId != null && message.hasOwnProperty("baitId"))
                if (!$util.isInteger(message.baitId))
                    return "baitId: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishCommonInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishCommonInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishCommonInfo} PB_SCRoleFishCommonInfo
         */
        PB_SCRoleFishCommonInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishCommonInfo)
                return object;
            var message = new $root.PB_SCRoleFishCommonInfo();
            if (object.fishCardTime != null)
                message.fishCardTime = object.fishCardTime | 0;
            if (object.isFetchCardReward != null)
                message.isFetchCardReward = object.isFetchCardReward | 0;
            if (object.areaId != null)
                message.areaId = object.areaId | 0;
            if (object.baitId != null)
                message.baitId = object.baitId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishCommonInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishCommonInfo
         * @static
         * @param {PB_SCRoleFishCommonInfo} message PB_SCRoleFishCommonInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishCommonInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.fishCardTime = 0;
                object.isFetchCardReward = 0;
                object.areaId = 0;
                object.baitId = 0;
            }
            if (message.fishCardTime != null && message.hasOwnProperty("fishCardTime"))
                object.fishCardTime = message.fishCardTime;
            if (message.isFetchCardReward != null && message.hasOwnProperty("isFetchCardReward"))
                object.isFetchCardReward = message.isFetchCardReward;
            if (message.areaId != null && message.hasOwnProperty("areaId"))
                object.areaId = message.areaId;
            if (message.baitId != null && message.hasOwnProperty("baitId"))
                object.baitId = message.baitId;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishCommonInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishCommonInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishCommonInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishCommonInfo;
    })();
    
    $root.PB_SCRoleFishFishInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishFishInfo.
         * @exports IPB_SCRoleFishFishInfo
         * @interface IPB_SCRoleFishFishInfo
         * @property {number|null} [state] PB_SCRoleFishFishInfo state
         * @property {IPB_RoleFishFish|null} [fish] PB_SCRoleFishFishInfo fish
         */
    
        /**
         * Constructs a new PB_SCRoleFishFishInfo.
         * @exports PB_SCRoleFishFishInfo
         * @classdesc Represents a PB_SCRoleFishFishInfo.
         * @implements IPB_SCRoleFishFishInfo
         * @constructor
         * @param {IPB_SCRoleFishFishInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishFishInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishFishInfo state.
         * @member {number} state
         * @memberof PB_SCRoleFishFishInfo
         * @instance
         */
        PB_SCRoleFishFishInfo.prototype.state = 0;
    
        /**
         * PB_SCRoleFishFishInfo fish.
         * @member {IPB_RoleFishFish|null|undefined} fish
         * @memberof PB_SCRoleFishFishInfo
         * @instance
         */
        PB_SCRoleFishFishInfo.prototype.fish = null;
    
        /**
         * Creates a new PB_SCRoleFishFishInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishFishInfo
         * @static
         * @param {IPB_SCRoleFishFishInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishFishInfo} PB_SCRoleFishFishInfo instance
         */
        PB_SCRoleFishFishInfo.create = function create(properties) {
            return new PB_SCRoleFishFishInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishFishInfo message. Does not implicitly {@link PB_SCRoleFishFishInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishFishInfo
         * @static
         * @param {IPB_SCRoleFishFishInfo} message PB_SCRoleFishFishInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishFishInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
            if (message.fish != null && Object.hasOwnProperty.call(message, "fish"))
                $root.PB_RoleFishFish.encode(message.fish, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishFishInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishFishInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishFishInfo
         * @static
         * @param {IPB_SCRoleFishFishInfo} message PB_SCRoleFishFishInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishFishInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishFishInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishFishInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishFishInfo} PB_SCRoleFishFishInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishFishInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishFishInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.int32();
                    break;
                case 2:
                    message.fish = $root.PB_RoleFishFish.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishFishInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishFishInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishFishInfo} PB_SCRoleFishFishInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishFishInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishFishInfo message.
         * @function verify
         * @memberof PB_SCRoleFishFishInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishFishInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.fish != null && message.hasOwnProperty("fish")) {
                var error = $root.PB_RoleFishFish.verify(message.fish);
                if (error)
                    return "fish." + error;
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishFishInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishFishInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishFishInfo} PB_SCRoleFishFishInfo
         */
        PB_SCRoleFishFishInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishFishInfo)
                return object;
            var message = new $root.PB_SCRoleFishFishInfo();
            if (object.state != null)
                message.state = object.state | 0;
            if (object.fish != null) {
                if (typeof object.fish !== "object")
                    throw TypeError(".PB_SCRoleFishFishInfo.fish: object expected");
                message.fish = $root.PB_RoleFishFish.fromObject(object.fish);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishFishInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishFishInfo
         * @static
         * @param {PB_SCRoleFishFishInfo} message PB_SCRoleFishFishInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishFishInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.state = 0;
                object.fish = null;
            }
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.fish != null && message.hasOwnProperty("fish"))
                object.fish = $root.PB_RoleFishFish.toObject(message.fish, options);
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishFishInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishFishInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishFishInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishFishInfo;
    })();
    
    $root.PB_SCRoleFishFishListInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishFishListInfo.
         * @exports IPB_SCRoleFishFishListInfo
         * @interface IPB_SCRoleFishFishListInfo
         * @property {number|null} [index] PB_SCRoleFishFishListInfo index
         * @property {IPB_RoleFishFish|null} [fish] PB_SCRoleFishFishListInfo fish
         */
    
        /**
         * Constructs a new PB_SCRoleFishFishListInfo.
         * @exports PB_SCRoleFishFishListInfo
         * @classdesc Represents a PB_SCRoleFishFishListInfo.
         * @implements IPB_SCRoleFishFishListInfo
         * @constructor
         * @param {IPB_SCRoleFishFishListInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishFishListInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishFishListInfo index.
         * @member {number} index
         * @memberof PB_SCRoleFishFishListInfo
         * @instance
         */
        PB_SCRoleFishFishListInfo.prototype.index = 0;
    
        /**
         * PB_SCRoleFishFishListInfo fish.
         * @member {IPB_RoleFishFish|null|undefined} fish
         * @memberof PB_SCRoleFishFishListInfo
         * @instance
         */
        PB_SCRoleFishFishListInfo.prototype.fish = null;
    
        /**
         * Creates a new PB_SCRoleFishFishListInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishFishListInfo
         * @static
         * @param {IPB_SCRoleFishFishListInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishFishListInfo} PB_SCRoleFishFishListInfo instance
         */
        PB_SCRoleFishFishListInfo.create = function create(properties) {
            return new PB_SCRoleFishFishListInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishFishListInfo message. Does not implicitly {@link PB_SCRoleFishFishListInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishFishListInfo
         * @static
         * @param {IPB_SCRoleFishFishListInfo} message PB_SCRoleFishFishListInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishFishListInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.fish != null && Object.hasOwnProperty.call(message, "fish"))
                $root.PB_RoleFishFish.encode(message.fish, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishFishListInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishFishListInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishFishListInfo
         * @static
         * @param {IPB_SCRoleFishFishListInfo} message PB_SCRoleFishFishListInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishFishListInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishFishListInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishFishListInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishFishListInfo} PB_SCRoleFishFishListInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishFishListInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishFishListInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.fish = $root.PB_RoleFishFish.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishFishListInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishFishListInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishFishListInfo} PB_SCRoleFishFishListInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishFishListInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishFishListInfo message.
         * @function verify
         * @memberof PB_SCRoleFishFishListInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishFishListInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.fish != null && message.hasOwnProperty("fish")) {
                var error = $root.PB_RoleFishFish.verify(message.fish);
                if (error)
                    return "fish." + error;
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishFishListInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishFishListInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishFishListInfo} PB_SCRoleFishFishListInfo
         */
        PB_SCRoleFishFishListInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishFishListInfo)
                return object;
            var message = new $root.PB_SCRoleFishFishListInfo();
            if (object.index != null)
                message.index = object.index | 0;
            if (object.fish != null) {
                if (typeof object.fish !== "object")
                    throw TypeError(".PB_SCRoleFishFishListInfo.fish: object expected");
                message.fish = $root.PB_RoleFishFish.fromObject(object.fish);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishFishListInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishFishListInfo
         * @static
         * @param {PB_SCRoleFishFishListInfo} message PB_SCRoleFishFishListInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishFishListInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.index = 0;
                object.fish = null;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.fish != null && message.hasOwnProperty("fish"))
                object.fish = $root.PB_RoleFishFish.toObject(message.fish, options);
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishFishListInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishFishListInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishFishListInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishFishListInfo;
    })();
    
    $root.PB_SCRoleFishLevelInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishLevelInfo.
         * @exports IPB_SCRoleFishLevelInfo
         * @interface IPB_SCRoleFishLevelInfo
         * @property {number|null} [level] PB_SCRoleFishLevelInfo level
         * @property {number|null} [exp] PB_SCRoleFishLevelInfo exp
         */
    
        /**
         * Constructs a new PB_SCRoleFishLevelInfo.
         * @exports PB_SCRoleFishLevelInfo
         * @classdesc Represents a PB_SCRoleFishLevelInfo.
         * @implements IPB_SCRoleFishLevelInfo
         * @constructor
         * @param {IPB_SCRoleFishLevelInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishLevelInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishLevelInfo level.
         * @member {number} level
         * @memberof PB_SCRoleFishLevelInfo
         * @instance
         */
        PB_SCRoleFishLevelInfo.prototype.level = 0;
    
        /**
         * PB_SCRoleFishLevelInfo exp.
         * @member {number} exp
         * @memberof PB_SCRoleFishLevelInfo
         * @instance
         */
        PB_SCRoleFishLevelInfo.prototype.exp = 0;
    
        /**
         * Creates a new PB_SCRoleFishLevelInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishLevelInfo
         * @static
         * @param {IPB_SCRoleFishLevelInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishLevelInfo} PB_SCRoleFishLevelInfo instance
         */
        PB_SCRoleFishLevelInfo.create = function create(properties) {
            return new PB_SCRoleFishLevelInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishLevelInfo message. Does not implicitly {@link PB_SCRoleFishLevelInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishLevelInfo
         * @static
         * @param {IPB_SCRoleFishLevelInfo} message PB_SCRoleFishLevelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishLevelInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.exp);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishLevelInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishLevelInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishLevelInfo
         * @static
         * @param {IPB_SCRoleFishLevelInfo} message PB_SCRoleFishLevelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishLevelInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishLevelInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishLevelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishLevelInfo} PB_SCRoleFishLevelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishLevelInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishLevelInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.level = reader.int32();
                    break;
                case 2:
                    message.exp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishLevelInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishLevelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishLevelInfo} PB_SCRoleFishLevelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishLevelInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishLevelInfo message.
         * @function verify
         * @memberof PB_SCRoleFishLevelInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishLevelInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishLevelInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishLevelInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishLevelInfo} PB_SCRoleFishLevelInfo
         */
        PB_SCRoleFishLevelInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishLevelInfo)
                return object;
            var message = new $root.PB_SCRoleFishLevelInfo();
            if (object.level != null)
                message.level = object.level | 0;
            if (object.exp != null)
                message.exp = object.exp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishLevelInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishLevelInfo
         * @static
         * @param {PB_SCRoleFishLevelInfo} message PB_SCRoleFishLevelInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishLevelInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.level = 0;
                object.exp = 0;
            }
            if (message.level != null && message.hasOwnProperty("level"))
                object.level = message.level;
            if (message.exp != null && message.hasOwnProperty("exp"))
                object.exp = message.exp;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishLevelInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishLevelInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishLevelInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishLevelInfo;
    })();
    
    $root.PB_SCRoleFishBookRewardInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishBookRewardInfo.
         * @exports IPB_SCRoleFishBookRewardInfo
         * @interface IPB_SCRoleFishBookRewardInfo
         * @property {Array.<boolean>|null} [bookRewardFetchFlag] PB_SCRoleFishBookRewardInfo bookRewardFetchFlag
         */
    
        /**
         * Constructs a new PB_SCRoleFishBookRewardInfo.
         * @exports PB_SCRoleFishBookRewardInfo
         * @classdesc Represents a PB_SCRoleFishBookRewardInfo.
         * @implements IPB_SCRoleFishBookRewardInfo
         * @constructor
         * @param {IPB_SCRoleFishBookRewardInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishBookRewardInfo(properties) {
            this.bookRewardFetchFlag = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishBookRewardInfo bookRewardFetchFlag.
         * @member {Array.<boolean>} bookRewardFetchFlag
         * @memberof PB_SCRoleFishBookRewardInfo
         * @instance
         */
        PB_SCRoleFishBookRewardInfo.prototype.bookRewardFetchFlag = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRoleFishBookRewardInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishBookRewardInfo
         * @static
         * @param {IPB_SCRoleFishBookRewardInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishBookRewardInfo} PB_SCRoleFishBookRewardInfo instance
         */
        PB_SCRoleFishBookRewardInfo.create = function create(properties) {
            return new PB_SCRoleFishBookRewardInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishBookRewardInfo message. Does not implicitly {@link PB_SCRoleFishBookRewardInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishBookRewardInfo
         * @static
         * @param {IPB_SCRoleFishBookRewardInfo} message PB_SCRoleFishBookRewardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishBookRewardInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bookRewardFetchFlag != null && message.bookRewardFetchFlag.length)
                for (var i = 0; i < message.bookRewardFetchFlag.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.bookRewardFetchFlag[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishBookRewardInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishBookRewardInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishBookRewardInfo
         * @static
         * @param {IPB_SCRoleFishBookRewardInfo} message PB_SCRoleFishBookRewardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishBookRewardInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishBookRewardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishBookRewardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishBookRewardInfo} PB_SCRoleFishBookRewardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishBookRewardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishBookRewardInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.bookRewardFetchFlag && message.bookRewardFetchFlag.length))
                        message.bookRewardFetchFlag = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.bookRewardFetchFlag.push(reader.bool());
                    } else
                        message.bookRewardFetchFlag.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishBookRewardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishBookRewardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishBookRewardInfo} PB_SCRoleFishBookRewardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishBookRewardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishBookRewardInfo message.
         * @function verify
         * @memberof PB_SCRoleFishBookRewardInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishBookRewardInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bookRewardFetchFlag != null && message.hasOwnProperty("bookRewardFetchFlag")) {
                if (!Array.isArray(message.bookRewardFetchFlag))
                    return "bookRewardFetchFlag: array expected";
                for (var i = 0; i < message.bookRewardFetchFlag.length; ++i)
                    if (typeof message.bookRewardFetchFlag[i] !== "boolean")
                        return "bookRewardFetchFlag: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishBookRewardInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishBookRewardInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishBookRewardInfo} PB_SCRoleFishBookRewardInfo
         */
        PB_SCRoleFishBookRewardInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishBookRewardInfo)
                return object;
            var message = new $root.PB_SCRoleFishBookRewardInfo();
            if (object.bookRewardFetchFlag) {
                if (!Array.isArray(object.bookRewardFetchFlag))
                    throw TypeError(".PB_SCRoleFishBookRewardInfo.bookRewardFetchFlag: array expected");
                message.bookRewardFetchFlag = [];
                for (var i = 0; i < object.bookRewardFetchFlag.length; ++i)
                    message.bookRewardFetchFlag[i] = Boolean(object.bookRewardFetchFlag[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishBookRewardInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishBookRewardInfo
         * @static
         * @param {PB_SCRoleFishBookRewardInfo} message PB_SCRoleFishBookRewardInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishBookRewardInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.bookRewardFetchFlag = [];
            if (message.bookRewardFetchFlag && message.bookRewardFetchFlag.length) {
                object.bookRewardFetchFlag = [];
                for (var j = 0; j < message.bookRewardFetchFlag.length; ++j)
                    object.bookRewardFetchFlag[j] = message.bookRewardFetchFlag[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishBookRewardInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishBookRewardInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishBookRewardInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishBookRewardInfo;
    })();
    
    $root.PB_SCRoleFishToolInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishToolInfo.
         * @exports IPB_SCRoleFishToolInfo
         * @interface IPB_SCRoleFishToolInfo
         * @property {Array.<IPB_RoleFishToolInfo>|null} [toolInfo] PB_SCRoleFishToolInfo toolInfo
         * @property {number|null} [huanHuaActiveFlag] PB_SCRoleFishToolInfo huanHuaActiveFlag
         */
    
        /**
         * Constructs a new PB_SCRoleFishToolInfo.
         * @exports PB_SCRoleFishToolInfo
         * @classdesc Represents a PB_SCRoleFishToolInfo.
         * @implements IPB_SCRoleFishToolInfo
         * @constructor
         * @param {IPB_SCRoleFishToolInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishToolInfo(properties) {
            this.toolInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishToolInfo toolInfo.
         * @member {Array.<IPB_RoleFishToolInfo>} toolInfo
         * @memberof PB_SCRoleFishToolInfo
         * @instance
         */
        PB_SCRoleFishToolInfo.prototype.toolInfo = $util.emptyArray;
    
        /**
         * PB_SCRoleFishToolInfo huanHuaActiveFlag.
         * @member {number} huanHuaActiveFlag
         * @memberof PB_SCRoleFishToolInfo
         * @instance
         */
        PB_SCRoleFishToolInfo.prototype.huanHuaActiveFlag = 0;
    
        /**
         * Creates a new PB_SCRoleFishToolInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishToolInfo
         * @static
         * @param {IPB_SCRoleFishToolInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishToolInfo} PB_SCRoleFishToolInfo instance
         */
        PB_SCRoleFishToolInfo.create = function create(properties) {
            return new PB_SCRoleFishToolInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishToolInfo message. Does not implicitly {@link PB_SCRoleFishToolInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishToolInfo
         * @static
         * @param {IPB_SCRoleFishToolInfo} message PB_SCRoleFishToolInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishToolInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.toolInfo != null && message.toolInfo.length)
                for (var i = 0; i < message.toolInfo.length; ++i)
                    $root.PB_RoleFishToolInfo.encode(message.toolInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.huanHuaActiveFlag != null && Object.hasOwnProperty.call(message, "huanHuaActiveFlag"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.huanHuaActiveFlag);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishToolInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishToolInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishToolInfo
         * @static
         * @param {IPB_SCRoleFishToolInfo} message PB_SCRoleFishToolInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishToolInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishToolInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishToolInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishToolInfo} PB_SCRoleFishToolInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishToolInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishToolInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.toolInfo && message.toolInfo.length))
                        message.toolInfo = [];
                    message.toolInfo.push($root.PB_RoleFishToolInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.huanHuaActiveFlag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishToolInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishToolInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishToolInfo} PB_SCRoleFishToolInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishToolInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishToolInfo message.
         * @function verify
         * @memberof PB_SCRoleFishToolInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishToolInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.toolInfo != null && message.hasOwnProperty("toolInfo")) {
                if (!Array.isArray(message.toolInfo))
                    return "toolInfo: array expected";
                for (var i = 0; i < message.toolInfo.length; ++i) {
                    var error = $root.PB_RoleFishToolInfo.verify(message.toolInfo[i]);
                    if (error)
                        return "toolInfo." + error;
                }
            }
            if (message.huanHuaActiveFlag != null && message.hasOwnProperty("huanHuaActiveFlag"))
                if (!$util.isInteger(message.huanHuaActiveFlag))
                    return "huanHuaActiveFlag: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishToolInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishToolInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishToolInfo} PB_SCRoleFishToolInfo
         */
        PB_SCRoleFishToolInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishToolInfo)
                return object;
            var message = new $root.PB_SCRoleFishToolInfo();
            if (object.toolInfo) {
                if (!Array.isArray(object.toolInfo))
                    throw TypeError(".PB_SCRoleFishToolInfo.toolInfo: array expected");
                message.toolInfo = [];
                for (var i = 0; i < object.toolInfo.length; ++i) {
                    if (typeof object.toolInfo[i] !== "object")
                        throw TypeError(".PB_SCRoleFishToolInfo.toolInfo: object expected");
                    message.toolInfo[i] = $root.PB_RoleFishToolInfo.fromObject(object.toolInfo[i]);
                }
            }
            if (object.huanHuaActiveFlag != null)
                message.huanHuaActiveFlag = object.huanHuaActiveFlag | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishToolInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishToolInfo
         * @static
         * @param {PB_SCRoleFishToolInfo} message PB_SCRoleFishToolInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishToolInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.toolInfo = [];
            if (options.defaults)
                object.huanHuaActiveFlag = 0;
            if (message.toolInfo && message.toolInfo.length) {
                object.toolInfo = [];
                for (var j = 0; j < message.toolInfo.length; ++j)
                    object.toolInfo[j] = $root.PB_RoleFishToolInfo.toObject(message.toolInfo[j], options);
            }
            if (message.huanHuaActiveFlag != null && message.hasOwnProperty("huanHuaActiveFlag"))
                object.huanHuaActiveFlag = message.huanHuaActiveFlag;
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishToolInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishToolInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishToolInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishToolInfo;
    })();
    
    $root.PB_SCRoleFishShopInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishShopInfo.
         * @exports IPB_SCRoleFishShopInfo
         * @interface IPB_SCRoleFishShopInfo
         * @property {Array.<number>|null} [buyTimes] PB_SCRoleFishShopInfo buyTimes
         */
    
        /**
         * Constructs a new PB_SCRoleFishShopInfo.
         * @exports PB_SCRoleFishShopInfo
         * @classdesc Represents a PB_SCRoleFishShopInfo.
         * @implements IPB_SCRoleFishShopInfo
         * @constructor
         * @param {IPB_SCRoleFishShopInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishShopInfo(properties) {
            this.buyTimes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishShopInfo buyTimes.
         * @member {Array.<number>} buyTimes
         * @memberof PB_SCRoleFishShopInfo
         * @instance
         */
        PB_SCRoleFishShopInfo.prototype.buyTimes = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRoleFishShopInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishShopInfo
         * @static
         * @param {IPB_SCRoleFishShopInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishShopInfo} PB_SCRoleFishShopInfo instance
         */
        PB_SCRoleFishShopInfo.create = function create(properties) {
            return new PB_SCRoleFishShopInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishShopInfo message. Does not implicitly {@link PB_SCRoleFishShopInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishShopInfo
         * @static
         * @param {IPB_SCRoleFishShopInfo} message PB_SCRoleFishShopInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishShopInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.buyTimes != null && message.buyTimes.length)
                for (var i = 0; i < message.buyTimes.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.buyTimes[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishShopInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishShopInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishShopInfo
         * @static
         * @param {IPB_SCRoleFishShopInfo} message PB_SCRoleFishShopInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishShopInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishShopInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishShopInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishShopInfo} PB_SCRoleFishShopInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishShopInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishShopInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.buyTimes && message.buyTimes.length))
                        message.buyTimes = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.buyTimes.push(reader.int32());
                    } else
                        message.buyTimes.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishShopInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishShopInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishShopInfo} PB_SCRoleFishShopInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishShopInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishShopInfo message.
         * @function verify
         * @memberof PB_SCRoleFishShopInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishShopInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.buyTimes != null && message.hasOwnProperty("buyTimes")) {
                if (!Array.isArray(message.buyTimes))
                    return "buyTimes: array expected";
                for (var i = 0; i < message.buyTimes.length; ++i)
                    if (!$util.isInteger(message.buyTimes[i]))
                        return "buyTimes: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishShopInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishShopInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishShopInfo} PB_SCRoleFishShopInfo
         */
        PB_SCRoleFishShopInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishShopInfo)
                return object;
            var message = new $root.PB_SCRoleFishShopInfo();
            if (object.buyTimes) {
                if (!Array.isArray(object.buyTimes))
                    throw TypeError(".PB_SCRoleFishShopInfo.buyTimes: array expected");
                message.buyTimes = [];
                for (var i = 0; i < object.buyTimes.length; ++i)
                    message.buyTimes[i] = object.buyTimes[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishShopInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishShopInfo
         * @static
         * @param {PB_SCRoleFishShopInfo} message PB_SCRoleFishShopInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishShopInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.buyTimes = [];
            if (message.buyTimes && message.buyTimes.length) {
                object.buyTimes = [];
                for (var j = 0; j < message.buyTimes.length; ++j)
                    object.buyTimes[j] = message.buyTimes[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishShopInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishShopInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishShopInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishShopInfo;
    })();
    
    $root.PB_SCRoleFishTaskInfo = (function() {
    
        /**
         * Properties of a PB_SCRoleFishTaskInfo.
         * @exports IPB_SCRoleFishTaskInfo
         * @interface IPB_SCRoleFishTaskInfo
         * @property {Array.<IPB_RoleFishTaskInfo>|null} [taskInfo] PB_SCRoleFishTaskInfo taskInfo
         */
    
        /**
         * Constructs a new PB_SCRoleFishTaskInfo.
         * @exports PB_SCRoleFishTaskInfo
         * @classdesc Represents a PB_SCRoleFishTaskInfo.
         * @implements IPB_SCRoleFishTaskInfo
         * @constructor
         * @param {IPB_SCRoleFishTaskInfo=} [properties] Properties to set
         */
        function PB_SCRoleFishTaskInfo(properties) {
            this.taskInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCRoleFishTaskInfo taskInfo.
         * @member {Array.<IPB_RoleFishTaskInfo>} taskInfo
         * @memberof PB_SCRoleFishTaskInfo
         * @instance
         */
        PB_SCRoleFishTaskInfo.prototype.taskInfo = $util.emptyArray;
    
        /**
         * Creates a new PB_SCRoleFishTaskInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCRoleFishTaskInfo
         * @static
         * @param {IPB_SCRoleFishTaskInfo=} [properties] Properties to set
         * @returns {PB_SCRoleFishTaskInfo} PB_SCRoleFishTaskInfo instance
         */
        PB_SCRoleFishTaskInfo.create = function create(properties) {
            return new PB_SCRoleFishTaskInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCRoleFishTaskInfo message. Does not implicitly {@link PB_SCRoleFishTaskInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCRoleFishTaskInfo
         * @static
         * @param {IPB_SCRoleFishTaskInfo} message PB_SCRoleFishTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishTaskInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskInfo != null && message.taskInfo.length)
                for (var i = 0; i < message.taskInfo.length; ++i)
                    $root.PB_RoleFishTaskInfo.encode(message.taskInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCRoleFishTaskInfo message, length delimited. Does not implicitly {@link PB_SCRoleFishTaskInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCRoleFishTaskInfo
         * @static
         * @param {IPB_SCRoleFishTaskInfo} message PB_SCRoleFishTaskInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCRoleFishTaskInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCRoleFishTaskInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCRoleFishTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCRoleFishTaskInfo} PB_SCRoleFishTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishTaskInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCRoleFishTaskInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.taskInfo && message.taskInfo.length))
                        message.taskInfo = [];
                    message.taskInfo.push($root.PB_RoleFishTaskInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCRoleFishTaskInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCRoleFishTaskInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCRoleFishTaskInfo} PB_SCRoleFishTaskInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCRoleFishTaskInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCRoleFishTaskInfo message.
         * @function verify
         * @memberof PB_SCRoleFishTaskInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCRoleFishTaskInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskInfo != null && message.hasOwnProperty("taskInfo")) {
                if (!Array.isArray(message.taskInfo))
                    return "taskInfo: array expected";
                for (var i = 0; i < message.taskInfo.length; ++i) {
                    var error = $root.PB_RoleFishTaskInfo.verify(message.taskInfo[i]);
                    if (error)
                        return "taskInfo." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCRoleFishTaskInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCRoleFishTaskInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCRoleFishTaskInfo} PB_SCRoleFishTaskInfo
         */
        PB_SCRoleFishTaskInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCRoleFishTaskInfo)
                return object;
            var message = new $root.PB_SCRoleFishTaskInfo();
            if (object.taskInfo) {
                if (!Array.isArray(object.taskInfo))
                    throw TypeError(".PB_SCRoleFishTaskInfo.taskInfo: array expected");
                message.taskInfo = [];
                for (var i = 0; i < object.taskInfo.length; ++i) {
                    if (typeof object.taskInfo[i] !== "object")
                        throw TypeError(".PB_SCRoleFishTaskInfo.taskInfo: object expected");
                    message.taskInfo[i] = $root.PB_RoleFishTaskInfo.fromObject(object.taskInfo[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCRoleFishTaskInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCRoleFishTaskInfo
         * @static
         * @param {PB_SCRoleFishTaskInfo} message PB_SCRoleFishTaskInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCRoleFishTaskInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.taskInfo = [];
            if (message.taskInfo && message.taskInfo.length) {
                object.taskInfo = [];
                for (var j = 0; j < message.taskInfo.length; ++j)
                    object.taskInfo[j] = $root.PB_RoleFishTaskInfo.toObject(message.taskInfo[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCRoleFishTaskInfo to JSON.
         * @function toJSON
         * @memberof PB_SCRoleFishTaskInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCRoleFishTaskInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCRoleFishTaskInfo;
    })();
    
    $root.PB_CSHeartbeatReq = (function() {
    
        /**
         * Properties of a PB_CSHeartbeatReq.
         * @exports IPB_CSHeartbeatReq
         * @interface IPB_CSHeartbeatReq
         * @property {number|null} [reserve] PB_CSHeartbeatReq reserve
         */
    
        /**
         * Constructs a new PB_CSHeartbeatReq.
         * @exports PB_CSHeartbeatReq
         * @classdesc Represents a PB_CSHeartbeatReq.
         * @implements IPB_CSHeartbeatReq
         * @constructor
         * @param {IPB_CSHeartbeatReq=} [properties] Properties to set
         */
        function PB_CSHeartbeatReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSHeartbeatReq reserve.
         * @member {number} reserve
         * @memberof PB_CSHeartbeatReq
         * @instance
         */
        PB_CSHeartbeatReq.prototype.reserve = 0;
    
        /**
         * Creates a new PB_CSHeartbeatReq instance using the specified properties.
         * @function create
         * @memberof PB_CSHeartbeatReq
         * @static
         * @param {IPB_CSHeartbeatReq=} [properties] Properties to set
         * @returns {PB_CSHeartbeatReq} PB_CSHeartbeatReq instance
         */
        PB_CSHeartbeatReq.create = function create(properties) {
            return new PB_CSHeartbeatReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSHeartbeatReq message. Does not implicitly {@link PB_CSHeartbeatReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSHeartbeatReq
         * @static
         * @param {IPB_CSHeartbeatReq} message PB_CSHeartbeatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSHeartbeatReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reserve != null && Object.hasOwnProperty.call(message, "reserve"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reserve);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSHeartbeatReq message, length delimited. Does not implicitly {@link PB_CSHeartbeatReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSHeartbeatReq
         * @static
         * @param {IPB_CSHeartbeatReq} message PB_CSHeartbeatReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSHeartbeatReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSHeartbeatReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSHeartbeatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSHeartbeatReq} PB_CSHeartbeatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSHeartbeatReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSHeartbeatReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reserve = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSHeartbeatReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSHeartbeatReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSHeartbeatReq} PB_CSHeartbeatReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSHeartbeatReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSHeartbeatReq message.
         * @function verify
         * @memberof PB_CSHeartbeatReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSHeartbeatReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                if (!$util.isInteger(message.reserve))
                    return "reserve: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSHeartbeatReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSHeartbeatReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSHeartbeatReq} PB_CSHeartbeatReq
         */
        PB_CSHeartbeatReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSHeartbeatReq)
                return object;
            var message = new $root.PB_CSHeartbeatReq();
            if (object.reserve != null)
                message.reserve = object.reserve | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSHeartbeatReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSHeartbeatReq
         * @static
         * @param {PB_CSHeartbeatReq} message PB_CSHeartbeatReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSHeartbeatReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reserve = 0;
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                object.reserve = message.reserve;
            return object;
        };
    
        /**
         * Converts this PB_CSHeartbeatReq to JSON.
         * @function toJSON
         * @memberof PB_CSHeartbeatReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSHeartbeatReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSHeartbeatReq;
    })();
    
    $root.PB_SCHeartbeatResp = (function() {
    
        /**
         * Properties of a PB_SCHeartbeatResp.
         * @exports IPB_SCHeartbeatResp
         * @interface IPB_SCHeartbeatResp
         * @property {number|null} [reserve] PB_SCHeartbeatResp reserve
         */
    
        /**
         * Constructs a new PB_SCHeartbeatResp.
         * @exports PB_SCHeartbeatResp
         * @classdesc Represents a PB_SCHeartbeatResp.
         * @implements IPB_SCHeartbeatResp
         * @constructor
         * @param {IPB_SCHeartbeatResp=} [properties] Properties to set
         */
        function PB_SCHeartbeatResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCHeartbeatResp reserve.
         * @member {number} reserve
         * @memberof PB_SCHeartbeatResp
         * @instance
         */
        PB_SCHeartbeatResp.prototype.reserve = 0;
    
        /**
         * Creates a new PB_SCHeartbeatResp instance using the specified properties.
         * @function create
         * @memberof PB_SCHeartbeatResp
         * @static
         * @param {IPB_SCHeartbeatResp=} [properties] Properties to set
         * @returns {PB_SCHeartbeatResp} PB_SCHeartbeatResp instance
         */
        PB_SCHeartbeatResp.create = function create(properties) {
            return new PB_SCHeartbeatResp(properties);
        };
    
        /**
         * Encodes the specified PB_SCHeartbeatResp message. Does not implicitly {@link PB_SCHeartbeatResp.verify|verify} messages.
         * @function encode
         * @memberof PB_SCHeartbeatResp
         * @static
         * @param {IPB_SCHeartbeatResp} message PB_SCHeartbeatResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHeartbeatResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reserve != null && Object.hasOwnProperty.call(message, "reserve"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reserve);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCHeartbeatResp message, length delimited. Does not implicitly {@link PB_SCHeartbeatResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCHeartbeatResp
         * @static
         * @param {IPB_SCHeartbeatResp} message PB_SCHeartbeatResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCHeartbeatResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCHeartbeatResp message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCHeartbeatResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCHeartbeatResp} PB_SCHeartbeatResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHeartbeatResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCHeartbeatResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reserve = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCHeartbeatResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCHeartbeatResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCHeartbeatResp} PB_SCHeartbeatResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCHeartbeatResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCHeartbeatResp message.
         * @function verify
         * @memberof PB_SCHeartbeatResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCHeartbeatResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                if (!$util.isInteger(message.reserve))
                    return "reserve: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCHeartbeatResp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCHeartbeatResp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCHeartbeatResp} PB_SCHeartbeatResp
         */
        PB_SCHeartbeatResp.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCHeartbeatResp)
                return object;
            var message = new $root.PB_SCHeartbeatResp();
            if (object.reserve != null)
                message.reserve = object.reserve | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCHeartbeatResp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCHeartbeatResp
         * @static
         * @param {PB_SCHeartbeatResp} message PB_SCHeartbeatResp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCHeartbeatResp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reserve = 0;
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                object.reserve = message.reserve;
            return object;
        };
    
        /**
         * Converts this PB_SCHeartbeatResp to JSON.
         * @function toJSON
         * @memberof PB_SCHeartbeatResp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCHeartbeatResp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCHeartbeatResp;
    })();
    
    $root.PB_SCTimeAck = (function() {
    
        /**
         * Properties of a PB_SCTimeAck.
         * @exports IPB_SCTimeAck
         * @interface IPB_SCTimeAck
         * @property {number|null} [serverTime] PB_SCTimeAck serverTime
         * @property {number|null} [serverRealStartTime] PB_SCTimeAck serverRealStartTime
         * @property {number|null} [openDays] PB_SCTimeAck openDays
         * @property {number|null} [serverRealCombineTime] PB_SCTimeAck serverRealCombineTime
         */
    
        /**
         * Constructs a new PB_SCTimeAck.
         * @exports PB_SCTimeAck
         * @classdesc Represents a PB_SCTimeAck.
         * @implements IPB_SCTimeAck
         * @constructor
         * @param {IPB_SCTimeAck=} [properties] Properties to set
         */
        function PB_SCTimeAck(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTimeAck serverTime.
         * @member {number} serverTime
         * @memberof PB_SCTimeAck
         * @instance
         */
        PB_SCTimeAck.prototype.serverTime = 0;
    
        /**
         * PB_SCTimeAck serverRealStartTime.
         * @member {number} serverRealStartTime
         * @memberof PB_SCTimeAck
         * @instance
         */
        PB_SCTimeAck.prototype.serverRealStartTime = 0;
    
        /**
         * PB_SCTimeAck openDays.
         * @member {number} openDays
         * @memberof PB_SCTimeAck
         * @instance
         */
        PB_SCTimeAck.prototype.openDays = 0;
    
        /**
         * PB_SCTimeAck serverRealCombineTime.
         * @member {number} serverRealCombineTime
         * @memberof PB_SCTimeAck
         * @instance
         */
        PB_SCTimeAck.prototype.serverRealCombineTime = 0;
    
        /**
         * Creates a new PB_SCTimeAck instance using the specified properties.
         * @function create
         * @memberof PB_SCTimeAck
         * @static
         * @param {IPB_SCTimeAck=} [properties] Properties to set
         * @returns {PB_SCTimeAck} PB_SCTimeAck instance
         */
        PB_SCTimeAck.create = function create(properties) {
            return new PB_SCTimeAck(properties);
        };
    
        /**
         * Encodes the specified PB_SCTimeAck message. Does not implicitly {@link PB_SCTimeAck.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTimeAck
         * @static
         * @param {IPB_SCTimeAck} message PB_SCTimeAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTimeAck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverTime != null && Object.hasOwnProperty.call(message, "serverTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.serverTime);
            if (message.serverRealStartTime != null && Object.hasOwnProperty.call(message, "serverRealStartTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.serverRealStartTime);
            if (message.openDays != null && Object.hasOwnProperty.call(message, "openDays"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.openDays);
            if (message.serverRealCombineTime != null && Object.hasOwnProperty.call(message, "serverRealCombineTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.serverRealCombineTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTimeAck message, length delimited. Does not implicitly {@link PB_SCTimeAck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTimeAck
         * @static
         * @param {IPB_SCTimeAck} message PB_SCTimeAck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTimeAck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTimeAck message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTimeAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTimeAck} PB_SCTimeAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTimeAck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTimeAck();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverTime = reader.uint32();
                    break;
                case 2:
                    message.serverRealStartTime = reader.uint32();
                    break;
                case 3:
                    message.openDays = reader.int32();
                    break;
                case 4:
                    message.serverRealCombineTime = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTimeAck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTimeAck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTimeAck} PB_SCTimeAck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTimeAck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTimeAck message.
         * @function verify
         * @memberof PB_SCTimeAck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTimeAck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                if (!$util.isInteger(message.serverTime))
                    return "serverTime: integer expected";
            if (message.serverRealStartTime != null && message.hasOwnProperty("serverRealStartTime"))
                if (!$util.isInteger(message.serverRealStartTime))
                    return "serverRealStartTime: integer expected";
            if (message.openDays != null && message.hasOwnProperty("openDays"))
                if (!$util.isInteger(message.openDays))
                    return "openDays: integer expected";
            if (message.serverRealCombineTime != null && message.hasOwnProperty("serverRealCombineTime"))
                if (!$util.isInteger(message.serverRealCombineTime))
                    return "serverRealCombineTime: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCTimeAck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTimeAck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTimeAck} PB_SCTimeAck
         */
        PB_SCTimeAck.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTimeAck)
                return object;
            var message = new $root.PB_SCTimeAck();
            if (object.serverTime != null)
                message.serverTime = object.serverTime >>> 0;
            if (object.serverRealStartTime != null)
                message.serverRealStartTime = object.serverRealStartTime >>> 0;
            if (object.openDays != null)
                message.openDays = object.openDays | 0;
            if (object.serverRealCombineTime != null)
                message.serverRealCombineTime = object.serverRealCombineTime >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTimeAck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTimeAck
         * @static
         * @param {PB_SCTimeAck} message PB_SCTimeAck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTimeAck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverTime = 0;
                object.serverRealStartTime = 0;
                object.openDays = 0;
                object.serverRealCombineTime = 0;
            }
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                object.serverTime = message.serverTime;
            if (message.serverRealStartTime != null && message.hasOwnProperty("serverRealStartTime"))
                object.serverRealStartTime = message.serverRealStartTime;
            if (message.openDays != null && message.hasOwnProperty("openDays"))
                object.openDays = message.openDays;
            if (message.serverRealCombineTime != null && message.hasOwnProperty("serverRealCombineTime"))
                object.serverRealCombineTime = message.serverRealCombineTime;
            return object;
        };
    
        /**
         * Converts this PB_SCTimeAck to JSON.
         * @function toJSON
         * @memberof PB_SCTimeAck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTimeAck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTimeAck;
    })();
    
    $root.PB_SCDisconnectNotice = (function() {
    
        /**
         * Properties of a PB_SCDisconnectNotice.
         * @exports IPB_SCDisconnectNotice
         * @interface IPB_SCDisconnectNotice
         * @property {number|null} [reason] PB_SCDisconnectNotice reason
         * @property {number|null} [roleId] PB_SCDisconnectNotice roleId
         * @property {string|null} [userName] PB_SCDisconnectNotice userName
         */
    
        /**
         * Constructs a new PB_SCDisconnectNotice.
         * @exports PB_SCDisconnectNotice
         * @classdesc Represents a PB_SCDisconnectNotice.
         * @implements IPB_SCDisconnectNotice
         * @constructor
         * @param {IPB_SCDisconnectNotice=} [properties] Properties to set
         */
        function PB_SCDisconnectNotice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCDisconnectNotice reason.
         * @member {number} reason
         * @memberof PB_SCDisconnectNotice
         * @instance
         */
        PB_SCDisconnectNotice.prototype.reason = 0;
    
        /**
         * PB_SCDisconnectNotice roleId.
         * @member {number} roleId
         * @memberof PB_SCDisconnectNotice
         * @instance
         */
        PB_SCDisconnectNotice.prototype.roleId = 0;
    
        /**
         * PB_SCDisconnectNotice userName.
         * @member {string} userName
         * @memberof PB_SCDisconnectNotice
         * @instance
         */
        PB_SCDisconnectNotice.prototype.userName = "";
    
        /**
         * Creates a new PB_SCDisconnectNotice instance using the specified properties.
         * @function create
         * @memberof PB_SCDisconnectNotice
         * @static
         * @param {IPB_SCDisconnectNotice=} [properties] Properties to set
         * @returns {PB_SCDisconnectNotice} PB_SCDisconnectNotice instance
         */
        PB_SCDisconnectNotice.create = function create(properties) {
            return new PB_SCDisconnectNotice(properties);
        };
    
        /**
         * Encodes the specified PB_SCDisconnectNotice message. Does not implicitly {@link PB_SCDisconnectNotice.verify|verify} messages.
         * @function encode
         * @memberof PB_SCDisconnectNotice
         * @static
         * @param {IPB_SCDisconnectNotice} message PB_SCDisconnectNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCDisconnectNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reason);
            if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.roleId);
            if (message.userName != null && Object.hasOwnProperty.call(message, "userName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.userName);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCDisconnectNotice message, length delimited. Does not implicitly {@link PB_SCDisconnectNotice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCDisconnectNotice
         * @static
         * @param {IPB_SCDisconnectNotice} message PB_SCDisconnectNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCDisconnectNotice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCDisconnectNotice message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCDisconnectNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCDisconnectNotice} PB_SCDisconnectNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCDisconnectNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCDisconnectNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.int32();
                    break;
                case 2:
                    message.roleId = reader.int32();
                    break;
                case 3:
                    message.userName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCDisconnectNotice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCDisconnectNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCDisconnectNotice} PB_SCDisconnectNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCDisconnectNotice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCDisconnectNotice message.
         * @function verify
         * @memberof PB_SCDisconnectNotice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCDisconnectNotice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isInteger(message.reason))
                    return "reason: integer expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
            if (message.userName != null && message.hasOwnProperty("userName"))
                if (!$util.isString(message.userName))
                    return "userName: string expected";
            return null;
        };
    
        /**
         * Creates a PB_SCDisconnectNotice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCDisconnectNotice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCDisconnectNotice} PB_SCDisconnectNotice
         */
        PB_SCDisconnectNotice.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCDisconnectNotice)
                return object;
            var message = new $root.PB_SCDisconnectNotice();
            if (object.reason != null)
                message.reason = object.reason | 0;
            if (object.roleId != null)
                message.roleId = object.roleId | 0;
            if (object.userName != null)
                message.userName = String(object.userName);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCDisconnectNotice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCDisconnectNotice
         * @static
         * @param {PB_SCDisconnectNotice} message PB_SCDisconnectNotice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCDisconnectNotice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reason = 0;
                object.roleId = 0;
                object.userName = "";
            }
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                object.roleId = message.roleId;
            if (message.userName != null && message.hasOwnProperty("userName"))
                object.userName = message.userName;
            return object;
        };
    
        /**
         * Converts this PB_SCDisconnectNotice to JSON.
         * @function toJSON
         * @memberof PB_SCDisconnectNotice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCDisconnectNotice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCDisconnectNotice;
    })();
    
    $root.PB_SCTimeDateInfo = (function() {
    
        /**
         * Properties of a PB_SCTimeDateInfo.
         * @exports IPB_SCTimeDateInfo
         * @interface IPB_SCTimeDateInfo
         * @property {number|null} [time] PB_SCTimeDateInfo time
         * @property {number|null} [year] PB_SCTimeDateInfo year
         * @property {number|null} [mon] PB_SCTimeDateInfo mon
         * @property {number|null} [day] PB_SCTimeDateInfo day
         * @property {number|null} [hour] PB_SCTimeDateInfo hour
         * @property {number|null} [minute] PB_SCTimeDateInfo minute
         * @property {number|null} [second] PB_SCTimeDateInfo second
         */
    
        /**
         * Constructs a new PB_SCTimeDateInfo.
         * @exports PB_SCTimeDateInfo
         * @classdesc Represents a PB_SCTimeDateInfo.
         * @implements IPB_SCTimeDateInfo
         * @constructor
         * @param {IPB_SCTimeDateInfo=} [properties] Properties to set
         */
        function PB_SCTimeDateInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTimeDateInfo time.
         * @member {number} time
         * @memberof PB_SCTimeDateInfo
         * @instance
         */
        PB_SCTimeDateInfo.prototype.time = 0;
    
        /**
         * PB_SCTimeDateInfo year.
         * @member {number} year
         * @memberof PB_SCTimeDateInfo
         * @instance
         */
        PB_SCTimeDateInfo.prototype.year = 0;
    
        /**
         * PB_SCTimeDateInfo mon.
         * @member {number} mon
         * @memberof PB_SCTimeDateInfo
         * @instance
         */
        PB_SCTimeDateInfo.prototype.mon = 0;
    
        /**
         * PB_SCTimeDateInfo day.
         * @member {number} day
         * @memberof PB_SCTimeDateInfo
         * @instance
         */
        PB_SCTimeDateInfo.prototype.day = 0;
    
        /**
         * PB_SCTimeDateInfo hour.
         * @member {number} hour
         * @memberof PB_SCTimeDateInfo
         * @instance
         */
        PB_SCTimeDateInfo.prototype.hour = 0;
    
        /**
         * PB_SCTimeDateInfo minute.
         * @member {number} minute
         * @memberof PB_SCTimeDateInfo
         * @instance
         */
        PB_SCTimeDateInfo.prototype.minute = 0;
    
        /**
         * PB_SCTimeDateInfo second.
         * @member {number} second
         * @memberof PB_SCTimeDateInfo
         * @instance
         */
        PB_SCTimeDateInfo.prototype.second = 0;
    
        /**
         * Creates a new PB_SCTimeDateInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCTimeDateInfo
         * @static
         * @param {IPB_SCTimeDateInfo=} [properties] Properties to set
         * @returns {PB_SCTimeDateInfo} PB_SCTimeDateInfo instance
         */
        PB_SCTimeDateInfo.create = function create(properties) {
            return new PB_SCTimeDateInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCTimeDateInfo message. Does not implicitly {@link PB_SCTimeDateInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTimeDateInfo
         * @static
         * @param {IPB_SCTimeDateInfo} message PB_SCTimeDateInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTimeDateInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.time);
            if (message.year != null && Object.hasOwnProperty.call(message, "year"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.year);
            if (message.mon != null && Object.hasOwnProperty.call(message, "mon"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.mon);
            if (message.day != null && Object.hasOwnProperty.call(message, "day"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.day);
            if (message.hour != null && Object.hasOwnProperty.call(message, "hour"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.hour);
            if (message.minute != null && Object.hasOwnProperty.call(message, "minute"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.minute);
            if (message.second != null && Object.hasOwnProperty.call(message, "second"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.second);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTimeDateInfo message, length delimited. Does not implicitly {@link PB_SCTimeDateInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTimeDateInfo
         * @static
         * @param {IPB_SCTimeDateInfo} message PB_SCTimeDateInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTimeDateInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTimeDateInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTimeDateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTimeDateInfo} PB_SCTimeDateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTimeDateInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTimeDateInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.uint32();
                    break;
                case 2:
                    message.year = reader.uint32();
                    break;
                case 3:
                    message.mon = reader.uint32();
                    break;
                case 4:
                    message.day = reader.uint32();
                    break;
                case 5:
                    message.hour = reader.uint32();
                    break;
                case 6:
                    message.minute = reader.uint32();
                    break;
                case 7:
                    message.second = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTimeDateInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTimeDateInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTimeDateInfo} PB_SCTimeDateInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTimeDateInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTimeDateInfo message.
         * @function verify
         * @memberof PB_SCTimeDateInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTimeDateInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.year != null && message.hasOwnProperty("year"))
                if (!$util.isInteger(message.year))
                    return "year: integer expected";
            if (message.mon != null && message.hasOwnProperty("mon"))
                if (!$util.isInteger(message.mon))
                    return "mon: integer expected";
            if (message.day != null && message.hasOwnProperty("day"))
                if (!$util.isInteger(message.day))
                    return "day: integer expected";
            if (message.hour != null && message.hasOwnProperty("hour"))
                if (!$util.isInteger(message.hour))
                    return "hour: integer expected";
            if (message.minute != null && message.hasOwnProperty("minute"))
                if (!$util.isInteger(message.minute))
                    return "minute: integer expected";
            if (message.second != null && message.hasOwnProperty("second"))
                if (!$util.isInteger(message.second))
                    return "second: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCTimeDateInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTimeDateInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTimeDateInfo} PB_SCTimeDateInfo
         */
        PB_SCTimeDateInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTimeDateInfo)
                return object;
            var message = new $root.PB_SCTimeDateInfo();
            if (object.time != null)
                message.time = object.time >>> 0;
            if (object.year != null)
                message.year = object.year >>> 0;
            if (object.mon != null)
                message.mon = object.mon >>> 0;
            if (object.day != null)
                message.day = object.day >>> 0;
            if (object.hour != null)
                message.hour = object.hour >>> 0;
            if (object.minute != null)
                message.minute = object.minute >>> 0;
            if (object.second != null)
                message.second = object.second >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTimeDateInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTimeDateInfo
         * @static
         * @param {PB_SCTimeDateInfo} message PB_SCTimeDateInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTimeDateInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = 0;
                object.year = 0;
                object.mon = 0;
                object.day = 0;
                object.hour = 0;
                object.minute = 0;
                object.second = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.year != null && message.hasOwnProperty("year"))
                object.year = message.year;
            if (message.mon != null && message.hasOwnProperty("mon"))
                object.mon = message.mon;
            if (message.day != null && message.hasOwnProperty("day"))
                object.day = message.day;
            if (message.hour != null && message.hasOwnProperty("hour"))
                object.hour = message.hour;
            if (message.minute != null && message.hasOwnProperty("minute"))
                object.minute = message.minute;
            if (message.second != null && message.hasOwnProperty("second"))
                object.second = message.second;
            return object;
        };
    
        /**
         * Converts this PB_SCTimeDateInfo to JSON.
         * @function toJSON
         * @memberof PB_SCTimeDateInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTimeDateInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTimeDateInfo;
    })();
    
    $root.PB_SCCrossConnectInfo = (function() {
    
        /**
         * Properties of a PB_SCCrossConnectInfo.
         * @exports IPB_SCCrossConnectInfo
         * @interface IPB_SCCrossConnectInfo
         * @property {number|null} [isConnectedCross] PB_SCCrossConnectInfo isConnectedCross
         * @property {number|null} [isCross] PB_SCCrossConnectInfo isCross
         */
    
        /**
         * Constructs a new PB_SCCrossConnectInfo.
         * @exports PB_SCCrossConnectInfo
         * @classdesc Represents a PB_SCCrossConnectInfo.
         * @implements IPB_SCCrossConnectInfo
         * @constructor
         * @param {IPB_SCCrossConnectInfo=} [properties] Properties to set
         */
        function PB_SCCrossConnectInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCCrossConnectInfo isConnectedCross.
         * @member {number} isConnectedCross
         * @memberof PB_SCCrossConnectInfo
         * @instance
         */
        PB_SCCrossConnectInfo.prototype.isConnectedCross = 0;
    
        /**
         * PB_SCCrossConnectInfo isCross.
         * @member {number} isCross
         * @memberof PB_SCCrossConnectInfo
         * @instance
         */
        PB_SCCrossConnectInfo.prototype.isCross = 0;
    
        /**
         * Creates a new PB_SCCrossConnectInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCCrossConnectInfo
         * @static
         * @param {IPB_SCCrossConnectInfo=} [properties] Properties to set
         * @returns {PB_SCCrossConnectInfo} PB_SCCrossConnectInfo instance
         */
        PB_SCCrossConnectInfo.create = function create(properties) {
            return new PB_SCCrossConnectInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCCrossConnectInfo message. Does not implicitly {@link PB_SCCrossConnectInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCCrossConnectInfo
         * @static
         * @param {IPB_SCCrossConnectInfo} message PB_SCCrossConnectInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCCrossConnectInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isConnectedCross != null && Object.hasOwnProperty.call(message, "isConnectedCross"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.isConnectedCross);
            if (message.isCross != null && Object.hasOwnProperty.call(message, "isCross"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.isCross);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCCrossConnectInfo message, length delimited. Does not implicitly {@link PB_SCCrossConnectInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCCrossConnectInfo
         * @static
         * @param {IPB_SCCrossConnectInfo} message PB_SCCrossConnectInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCCrossConnectInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCCrossConnectInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCCrossConnectInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCCrossConnectInfo} PB_SCCrossConnectInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCCrossConnectInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCCrossConnectInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isConnectedCross = reader.int32();
                    break;
                case 2:
                    message.isCross = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCCrossConnectInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCCrossConnectInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCCrossConnectInfo} PB_SCCrossConnectInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCCrossConnectInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCCrossConnectInfo message.
         * @function verify
         * @memberof PB_SCCrossConnectInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCCrossConnectInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isConnectedCross != null && message.hasOwnProperty("isConnectedCross"))
                if (!$util.isInteger(message.isConnectedCross))
                    return "isConnectedCross: integer expected";
            if (message.isCross != null && message.hasOwnProperty("isCross"))
                if (!$util.isInteger(message.isCross))
                    return "isCross: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCCrossConnectInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCCrossConnectInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCCrossConnectInfo} PB_SCCrossConnectInfo
         */
        PB_SCCrossConnectInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCCrossConnectInfo)
                return object;
            var message = new $root.PB_SCCrossConnectInfo();
            if (object.isConnectedCross != null)
                message.isConnectedCross = object.isConnectedCross | 0;
            if (object.isCross != null)
                message.isCross = object.isCross | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCCrossConnectInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCCrossConnectInfo
         * @static
         * @param {PB_SCCrossConnectInfo} message PB_SCCrossConnectInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCCrossConnectInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.isConnectedCross = 0;
                object.isCross = 0;
            }
            if (message.isConnectedCross != null && message.hasOwnProperty("isConnectedCross"))
                object.isConnectedCross = message.isConnectedCross;
            if (message.isCross != null && message.hasOwnProperty("isCross"))
                object.isCross = message.isCross;
            return object;
        };
    
        /**
         * Converts this PB_SCCrossConnectInfo to JSON.
         * @function toJSON
         * @memberof PB_SCCrossConnectInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCCrossConnectInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCCrossConnectInfo;
    })();
    
    $root.PB_CSTimeReq = (function() {
    
        /**
         * Properties of a PB_CSTimeReq.
         * @exports IPB_CSTimeReq
         * @interface IPB_CSTimeReq
         * @property {number|null} [reserve] PB_CSTimeReq reserve
         */
    
        /**
         * Constructs a new PB_CSTimeReq.
         * @exports PB_CSTimeReq
         * @classdesc Represents a PB_CSTimeReq.
         * @implements IPB_CSTimeReq
         * @constructor
         * @param {IPB_CSTimeReq=} [properties] Properties to set
         */
        function PB_CSTimeReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSTimeReq reserve.
         * @member {number} reserve
         * @memberof PB_CSTimeReq
         * @instance
         */
        PB_CSTimeReq.prototype.reserve = 0;
    
        /**
         * Creates a new PB_CSTimeReq instance using the specified properties.
         * @function create
         * @memberof PB_CSTimeReq
         * @static
         * @param {IPB_CSTimeReq=} [properties] Properties to set
         * @returns {PB_CSTimeReq} PB_CSTimeReq instance
         */
        PB_CSTimeReq.create = function create(properties) {
            return new PB_CSTimeReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSTimeReq message. Does not implicitly {@link PB_CSTimeReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSTimeReq
         * @static
         * @param {IPB_CSTimeReq} message PB_CSTimeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSTimeReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reserve != null && Object.hasOwnProperty.call(message, "reserve"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reserve);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSTimeReq message, length delimited. Does not implicitly {@link PB_CSTimeReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSTimeReq
         * @static
         * @param {IPB_CSTimeReq} message PB_CSTimeReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSTimeReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSTimeReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSTimeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSTimeReq} PB_CSTimeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSTimeReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSTimeReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reserve = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSTimeReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSTimeReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSTimeReq} PB_CSTimeReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSTimeReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSTimeReq message.
         * @function verify
         * @memberof PB_CSTimeReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSTimeReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                if (!$util.isInteger(message.reserve))
                    return "reserve: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSTimeReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSTimeReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSTimeReq} PB_CSTimeReq
         */
        PB_CSTimeReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSTimeReq)
                return object;
            var message = new $root.PB_CSTimeReq();
            if (object.reserve != null)
                message.reserve = object.reserve | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSTimeReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSTimeReq
         * @static
         * @param {PB_CSTimeReq} message PB_CSTimeReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSTimeReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reserve = 0;
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                object.reserve = message.reserve;
            return object;
        };
    
        /**
         * Converts this PB_CSTimeReq to JSON.
         * @function toJSON
         * @memberof PB_CSTimeReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSTimeReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSTimeReq;
    })();
    
    $root.PB_CSSevenDayHeroReq = (function() {
    
        /**
         * Properties of a PB_CSSevenDayHeroReq.
         * @exports IPB_CSSevenDayHeroReq
         * @interface IPB_CSSevenDayHeroReq
         * @property {number|null} [reqType] PB_CSSevenDayHeroReq reqType
         * @property {number|null} [p1] PB_CSSevenDayHeroReq p1
         */
    
        /**
         * Constructs a new PB_CSSevenDayHeroReq.
         * @exports PB_CSSevenDayHeroReq
         * @classdesc Represents a PB_CSSevenDayHeroReq.
         * @implements IPB_CSSevenDayHeroReq
         * @constructor
         * @param {IPB_CSSevenDayHeroReq=} [properties] Properties to set
         */
        function PB_CSSevenDayHeroReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSSevenDayHeroReq reqType.
         * @member {number} reqType
         * @memberof PB_CSSevenDayHeroReq
         * @instance
         */
        PB_CSSevenDayHeroReq.prototype.reqType = 0;
    
        /**
         * PB_CSSevenDayHeroReq p1.
         * @member {number} p1
         * @memberof PB_CSSevenDayHeroReq
         * @instance
         */
        PB_CSSevenDayHeroReq.prototype.p1 = 0;
    
        /**
         * Creates a new PB_CSSevenDayHeroReq instance using the specified properties.
         * @function create
         * @memberof PB_CSSevenDayHeroReq
         * @static
         * @param {IPB_CSSevenDayHeroReq=} [properties] Properties to set
         * @returns {PB_CSSevenDayHeroReq} PB_CSSevenDayHeroReq instance
         */
        PB_CSSevenDayHeroReq.create = function create(properties) {
            return new PB_CSSevenDayHeroReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSSevenDayHeroReq message. Does not implicitly {@link PB_CSSevenDayHeroReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSSevenDayHeroReq
         * @static
         * @param {IPB_CSSevenDayHeroReq} message PB_CSSevenDayHeroReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSSevenDayHeroReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.p1 != null && Object.hasOwnProperty.call(message, "p1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.p1);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSSevenDayHeroReq message, length delimited. Does not implicitly {@link PB_CSSevenDayHeroReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSSevenDayHeroReq
         * @static
         * @param {IPB_CSSevenDayHeroReq} message PB_CSSevenDayHeroReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSSevenDayHeroReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSSevenDayHeroReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSSevenDayHeroReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSSevenDayHeroReq} PB_CSSevenDayHeroReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSSevenDayHeroReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSSevenDayHeroReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    message.p1 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSSevenDayHeroReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSSevenDayHeroReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSSevenDayHeroReq} PB_CSSevenDayHeroReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSSevenDayHeroReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSSevenDayHeroReq message.
         * @function verify
         * @memberof PB_CSSevenDayHeroReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSSevenDayHeroReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.p1 != null && message.hasOwnProperty("p1"))
                if (!$util.isInteger(message.p1))
                    return "p1: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_CSSevenDayHeroReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSSevenDayHeroReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSSevenDayHeroReq} PB_CSSevenDayHeroReq
         */
        PB_CSSevenDayHeroReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSSevenDayHeroReq)
                return object;
            var message = new $root.PB_CSSevenDayHeroReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.p1 != null)
                message.p1 = object.p1 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSSevenDayHeroReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSSevenDayHeroReq
         * @static
         * @param {PB_CSSevenDayHeroReq} message PB_CSSevenDayHeroReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSSevenDayHeroReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.reqType = 0;
                object.p1 = 0;
            }
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = message.p1;
            return object;
        };
    
        /**
         * Converts this PB_CSSevenDayHeroReq to JSON.
         * @function toJSON
         * @memberof PB_CSSevenDayHeroReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSSevenDayHeroReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSSevenDayHeroReq;
    })();
    
    $root.PB_SCSevenDayHeroInfo = (function() {
    
        /**
         * Properties of a PB_SCSevenDayHeroInfo.
         * @exports IPB_SCSevenDayHeroInfo
         * @interface IPB_SCSevenDayHeroInfo
         * @property {number|null} [fetchRewardTimes] PB_SCSevenDayHeroInfo fetchRewardTimes
         * @property {number|null} [expiryTime] PB_SCSevenDayHeroInfo expiryTime
         * @property {Array.<number>|null} [heroId] PB_SCSevenDayHeroInfo heroId
         */
    
        /**
         * Constructs a new PB_SCSevenDayHeroInfo.
         * @exports PB_SCSevenDayHeroInfo
         * @classdesc Represents a PB_SCSevenDayHeroInfo.
         * @implements IPB_SCSevenDayHeroInfo
         * @constructor
         * @param {IPB_SCSevenDayHeroInfo=} [properties] Properties to set
         */
        function PB_SCSevenDayHeroInfo(properties) {
            this.heroId = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCSevenDayHeroInfo fetchRewardTimes.
         * @member {number} fetchRewardTimes
         * @memberof PB_SCSevenDayHeroInfo
         * @instance
         */
        PB_SCSevenDayHeroInfo.prototype.fetchRewardTimes = 0;
    
        /**
         * PB_SCSevenDayHeroInfo expiryTime.
         * @member {number} expiryTime
         * @memberof PB_SCSevenDayHeroInfo
         * @instance
         */
        PB_SCSevenDayHeroInfo.prototype.expiryTime = 0;
    
        /**
         * PB_SCSevenDayHeroInfo heroId.
         * @member {Array.<number>} heroId
         * @memberof PB_SCSevenDayHeroInfo
         * @instance
         */
        PB_SCSevenDayHeroInfo.prototype.heroId = $util.emptyArray;
    
        /**
         * Creates a new PB_SCSevenDayHeroInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCSevenDayHeroInfo
         * @static
         * @param {IPB_SCSevenDayHeroInfo=} [properties] Properties to set
         * @returns {PB_SCSevenDayHeroInfo} PB_SCSevenDayHeroInfo instance
         */
        PB_SCSevenDayHeroInfo.create = function create(properties) {
            return new PB_SCSevenDayHeroInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCSevenDayHeroInfo message. Does not implicitly {@link PB_SCSevenDayHeroInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCSevenDayHeroInfo
         * @static
         * @param {IPB_SCSevenDayHeroInfo} message PB_SCSevenDayHeroInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCSevenDayHeroInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fetchRewardTimes != null && Object.hasOwnProperty.call(message, "fetchRewardTimes"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fetchRewardTimes);
            if (message.expiryTime != null && Object.hasOwnProperty.call(message, "expiryTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.expiryTime);
            if (message.heroId != null && message.heroId.length)
                for (var i = 0; i < message.heroId.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.heroId[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCSevenDayHeroInfo message, length delimited. Does not implicitly {@link PB_SCSevenDayHeroInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCSevenDayHeroInfo
         * @static
         * @param {IPB_SCSevenDayHeroInfo} message PB_SCSevenDayHeroInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCSevenDayHeroInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCSevenDayHeroInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCSevenDayHeroInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCSevenDayHeroInfo} PB_SCSevenDayHeroInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCSevenDayHeroInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCSevenDayHeroInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fetchRewardTimes = reader.int32();
                    break;
                case 2:
                    message.expiryTime = reader.uint32();
                    break;
                case 3:
                    if (!(message.heroId && message.heroId.length))
                        message.heroId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.heroId.push(reader.int32());
                    } else
                        message.heroId.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCSevenDayHeroInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCSevenDayHeroInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCSevenDayHeroInfo} PB_SCSevenDayHeroInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCSevenDayHeroInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCSevenDayHeroInfo message.
         * @function verify
         * @memberof PB_SCSevenDayHeroInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCSevenDayHeroInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fetchRewardTimes != null && message.hasOwnProperty("fetchRewardTimes"))
                if (!$util.isInteger(message.fetchRewardTimes))
                    return "fetchRewardTimes: integer expected";
            if (message.expiryTime != null && message.hasOwnProperty("expiryTime"))
                if (!$util.isInteger(message.expiryTime))
                    return "expiryTime: integer expected";
            if (message.heroId != null && message.hasOwnProperty("heroId")) {
                if (!Array.isArray(message.heroId))
                    return "heroId: array expected";
                for (var i = 0; i < message.heroId.length; ++i)
                    if (!$util.isInteger(message.heroId[i]))
                        return "heroId: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCSevenDayHeroInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCSevenDayHeroInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCSevenDayHeroInfo} PB_SCSevenDayHeroInfo
         */
        PB_SCSevenDayHeroInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCSevenDayHeroInfo)
                return object;
            var message = new $root.PB_SCSevenDayHeroInfo();
            if (object.fetchRewardTimes != null)
                message.fetchRewardTimes = object.fetchRewardTimes | 0;
            if (object.expiryTime != null)
                message.expiryTime = object.expiryTime >>> 0;
            if (object.heroId) {
                if (!Array.isArray(object.heroId))
                    throw TypeError(".PB_SCSevenDayHeroInfo.heroId: array expected");
                message.heroId = [];
                for (var i = 0; i < object.heroId.length; ++i)
                    message.heroId[i] = object.heroId[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCSevenDayHeroInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCSevenDayHeroInfo
         * @static
         * @param {PB_SCSevenDayHeroInfo} message PB_SCSevenDayHeroInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCSevenDayHeroInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.heroId = [];
            if (options.defaults) {
                object.fetchRewardTimes = 0;
                object.expiryTime = 0;
            }
            if (message.fetchRewardTimes != null && message.hasOwnProperty("fetchRewardTimes"))
                object.fetchRewardTimes = message.fetchRewardTimes;
            if (message.expiryTime != null && message.hasOwnProperty("expiryTime"))
                object.expiryTime = message.expiryTime;
            if (message.heroId && message.heroId.length) {
                object.heroId = [];
                for (var j = 0; j < message.heroId.length; ++j)
                    object.heroId[j] = message.heroId[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCSevenDayHeroInfo to JSON.
         * @function toJSON
         * @memberof PB_SCSevenDayHeroInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCSevenDayHeroInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCSevenDayHeroInfo;
    })();
    
    $root.PB_CSShopBoxReq = (function() {
    
        /**
         * Properties of a PB_CSShopBoxReq.
         * @exports IPB_CSShopBoxReq
         * @interface IPB_CSShopBoxReq
         * @property {number|null} [reqType] PB_CSShopBoxReq reqType
         * @property {Array.<number>|null} [paramList] PB_CSShopBoxReq paramList
         */
    
        /**
         * Constructs a new PB_CSShopBoxReq.
         * @exports PB_CSShopBoxReq
         * @classdesc Represents a PB_CSShopBoxReq.
         * @implements IPB_CSShopBoxReq
         * @constructor
         * @param {IPB_CSShopBoxReq=} [properties] Properties to set
         */
        function PB_CSShopBoxReq(properties) {
            this.paramList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSShopBoxReq reqType.
         * @member {number} reqType
         * @memberof PB_CSShopBoxReq
         * @instance
         */
        PB_CSShopBoxReq.prototype.reqType = 0;
    
        /**
         * PB_CSShopBoxReq paramList.
         * @member {Array.<number>} paramList
         * @memberof PB_CSShopBoxReq
         * @instance
         */
        PB_CSShopBoxReq.prototype.paramList = $util.emptyArray;
    
        /**
         * Creates a new PB_CSShopBoxReq instance using the specified properties.
         * @function create
         * @memberof PB_CSShopBoxReq
         * @static
         * @param {IPB_CSShopBoxReq=} [properties] Properties to set
         * @returns {PB_CSShopBoxReq} PB_CSShopBoxReq instance
         */
        PB_CSShopBoxReq.create = function create(properties) {
            return new PB_CSShopBoxReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSShopBoxReq message. Does not implicitly {@link PB_CSShopBoxReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSShopBoxReq
         * @static
         * @param {IPB_CSShopBoxReq} message PB_CSShopBoxReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSShopBoxReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.paramList != null && message.paramList.length)
                for (var i = 0; i < message.paramList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.paramList[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSShopBoxReq message, length delimited. Does not implicitly {@link PB_CSShopBoxReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSShopBoxReq
         * @static
         * @param {IPB_CSShopBoxReq} message PB_CSShopBoxReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSShopBoxReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSShopBoxReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSShopBoxReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSShopBoxReq} PB_CSShopBoxReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSShopBoxReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSShopBoxReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    if (!(message.paramList && message.paramList.length))
                        message.paramList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.paramList.push(reader.int32());
                    } else
                        message.paramList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSShopBoxReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSShopBoxReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSShopBoxReq} PB_CSShopBoxReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSShopBoxReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSShopBoxReq message.
         * @function verify
         * @memberof PB_CSShopBoxReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSShopBoxReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.paramList != null && message.hasOwnProperty("paramList")) {
                if (!Array.isArray(message.paramList))
                    return "paramList: array expected";
                for (var i = 0; i < message.paramList.length; ++i)
                    if (!$util.isInteger(message.paramList[i]))
                        return "paramList: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSShopBoxReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSShopBoxReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSShopBoxReq} PB_CSShopBoxReq
         */
        PB_CSShopBoxReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSShopBoxReq)
                return object;
            var message = new $root.PB_CSShopBoxReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.paramList) {
                if (!Array.isArray(object.paramList))
                    throw TypeError(".PB_CSShopBoxReq.paramList: array expected");
                message.paramList = [];
                for (var i = 0; i < object.paramList.length; ++i)
                    message.paramList[i] = object.paramList[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSShopBoxReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSShopBoxReq
         * @static
         * @param {PB_CSShopBoxReq} message PB_CSShopBoxReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSShopBoxReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.paramList = [];
            if (options.defaults)
                object.reqType = 0;
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.paramList && message.paramList.length) {
                object.paramList = [];
                for (var j = 0; j < message.paramList.length; ++j)
                    object.paramList[j] = message.paramList[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSShopBoxReq to JSON.
         * @function toJSON
         * @memberof PB_CSShopBoxReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSShopBoxReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSShopBoxReq;
    })();
    
    $root.PB_SCShopBoxInfo = (function() {
    
        /**
         * Properties of a PB_SCShopBoxInfo.
         * @exports IPB_SCShopBoxInfo
         * @interface IPB_SCShopBoxInfo
         * @property {number|null} [boxLevel] PB_SCShopBoxInfo boxLevel
         * @property {number|null} [boxExp] PB_SCShopBoxInfo boxExp
         */
    
        /**
         * Constructs a new PB_SCShopBoxInfo.
         * @exports PB_SCShopBoxInfo
         * @classdesc Represents a PB_SCShopBoxInfo.
         * @implements IPB_SCShopBoxInfo
         * @constructor
         * @param {IPB_SCShopBoxInfo=} [properties] Properties to set
         */
        function PB_SCShopBoxInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCShopBoxInfo boxLevel.
         * @member {number} boxLevel
         * @memberof PB_SCShopBoxInfo
         * @instance
         */
        PB_SCShopBoxInfo.prototype.boxLevel = 0;
    
        /**
         * PB_SCShopBoxInfo boxExp.
         * @member {number} boxExp
         * @memberof PB_SCShopBoxInfo
         * @instance
         */
        PB_SCShopBoxInfo.prototype.boxExp = 0;
    
        /**
         * Creates a new PB_SCShopBoxInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCShopBoxInfo
         * @static
         * @param {IPB_SCShopBoxInfo=} [properties] Properties to set
         * @returns {PB_SCShopBoxInfo} PB_SCShopBoxInfo instance
         */
        PB_SCShopBoxInfo.create = function create(properties) {
            return new PB_SCShopBoxInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCShopBoxInfo message. Does not implicitly {@link PB_SCShopBoxInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCShopBoxInfo
         * @static
         * @param {IPB_SCShopBoxInfo} message PB_SCShopBoxInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCShopBoxInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.boxLevel != null && Object.hasOwnProperty.call(message, "boxLevel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.boxLevel);
            if (message.boxExp != null && Object.hasOwnProperty.call(message, "boxExp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.boxExp);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCShopBoxInfo message, length delimited. Does not implicitly {@link PB_SCShopBoxInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCShopBoxInfo
         * @static
         * @param {IPB_SCShopBoxInfo} message PB_SCShopBoxInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCShopBoxInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCShopBoxInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCShopBoxInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCShopBoxInfo} PB_SCShopBoxInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCShopBoxInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCShopBoxInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.boxLevel = reader.int32();
                    break;
                case 2:
                    message.boxExp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCShopBoxInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCShopBoxInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCShopBoxInfo} PB_SCShopBoxInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCShopBoxInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCShopBoxInfo message.
         * @function verify
         * @memberof PB_SCShopBoxInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCShopBoxInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.boxLevel != null && message.hasOwnProperty("boxLevel"))
                if (!$util.isInteger(message.boxLevel))
                    return "boxLevel: integer expected";
            if (message.boxExp != null && message.hasOwnProperty("boxExp"))
                if (!$util.isInteger(message.boxExp))
                    return "boxExp: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCShopBoxInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCShopBoxInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCShopBoxInfo} PB_SCShopBoxInfo
         */
        PB_SCShopBoxInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCShopBoxInfo)
                return object;
            var message = new $root.PB_SCShopBoxInfo();
            if (object.boxLevel != null)
                message.boxLevel = object.boxLevel | 0;
            if (object.boxExp != null)
                message.boxExp = object.boxExp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCShopBoxInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCShopBoxInfo
         * @static
         * @param {PB_SCShopBoxInfo} message PB_SCShopBoxInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCShopBoxInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.boxLevel = 0;
                object.boxExp = 0;
            }
            if (message.boxLevel != null && message.hasOwnProperty("boxLevel"))
                object.boxLevel = message.boxLevel;
            if (message.boxExp != null && message.hasOwnProperty("boxExp"))
                object.boxExp = message.boxExp;
            return object;
        };
    
        /**
         * Converts this PB_SCShopBoxInfo to JSON.
         * @function toJSON
         * @memberof PB_SCShopBoxInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCShopBoxInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCShopBoxInfo;
    })();
    
    $root.PB_CSShopReq = (function() {
    
        /**
         * Properties of a PB_CSShopReq.
         * @exports IPB_CSShopReq
         * @interface IPB_CSShopReq
         * @property {number|null} [reqType] PB_CSShopReq reqType
         * @property {Array.<number>|null} [paramList] PB_CSShopReq paramList
         */
    
        /**
         * Constructs a new PB_CSShopReq.
         * @exports PB_CSShopReq
         * @classdesc Represents a PB_CSShopReq.
         * @implements IPB_CSShopReq
         * @constructor
         * @param {IPB_CSShopReq=} [properties] Properties to set
         */
        function PB_CSShopReq(properties) {
            this.paramList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSShopReq reqType.
         * @member {number} reqType
         * @memberof PB_CSShopReq
         * @instance
         */
        PB_CSShopReq.prototype.reqType = 0;
    
        /**
         * PB_CSShopReq paramList.
         * @member {Array.<number>} paramList
         * @memberof PB_CSShopReq
         * @instance
         */
        PB_CSShopReq.prototype.paramList = $util.emptyArray;
    
        /**
         * Creates a new PB_CSShopReq instance using the specified properties.
         * @function create
         * @memberof PB_CSShopReq
         * @static
         * @param {IPB_CSShopReq=} [properties] Properties to set
         * @returns {PB_CSShopReq} PB_CSShopReq instance
         */
        PB_CSShopReq.create = function create(properties) {
            return new PB_CSShopReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSShopReq message. Does not implicitly {@link PB_CSShopReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSShopReq
         * @static
         * @param {IPB_CSShopReq} message PB_CSShopReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSShopReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.paramList != null && message.paramList.length)
                for (var i = 0; i < message.paramList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.paramList[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSShopReq message, length delimited. Does not implicitly {@link PB_CSShopReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSShopReq
         * @static
         * @param {IPB_CSShopReq} message PB_CSShopReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSShopReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSShopReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSShopReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSShopReq} PB_CSShopReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSShopReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSShopReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    if (!(message.paramList && message.paramList.length))
                        message.paramList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.paramList.push(reader.int32());
                    } else
                        message.paramList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSShopReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSShopReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSShopReq} PB_CSShopReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSShopReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSShopReq message.
         * @function verify
         * @memberof PB_CSShopReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSShopReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.paramList != null && message.hasOwnProperty("paramList")) {
                if (!Array.isArray(message.paramList))
                    return "paramList: array expected";
                for (var i = 0; i < message.paramList.length; ++i)
                    if (!$util.isInteger(message.paramList[i]))
                        return "paramList: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSShopReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSShopReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSShopReq} PB_CSShopReq
         */
        PB_CSShopReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSShopReq)
                return object;
            var message = new $root.PB_CSShopReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.paramList) {
                if (!Array.isArray(object.paramList))
                    throw TypeError(".PB_CSShopReq.paramList: array expected");
                message.paramList = [];
                for (var i = 0; i < object.paramList.length; ++i)
                    message.paramList[i] = object.paramList[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSShopReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSShopReq
         * @static
         * @param {PB_CSShopReq} message PB_CSShopReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSShopReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.paramList = [];
            if (options.defaults)
                object.reqType = 0;
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.paramList && message.paramList.length) {
                object.paramList = [];
                for (var j = 0; j < message.paramList.length; ++j)
                    object.paramList[j] = message.paramList[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSShopReq to JSON.
         * @function toJSON
         * @memberof PB_CSShopReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSShopReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSShopReq;
    })();
    
    $root.PB_SCShopNode = (function() {
    
        /**
         * Properties of a PB_SCShopNode.
         * @exports IPB_SCShopNode
         * @interface IPB_SCShopNode
         * @property {number|null} [shopIndex] PB_SCShopNode shopIndex
         * @property {number|null} [buyNum] PB_SCShopNode buyNum
         */
    
        /**
         * Constructs a new PB_SCShopNode.
         * @exports PB_SCShopNode
         * @classdesc Represents a PB_SCShopNode.
         * @implements IPB_SCShopNode
         * @constructor
         * @param {IPB_SCShopNode=} [properties] Properties to set
         */
        function PB_SCShopNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCShopNode shopIndex.
         * @member {number} shopIndex
         * @memberof PB_SCShopNode
         * @instance
         */
        PB_SCShopNode.prototype.shopIndex = 0;
    
        /**
         * PB_SCShopNode buyNum.
         * @member {number} buyNum
         * @memberof PB_SCShopNode
         * @instance
         */
        PB_SCShopNode.prototype.buyNum = 0;
    
        /**
         * Creates a new PB_SCShopNode instance using the specified properties.
         * @function create
         * @memberof PB_SCShopNode
         * @static
         * @param {IPB_SCShopNode=} [properties] Properties to set
         * @returns {PB_SCShopNode} PB_SCShopNode instance
         */
        PB_SCShopNode.create = function create(properties) {
            return new PB_SCShopNode(properties);
        };
    
        /**
         * Encodes the specified PB_SCShopNode message. Does not implicitly {@link PB_SCShopNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SCShopNode
         * @static
         * @param {IPB_SCShopNode} message PB_SCShopNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCShopNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.shopIndex != null && Object.hasOwnProperty.call(message, "shopIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.shopIndex);
            if (message.buyNum != null && Object.hasOwnProperty.call(message, "buyNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buyNum);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCShopNode message, length delimited. Does not implicitly {@link PB_SCShopNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCShopNode
         * @static
         * @param {IPB_SCShopNode} message PB_SCShopNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCShopNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCShopNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCShopNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCShopNode} PB_SCShopNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCShopNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCShopNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.shopIndex = reader.int32();
                    break;
                case 2:
                    message.buyNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCShopNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCShopNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCShopNode} PB_SCShopNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCShopNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCShopNode message.
         * @function verify
         * @memberof PB_SCShopNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCShopNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.shopIndex != null && message.hasOwnProperty("shopIndex"))
                if (!$util.isInteger(message.shopIndex))
                    return "shopIndex: integer expected";
            if (message.buyNum != null && message.hasOwnProperty("buyNum"))
                if (!$util.isInteger(message.buyNum))
                    return "buyNum: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCShopNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCShopNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCShopNode} PB_SCShopNode
         */
        PB_SCShopNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCShopNode)
                return object;
            var message = new $root.PB_SCShopNode();
            if (object.shopIndex != null)
                message.shopIndex = object.shopIndex | 0;
            if (object.buyNum != null)
                message.buyNum = object.buyNum | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCShopNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCShopNode
         * @static
         * @param {PB_SCShopNode} message PB_SCShopNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCShopNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.shopIndex = 0;
                object.buyNum = 0;
            }
            if (message.shopIndex != null && message.hasOwnProperty("shopIndex"))
                object.shopIndex = message.shopIndex;
            if (message.buyNum != null && message.hasOwnProperty("buyNum"))
                object.buyNum = message.buyNum;
            return object;
        };
    
        /**
         * Converts this PB_SCShopNode to JSON.
         * @function toJSON
         * @memberof PB_SCShopNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCShopNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCShopNode;
    })();
    
    $root.PB_SCShopInfo = (function() {
    
        /**
         * Properties of a PB_SCShopInfo.
         * @exports IPB_SCShopInfo
         * @interface IPB_SCShopInfo
         * @property {number|null} [sendType] PB_SCShopInfo sendType
         * @property {Array.<IPB_SCShopNode>|null} [shopList] PB_SCShopInfo shopList
         */
    
        /**
         * Constructs a new PB_SCShopInfo.
         * @exports PB_SCShopInfo
         * @classdesc Represents a PB_SCShopInfo.
         * @implements IPB_SCShopInfo
         * @constructor
         * @param {IPB_SCShopInfo=} [properties] Properties to set
         */
        function PB_SCShopInfo(properties) {
            this.shopList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCShopInfo sendType.
         * @member {number} sendType
         * @memberof PB_SCShopInfo
         * @instance
         */
        PB_SCShopInfo.prototype.sendType = 0;
    
        /**
         * PB_SCShopInfo shopList.
         * @member {Array.<IPB_SCShopNode>} shopList
         * @memberof PB_SCShopInfo
         * @instance
         */
        PB_SCShopInfo.prototype.shopList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCShopInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCShopInfo
         * @static
         * @param {IPB_SCShopInfo=} [properties] Properties to set
         * @returns {PB_SCShopInfo} PB_SCShopInfo instance
         */
        PB_SCShopInfo.create = function create(properties) {
            return new PB_SCShopInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCShopInfo message. Does not implicitly {@link PB_SCShopInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCShopInfo
         * @static
         * @param {IPB_SCShopInfo} message PB_SCShopInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCShopInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sendType != null && Object.hasOwnProperty.call(message, "sendType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sendType);
            if (message.shopList != null && message.shopList.length)
                for (var i = 0; i < message.shopList.length; ++i)
                    $root.PB_SCShopNode.encode(message.shopList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCShopInfo message, length delimited. Does not implicitly {@link PB_SCShopInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCShopInfo
         * @static
         * @param {IPB_SCShopInfo} message PB_SCShopInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCShopInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCShopInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCShopInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCShopInfo} PB_SCShopInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCShopInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCShopInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sendType = reader.int32();
                    break;
                case 2:
                    if (!(message.shopList && message.shopList.length))
                        message.shopList = [];
                    message.shopList.push($root.PB_SCShopNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCShopInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCShopInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCShopInfo} PB_SCShopInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCShopInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCShopInfo message.
         * @function verify
         * @memberof PB_SCShopInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCShopInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                if (!$util.isInteger(message.sendType))
                    return "sendType: integer expected";
            if (message.shopList != null && message.hasOwnProperty("shopList")) {
                if (!Array.isArray(message.shopList))
                    return "shopList: array expected";
                for (var i = 0; i < message.shopList.length; ++i) {
                    var error = $root.PB_SCShopNode.verify(message.shopList[i]);
                    if (error)
                        return "shopList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCShopInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCShopInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCShopInfo} PB_SCShopInfo
         */
        PB_SCShopInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCShopInfo)
                return object;
            var message = new $root.PB_SCShopInfo();
            if (object.sendType != null)
                message.sendType = object.sendType | 0;
            if (object.shopList) {
                if (!Array.isArray(object.shopList))
                    throw TypeError(".PB_SCShopInfo.shopList: array expected");
                message.shopList = [];
                for (var i = 0; i < object.shopList.length; ++i) {
                    if (typeof object.shopList[i] !== "object")
                        throw TypeError(".PB_SCShopInfo.shopList: object expected");
                    message.shopList[i] = $root.PB_SCShopNode.fromObject(object.shopList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCShopInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCShopInfo
         * @static
         * @param {PB_SCShopInfo} message PB_SCShopInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCShopInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.shopList = [];
            if (options.defaults)
                object.sendType = 0;
            if (message.sendType != null && message.hasOwnProperty("sendType"))
                object.sendType = message.sendType;
            if (message.shopList && message.shopList.length) {
                object.shopList = [];
                for (var j = 0; j < message.shopList.length; ++j)
                    object.shopList[j] = $root.PB_SCShopNode.toObject(message.shopList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCShopInfo to JSON.
         * @function toJSON
         * @memberof PB_SCShopInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCShopInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCShopInfo;
    })();
    
    $root.PB_CSDailyBuyReq = (function() {
    
        /**
         * Properties of a PB_CSDailyBuyReq.
         * @exports IPB_CSDailyBuyReq
         * @interface IPB_CSDailyBuyReq
         * @property {number|null} [reqType] PB_CSDailyBuyReq reqType
         * @property {Array.<number>|null} [paramList] PB_CSDailyBuyReq paramList
         */
    
        /**
         * Constructs a new PB_CSDailyBuyReq.
         * @exports PB_CSDailyBuyReq
         * @classdesc Represents a PB_CSDailyBuyReq.
         * @implements IPB_CSDailyBuyReq
         * @constructor
         * @param {IPB_CSDailyBuyReq=} [properties] Properties to set
         */
        function PB_CSDailyBuyReq(properties) {
            this.paramList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSDailyBuyReq reqType.
         * @member {number} reqType
         * @memberof PB_CSDailyBuyReq
         * @instance
         */
        PB_CSDailyBuyReq.prototype.reqType = 0;
    
        /**
         * PB_CSDailyBuyReq paramList.
         * @member {Array.<number>} paramList
         * @memberof PB_CSDailyBuyReq
         * @instance
         */
        PB_CSDailyBuyReq.prototype.paramList = $util.emptyArray;
    
        /**
         * Creates a new PB_CSDailyBuyReq instance using the specified properties.
         * @function create
         * @memberof PB_CSDailyBuyReq
         * @static
         * @param {IPB_CSDailyBuyReq=} [properties] Properties to set
         * @returns {PB_CSDailyBuyReq} PB_CSDailyBuyReq instance
         */
        PB_CSDailyBuyReq.create = function create(properties) {
            return new PB_CSDailyBuyReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSDailyBuyReq message. Does not implicitly {@link PB_CSDailyBuyReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSDailyBuyReq
         * @static
         * @param {IPB_CSDailyBuyReq} message PB_CSDailyBuyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSDailyBuyReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reqType != null && Object.hasOwnProperty.call(message, "reqType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reqType);
            if (message.paramList != null && message.paramList.length)
                for (var i = 0; i < message.paramList.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.paramList[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSDailyBuyReq message, length delimited. Does not implicitly {@link PB_CSDailyBuyReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSDailyBuyReq
         * @static
         * @param {IPB_CSDailyBuyReq} message PB_CSDailyBuyReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSDailyBuyReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSDailyBuyReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSDailyBuyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSDailyBuyReq} PB_CSDailyBuyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSDailyBuyReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSDailyBuyReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reqType = reader.int32();
                    break;
                case 2:
                    if (!(message.paramList && message.paramList.length))
                        message.paramList = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.paramList.push(reader.int32());
                    } else
                        message.paramList.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSDailyBuyReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSDailyBuyReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSDailyBuyReq} PB_CSDailyBuyReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSDailyBuyReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSDailyBuyReq message.
         * @function verify
         * @memberof PB_CSDailyBuyReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSDailyBuyReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                if (!$util.isInteger(message.reqType))
                    return "reqType: integer expected";
            if (message.paramList != null && message.hasOwnProperty("paramList")) {
                if (!Array.isArray(message.paramList))
                    return "paramList: array expected";
                for (var i = 0; i < message.paramList.length; ++i)
                    if (!$util.isInteger(message.paramList[i]))
                        return "paramList: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSDailyBuyReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSDailyBuyReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSDailyBuyReq} PB_CSDailyBuyReq
         */
        PB_CSDailyBuyReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSDailyBuyReq)
                return object;
            var message = new $root.PB_CSDailyBuyReq();
            if (object.reqType != null)
                message.reqType = object.reqType | 0;
            if (object.paramList) {
                if (!Array.isArray(object.paramList))
                    throw TypeError(".PB_CSDailyBuyReq.paramList: array expected");
                message.paramList = [];
                for (var i = 0; i < object.paramList.length; ++i)
                    message.paramList[i] = object.paramList[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSDailyBuyReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSDailyBuyReq
         * @static
         * @param {PB_CSDailyBuyReq} message PB_CSDailyBuyReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSDailyBuyReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.paramList = [];
            if (options.defaults)
                object.reqType = 0;
            if (message.reqType != null && message.hasOwnProperty("reqType"))
                object.reqType = message.reqType;
            if (message.paramList && message.paramList.length) {
                object.paramList = [];
                for (var j = 0; j < message.paramList.length; ++j)
                    object.paramList[j] = message.paramList[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSDailyBuyReq to JSON.
         * @function toJSON
         * @memberof PB_CSDailyBuyReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSDailyBuyReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSDailyBuyReq;
    })();
    
    $root.PB_DailyBuyItem = (function() {
    
        /**
         * Properties of a PB_DailyBuyItem.
         * @exports IPB_DailyBuyItem
         * @interface IPB_DailyBuyItem
         * @property {number|null} [itemId] PB_DailyBuyItem itemId
         * @property {number|null} [itemNum] PB_DailyBuyItem itemNum
         * @property {number|null} [consumeId] PB_DailyBuyItem consumeId
         * @property {number|null} [consumeNum] PB_DailyBuyItem consumeNum
         * @property {boolean|null} [isBuy] PB_DailyBuyItem isBuy
         */
    
        /**
         * Constructs a new PB_DailyBuyItem.
         * @exports PB_DailyBuyItem
         * @classdesc Represents a PB_DailyBuyItem.
         * @implements IPB_DailyBuyItem
         * @constructor
         * @param {IPB_DailyBuyItem=} [properties] Properties to set
         */
        function PB_DailyBuyItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_DailyBuyItem itemId.
         * @member {number} itemId
         * @memberof PB_DailyBuyItem
         * @instance
         */
        PB_DailyBuyItem.prototype.itemId = 0;
    
        /**
         * PB_DailyBuyItem itemNum.
         * @member {number} itemNum
         * @memberof PB_DailyBuyItem
         * @instance
         */
        PB_DailyBuyItem.prototype.itemNum = 0;
    
        /**
         * PB_DailyBuyItem consumeId.
         * @member {number} consumeId
         * @memberof PB_DailyBuyItem
         * @instance
         */
        PB_DailyBuyItem.prototype.consumeId = 0;
    
        /**
         * PB_DailyBuyItem consumeNum.
         * @member {number} consumeNum
         * @memberof PB_DailyBuyItem
         * @instance
         */
        PB_DailyBuyItem.prototype.consumeNum = 0;
    
        /**
         * PB_DailyBuyItem isBuy.
         * @member {boolean} isBuy
         * @memberof PB_DailyBuyItem
         * @instance
         */
        PB_DailyBuyItem.prototype.isBuy = false;
    
        /**
         * Creates a new PB_DailyBuyItem instance using the specified properties.
         * @function create
         * @memberof PB_DailyBuyItem
         * @static
         * @param {IPB_DailyBuyItem=} [properties] Properties to set
         * @returns {PB_DailyBuyItem} PB_DailyBuyItem instance
         */
        PB_DailyBuyItem.create = function create(properties) {
            return new PB_DailyBuyItem(properties);
        };
    
        /**
         * Encodes the specified PB_DailyBuyItem message. Does not implicitly {@link PB_DailyBuyItem.verify|verify} messages.
         * @function encode
         * @memberof PB_DailyBuyItem
         * @static
         * @param {IPB_DailyBuyItem} message PB_DailyBuyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyBuyItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
            if (message.itemNum != null && Object.hasOwnProperty.call(message, "itemNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemNum);
            if (message.consumeId != null && Object.hasOwnProperty.call(message, "consumeId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.consumeId);
            if (message.consumeNum != null && Object.hasOwnProperty.call(message, "consumeNum"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.consumeNum);
            if (message.isBuy != null && Object.hasOwnProperty.call(message, "isBuy"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isBuy);
            return writer;
        };
    
        /**
         * Encodes the specified PB_DailyBuyItem message, length delimited. Does not implicitly {@link PB_DailyBuyItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_DailyBuyItem
         * @static
         * @param {IPB_DailyBuyItem} message PB_DailyBuyItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_DailyBuyItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_DailyBuyItem message from the specified reader or buffer.
         * @function decode
         * @memberof PB_DailyBuyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_DailyBuyItem} PB_DailyBuyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyBuyItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_DailyBuyItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.int32();
                    break;
                case 2:
                    message.itemNum = reader.int32();
                    break;
                case 3:
                    message.consumeId = reader.int32();
                    break;
                case 4:
                    message.consumeNum = reader.int32();
                    break;
                case 5:
                    message.isBuy = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_DailyBuyItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_DailyBuyItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_DailyBuyItem} PB_DailyBuyItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_DailyBuyItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_DailyBuyItem message.
         * @function verify
         * @memberof PB_DailyBuyItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_DailyBuyItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                if (!$util.isInteger(message.itemId))
                    return "itemId: integer expected";
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                if (!$util.isInteger(message.itemNum))
                    return "itemNum: integer expected";
            if (message.consumeId != null && message.hasOwnProperty("consumeId"))
                if (!$util.isInteger(message.consumeId))
                    return "consumeId: integer expected";
            if (message.consumeNum != null && message.hasOwnProperty("consumeNum"))
                if (!$util.isInteger(message.consumeNum))
                    return "consumeNum: integer expected";
            if (message.isBuy != null && message.hasOwnProperty("isBuy"))
                if (typeof message.isBuy !== "boolean")
                    return "isBuy: boolean expected";
            return null;
        };
    
        /**
         * Creates a PB_DailyBuyItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_DailyBuyItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_DailyBuyItem} PB_DailyBuyItem
         */
        PB_DailyBuyItem.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_DailyBuyItem)
                return object;
            var message = new $root.PB_DailyBuyItem();
            if (object.itemId != null)
                message.itemId = object.itemId | 0;
            if (object.itemNum != null)
                message.itemNum = object.itemNum | 0;
            if (object.consumeId != null)
                message.consumeId = object.consumeId | 0;
            if (object.consumeNum != null)
                message.consumeNum = object.consumeNum | 0;
            if (object.isBuy != null)
                message.isBuy = Boolean(object.isBuy);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_DailyBuyItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_DailyBuyItem
         * @static
         * @param {PB_DailyBuyItem} message PB_DailyBuyItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_DailyBuyItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.itemId = 0;
                object.itemNum = 0;
                object.consumeId = 0;
                object.consumeNum = 0;
                object.isBuy = false;
            }
            if (message.itemId != null && message.hasOwnProperty("itemId"))
                object.itemId = message.itemId;
            if (message.itemNum != null && message.hasOwnProperty("itemNum"))
                object.itemNum = message.itemNum;
            if (message.consumeId != null && message.hasOwnProperty("consumeId"))
                object.consumeId = message.consumeId;
            if (message.consumeNum != null && message.hasOwnProperty("consumeNum"))
                object.consumeNum = message.consumeNum;
            if (message.isBuy != null && message.hasOwnProperty("isBuy"))
                object.isBuy = message.isBuy;
            return object;
        };
    
        /**
         * Converts this PB_DailyBuyItem to JSON.
         * @function toJSON
         * @memberof PB_DailyBuyItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_DailyBuyItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_DailyBuyItem;
    })();
    
    $root.PB_SCDailyBuyInfo = (function() {
    
        /**
         * Properties of a PB_SCDailyBuyInfo.
         * @exports IPB_SCDailyBuyInfo
         * @interface IPB_SCDailyBuyInfo
         * @property {number|null} [dayRefreshTimes] PB_SCDailyBuyInfo dayRefreshTimes
         * @property {Array.<IPB_DailyBuyItem>|null} [itemList] PB_SCDailyBuyInfo itemList
         */
    
        /**
         * Constructs a new PB_SCDailyBuyInfo.
         * @exports PB_SCDailyBuyInfo
         * @classdesc Represents a PB_SCDailyBuyInfo.
         * @implements IPB_SCDailyBuyInfo
         * @constructor
         * @param {IPB_SCDailyBuyInfo=} [properties] Properties to set
         */
        function PB_SCDailyBuyInfo(properties) {
            this.itemList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCDailyBuyInfo dayRefreshTimes.
         * @member {number} dayRefreshTimes
         * @memberof PB_SCDailyBuyInfo
         * @instance
         */
        PB_SCDailyBuyInfo.prototype.dayRefreshTimes = 0;
    
        /**
         * PB_SCDailyBuyInfo itemList.
         * @member {Array.<IPB_DailyBuyItem>} itemList
         * @memberof PB_SCDailyBuyInfo
         * @instance
         */
        PB_SCDailyBuyInfo.prototype.itemList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCDailyBuyInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCDailyBuyInfo
         * @static
         * @param {IPB_SCDailyBuyInfo=} [properties] Properties to set
         * @returns {PB_SCDailyBuyInfo} PB_SCDailyBuyInfo instance
         */
        PB_SCDailyBuyInfo.create = function create(properties) {
            return new PB_SCDailyBuyInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCDailyBuyInfo message. Does not implicitly {@link PB_SCDailyBuyInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCDailyBuyInfo
         * @static
         * @param {IPB_SCDailyBuyInfo} message PB_SCDailyBuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCDailyBuyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dayRefreshTimes != null && Object.hasOwnProperty.call(message, "dayRefreshTimes"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dayRefreshTimes);
            if (message.itemList != null && message.itemList.length)
                for (var i = 0; i < message.itemList.length; ++i)
                    $root.PB_DailyBuyItem.encode(message.itemList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCDailyBuyInfo message, length delimited. Does not implicitly {@link PB_SCDailyBuyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCDailyBuyInfo
         * @static
         * @param {IPB_SCDailyBuyInfo} message PB_SCDailyBuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCDailyBuyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCDailyBuyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCDailyBuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCDailyBuyInfo} PB_SCDailyBuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCDailyBuyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCDailyBuyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dayRefreshTimes = reader.int32();
                    break;
                case 2:
                    if (!(message.itemList && message.itemList.length))
                        message.itemList = [];
                    message.itemList.push($root.PB_DailyBuyItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCDailyBuyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCDailyBuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCDailyBuyInfo} PB_SCDailyBuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCDailyBuyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCDailyBuyInfo message.
         * @function verify
         * @memberof PB_SCDailyBuyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCDailyBuyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dayRefreshTimes != null && message.hasOwnProperty("dayRefreshTimes"))
                if (!$util.isInteger(message.dayRefreshTimes))
                    return "dayRefreshTimes: integer expected";
            if (message.itemList != null && message.hasOwnProperty("itemList")) {
                if (!Array.isArray(message.itemList))
                    return "itemList: array expected";
                for (var i = 0; i < message.itemList.length; ++i) {
                    var error = $root.PB_DailyBuyItem.verify(message.itemList[i]);
                    if (error)
                        return "itemList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCDailyBuyInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCDailyBuyInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCDailyBuyInfo} PB_SCDailyBuyInfo
         */
        PB_SCDailyBuyInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCDailyBuyInfo)
                return object;
            var message = new $root.PB_SCDailyBuyInfo();
            if (object.dayRefreshTimes != null)
                message.dayRefreshTimes = object.dayRefreshTimes | 0;
            if (object.itemList) {
                if (!Array.isArray(object.itemList))
                    throw TypeError(".PB_SCDailyBuyInfo.itemList: array expected");
                message.itemList = [];
                for (var i = 0; i < object.itemList.length; ++i) {
                    if (typeof object.itemList[i] !== "object")
                        throw TypeError(".PB_SCDailyBuyInfo.itemList: object expected");
                    message.itemList[i] = $root.PB_DailyBuyItem.fromObject(object.itemList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCDailyBuyInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCDailyBuyInfo
         * @static
         * @param {PB_SCDailyBuyInfo} message PB_SCDailyBuyInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCDailyBuyInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemList = [];
            if (options.defaults)
                object.dayRefreshTimes = 0;
            if (message.dayRefreshTimes != null && message.hasOwnProperty("dayRefreshTimes"))
                object.dayRefreshTimes = message.dayRefreshTimes;
            if (message.itemList && message.itemList.length) {
                object.itemList = [];
                for (var j = 0; j < message.itemList.length; ++j)
                    object.itemList[j] = $root.PB_DailyBuyItem.toObject(message.itemList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCDailyBuyInfo to JSON.
         * @function toJSON
         * @memberof PB_SCDailyBuyInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCDailyBuyInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCDailyBuyInfo;
    })();
    
    $root.PB_UniqueID = (function() {
    
        /**
         * Properties of a PB_UniqueID.
         * @exports IPB_UniqueID
         * @interface IPB_UniqueID
         * @property {Array.<number>|null} [itemUniqueId] PB_UniqueID itemUniqueId
         */
    
        /**
         * Constructs a new PB_UniqueID.
         * @exports PB_UniqueID
         * @classdesc Represents a PB_UniqueID.
         * @implements IPB_UniqueID
         * @constructor
         * @param {IPB_UniqueID=} [properties] Properties to set
         */
        function PB_UniqueID(properties) {
            this.itemUniqueId = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_UniqueID itemUniqueId.
         * @member {Array.<number>} itemUniqueId
         * @memberof PB_UniqueID
         * @instance
         */
        PB_UniqueID.prototype.itemUniqueId = $util.emptyArray;
    
        /**
         * Creates a new PB_UniqueID instance using the specified properties.
         * @function create
         * @memberof PB_UniqueID
         * @static
         * @param {IPB_UniqueID=} [properties] Properties to set
         * @returns {PB_UniqueID} PB_UniqueID instance
         */
        PB_UniqueID.create = function create(properties) {
            return new PB_UniqueID(properties);
        };
    
        /**
         * Encodes the specified PB_UniqueID message. Does not implicitly {@link PB_UniqueID.verify|verify} messages.
         * @function encode
         * @memberof PB_UniqueID
         * @static
         * @param {IPB_UniqueID} message PB_UniqueID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_UniqueID.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.itemUniqueId != null && message.itemUniqueId.length)
                for (var i = 0; i < message.itemUniqueId.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.itemUniqueId[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_UniqueID message, length delimited. Does not implicitly {@link PB_UniqueID.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_UniqueID
         * @static
         * @param {IPB_UniqueID} message PB_UniqueID message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_UniqueID.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_UniqueID message from the specified reader or buffer.
         * @function decode
         * @memberof PB_UniqueID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_UniqueID} PB_UniqueID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_UniqueID.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_UniqueID();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.itemUniqueId && message.itemUniqueId.length))
                        message.itemUniqueId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemUniqueId.push(reader.uint32());
                    } else
                        message.itemUniqueId.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_UniqueID message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_UniqueID
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_UniqueID} PB_UniqueID
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_UniqueID.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_UniqueID message.
         * @function verify
         * @memberof PB_UniqueID
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_UniqueID.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.itemUniqueId != null && message.hasOwnProperty("itemUniqueId")) {
                if (!Array.isArray(message.itemUniqueId))
                    return "itemUniqueId: array expected";
                for (var i = 0; i < message.itemUniqueId.length; ++i)
                    if (!$util.isInteger(message.itemUniqueId[i]))
                        return "itemUniqueId: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_UniqueID message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_UniqueID
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_UniqueID} PB_UniqueID
         */
        PB_UniqueID.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_UniqueID)
                return object;
            var message = new $root.PB_UniqueID();
            if (object.itemUniqueId) {
                if (!Array.isArray(object.itemUniqueId))
                    throw TypeError(".PB_UniqueID.itemUniqueId: array expected");
                message.itemUniqueId = [];
                for (var i = 0; i < object.itemUniqueId.length; ++i)
                    message.itemUniqueId[i] = object.itemUniqueId[i] >>> 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_UniqueID message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_UniqueID
         * @static
         * @param {PB_UniqueID} message PB_UniqueID
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_UniqueID.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemUniqueId = [];
            if (message.itemUniqueId && message.itemUniqueId.length) {
                object.itemUniqueId = [];
                for (var j = 0; j < message.itemUniqueId.length; ++j)
                    object.itemUniqueId[j] = message.itemUniqueId[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_UniqueID to JSON.
         * @function toJSON
         * @memberof PB_UniqueID
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_UniqueID.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_UniqueID;
    })();
    
    $root.PB_SCNoticeNum = (function() {
    
        /**
         * Properties of a PB_SCNoticeNum.
         * @exports IPB_SCNoticeNum
         * @interface IPB_SCNoticeNum
         * @property {number|null} [noticeNum] PB_SCNoticeNum noticeNum
         */
    
        /**
         * Constructs a new PB_SCNoticeNum.
         * @exports PB_SCNoticeNum
         * @classdesc Represents a PB_SCNoticeNum.
         * @implements IPB_SCNoticeNum
         * @constructor
         * @param {IPB_SCNoticeNum=} [properties] Properties to set
         */
        function PB_SCNoticeNum(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCNoticeNum noticeNum.
         * @member {number} noticeNum
         * @memberof PB_SCNoticeNum
         * @instance
         */
        PB_SCNoticeNum.prototype.noticeNum = 0;
    
        /**
         * Creates a new PB_SCNoticeNum instance using the specified properties.
         * @function create
         * @memberof PB_SCNoticeNum
         * @static
         * @param {IPB_SCNoticeNum=} [properties] Properties to set
         * @returns {PB_SCNoticeNum} PB_SCNoticeNum instance
         */
        PB_SCNoticeNum.create = function create(properties) {
            return new PB_SCNoticeNum(properties);
        };
    
        /**
         * Encodes the specified PB_SCNoticeNum message. Does not implicitly {@link PB_SCNoticeNum.verify|verify} messages.
         * @function encode
         * @memberof PB_SCNoticeNum
         * @static
         * @param {IPB_SCNoticeNum} message PB_SCNoticeNum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCNoticeNum.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.noticeNum != null && Object.hasOwnProperty.call(message, "noticeNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.noticeNum);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCNoticeNum message, length delimited. Does not implicitly {@link PB_SCNoticeNum.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCNoticeNum
         * @static
         * @param {IPB_SCNoticeNum} message PB_SCNoticeNum message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCNoticeNum.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCNoticeNum message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCNoticeNum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCNoticeNum} PB_SCNoticeNum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCNoticeNum.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCNoticeNum();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.noticeNum = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCNoticeNum message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCNoticeNum
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCNoticeNum} PB_SCNoticeNum
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCNoticeNum.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCNoticeNum message.
         * @function verify
         * @memberof PB_SCNoticeNum
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCNoticeNum.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.noticeNum != null && message.hasOwnProperty("noticeNum"))
                if (!$util.isInteger(message.noticeNum))
                    return "noticeNum: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCNoticeNum message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCNoticeNum
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCNoticeNum} PB_SCNoticeNum
         */
        PB_SCNoticeNum.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCNoticeNum)
                return object;
            var message = new $root.PB_SCNoticeNum();
            if (object.noticeNum != null)
                message.noticeNum = object.noticeNum >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCNoticeNum message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCNoticeNum
         * @static
         * @param {PB_SCNoticeNum} message PB_SCNoticeNum
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCNoticeNum.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.noticeNum = 0;
            if (message.noticeNum != null && message.hasOwnProperty("noticeNum"))
                object.noticeNum = message.noticeNum;
            return object;
        };
    
        /**
         * Converts this PB_SCNoticeNum to JSON.
         * @function toJSON
         * @memberof PB_SCNoticeNum
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCNoticeNum.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCNoticeNum;
    })();
    
    $root.PB_SCSystemMsg = (function() {
    
        /**
         * Properties of a PB_SCSystemMsg.
         * @exports IPB_SCSystemMsg
         * @interface IPB_SCSystemMsg
         * @property {number|null} [sendTime] PB_SCSystemMsg sendTime
         * @property {number|null} [limitLevel] PB_SCSystemMsg limitLevel
         * @property {number|null} [msgLength] PB_SCSystemMsg msgLength
         * @property {number|null} [displayPos] PB_SCSystemMsg displayPos
         * @property {number|null} [color] PB_SCSystemMsg color
         * @property {number|null} [msgType] PB_SCSystemMsg msgType
         * @property {Uint8Array|null} [spidId] PB_SCSystemMsg spidId
         * @property {Uint8Array|null} [msg] PB_SCSystemMsg msg
         */
    
        /**
         * Constructs a new PB_SCSystemMsg.
         * @exports PB_SCSystemMsg
         * @classdesc Represents a PB_SCSystemMsg.
         * @implements IPB_SCSystemMsg
         * @constructor
         * @param {IPB_SCSystemMsg=} [properties] Properties to set
         */
        function PB_SCSystemMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCSystemMsg sendTime.
         * @member {number} sendTime
         * @memberof PB_SCSystemMsg
         * @instance
         */
        PB_SCSystemMsg.prototype.sendTime = 0;
    
        /**
         * PB_SCSystemMsg limitLevel.
         * @member {number} limitLevel
         * @memberof PB_SCSystemMsg
         * @instance
         */
        PB_SCSystemMsg.prototype.limitLevel = 0;
    
        /**
         * PB_SCSystemMsg msgLength.
         * @member {number} msgLength
         * @memberof PB_SCSystemMsg
         * @instance
         */
        PB_SCSystemMsg.prototype.msgLength = 0;
    
        /**
         * PB_SCSystemMsg displayPos.
         * @member {number} displayPos
         * @memberof PB_SCSystemMsg
         * @instance
         */
        PB_SCSystemMsg.prototype.displayPos = 0;
    
        /**
         * PB_SCSystemMsg color.
         * @member {number} color
         * @memberof PB_SCSystemMsg
         * @instance
         */
        PB_SCSystemMsg.prototype.color = 0;
    
        /**
         * PB_SCSystemMsg msgType.
         * @member {number} msgType
         * @memberof PB_SCSystemMsg
         * @instance
         */
        PB_SCSystemMsg.prototype.msgType = 0;
    
        /**
         * PB_SCSystemMsg spidId.
         * @member {Uint8Array} spidId
         * @memberof PB_SCSystemMsg
         * @instance
         */
        PB_SCSystemMsg.prototype.spidId = $util.newBuffer([]);
    
        /**
         * PB_SCSystemMsg msg.
         * @member {Uint8Array} msg
         * @memberof PB_SCSystemMsg
         * @instance
         */
        PB_SCSystemMsg.prototype.msg = $util.newBuffer([]);
    
        /**
         * Creates a new PB_SCSystemMsg instance using the specified properties.
         * @function create
         * @memberof PB_SCSystemMsg
         * @static
         * @param {IPB_SCSystemMsg=} [properties] Properties to set
         * @returns {PB_SCSystemMsg} PB_SCSystemMsg instance
         */
        PB_SCSystemMsg.create = function create(properties) {
            return new PB_SCSystemMsg(properties);
        };
    
        /**
         * Encodes the specified PB_SCSystemMsg message. Does not implicitly {@link PB_SCSystemMsg.verify|verify} messages.
         * @function encode
         * @memberof PB_SCSystemMsg
         * @static
         * @param {IPB_SCSystemMsg} message PB_SCSystemMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCSystemMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sendTime != null && Object.hasOwnProperty.call(message, "sendTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sendTime);
            if (message.limitLevel != null && Object.hasOwnProperty.call(message, "limitLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.limitLevel);
            if (message.msgLength != null && Object.hasOwnProperty.call(message, "msgLength"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msgLength);
            if (message.displayPos != null && Object.hasOwnProperty.call(message, "displayPos"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.displayPos);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.color);
            if (message.msgType != null && Object.hasOwnProperty.call(message, "msgType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.msgType);
            if (message.spidId != null && Object.hasOwnProperty.call(message, "spidId"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.spidId);
            if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.msg);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCSystemMsg message, length delimited. Does not implicitly {@link PB_SCSystemMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCSystemMsg
         * @static
         * @param {IPB_SCSystemMsg} message PB_SCSystemMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCSystemMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCSystemMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCSystemMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCSystemMsg} PB_SCSystemMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCSystemMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCSystemMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sendTime = reader.uint32();
                    break;
                case 2:
                    message.limitLevel = reader.int32();
                    break;
                case 3:
                    message.msgLength = reader.int32();
                    break;
                case 4:
                    message.displayPos = reader.int32();
                    break;
                case 5:
                    message.color = reader.int32();
                    break;
                case 6:
                    message.msgType = reader.int32();
                    break;
                case 7:
                    message.spidId = reader.bytes();
                    break;
                case 8:
                    message.msg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCSystemMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCSystemMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCSystemMsg} PB_SCSystemMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCSystemMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCSystemMsg message.
         * @function verify
         * @memberof PB_SCSystemMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCSystemMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sendTime != null && message.hasOwnProperty("sendTime"))
                if (!$util.isInteger(message.sendTime))
                    return "sendTime: integer expected";
            if (message.limitLevel != null && message.hasOwnProperty("limitLevel"))
                if (!$util.isInteger(message.limitLevel))
                    return "limitLevel: integer expected";
            if (message.msgLength != null && message.hasOwnProperty("msgLength"))
                if (!$util.isInteger(message.msgLength))
                    return "msgLength: integer expected";
            if (message.displayPos != null && message.hasOwnProperty("displayPos"))
                if (!$util.isInteger(message.displayPos))
                    return "displayPos: integer expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isInteger(message.color))
                    return "color: integer expected";
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                if (!$util.isInteger(message.msgType))
                    return "msgType: integer expected";
            if (message.spidId != null && message.hasOwnProperty("spidId"))
                if (!(message.spidId && typeof message.spidId.length === "number" || $util.isString(message.spidId)))
                    return "spidId: buffer expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!(message.msg && typeof message.msg.length === "number" || $util.isString(message.msg)))
                    return "msg: buffer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCSystemMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCSystemMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCSystemMsg} PB_SCSystemMsg
         */
        PB_SCSystemMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCSystemMsg)
                return object;
            var message = new $root.PB_SCSystemMsg();
            if (object.sendTime != null)
                message.sendTime = object.sendTime >>> 0;
            if (object.limitLevel != null)
                message.limitLevel = object.limitLevel | 0;
            if (object.msgLength != null)
                message.msgLength = object.msgLength | 0;
            if (object.displayPos != null)
                message.displayPos = object.displayPos | 0;
            if (object.color != null)
                message.color = object.color | 0;
            if (object.msgType != null)
                message.msgType = object.msgType | 0;
            if (object.spidId != null)
                if (typeof object.spidId === "string")
                    $util.base64.decode(object.spidId, message.spidId = $util.newBuffer($util.base64.length(object.spidId)), 0);
                else if (object.spidId.length)
                    message.spidId = object.spidId;
            if (object.msg != null)
                if (typeof object.msg === "string")
                    $util.base64.decode(object.msg, message.msg = $util.newBuffer($util.base64.length(object.msg)), 0);
                else if (object.msg.length)
                    message.msg = object.msg;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCSystemMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCSystemMsg
         * @static
         * @param {PB_SCSystemMsg} message PB_SCSystemMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCSystemMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sendTime = 0;
                object.limitLevel = 0;
                object.msgLength = 0;
                object.displayPos = 0;
                object.color = 0;
                object.msgType = 0;
                if (options.bytes === String)
                    object.spidId = "";
                else {
                    object.spidId = [];
                    if (options.bytes !== Array)
                        object.spidId = $util.newBuffer(object.spidId);
                }
                if (options.bytes === String)
                    object.msg = "";
                else {
                    object.msg = [];
                    if (options.bytes !== Array)
                        object.msg = $util.newBuffer(object.msg);
                }
            }
            if (message.sendTime != null && message.hasOwnProperty("sendTime"))
                object.sendTime = message.sendTime;
            if (message.limitLevel != null && message.hasOwnProperty("limitLevel"))
                object.limitLevel = message.limitLevel;
            if (message.msgLength != null && message.hasOwnProperty("msgLength"))
                object.msgLength = message.msgLength;
            if (message.displayPos != null && message.hasOwnProperty("displayPos"))
                object.displayPos = message.displayPos;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            if (message.msgType != null && message.hasOwnProperty("msgType"))
                object.msgType = message.msgType;
            if (message.spidId != null && message.hasOwnProperty("spidId"))
                object.spidId = options.bytes === String ? $util.base64.encode(message.spidId, 0, message.spidId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spidId) : message.spidId;
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = options.bytes === String ? $util.base64.encode(message.msg, 0, message.msg.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg) : message.msg;
            return object;
        };
    
        /**
         * Converts this PB_SCSystemMsg to JSON.
         * @function toJSON
         * @memberof PB_SCSystemMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCSystemMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCSystemMsg;
    })();
    
    $root.PB_SCZeroHour = (function() {
    
        /**
         * Properties of a PB_SCZeroHour.
         * @exports IPB_SCZeroHour
         * @interface IPB_SCZeroHour
         * @property {number|null} [reserve] PB_SCZeroHour reserve
         */
    
        /**
         * Constructs a new PB_SCZeroHour.
         * @exports PB_SCZeroHour
         * @classdesc Represents a PB_SCZeroHour.
         * @implements IPB_SCZeroHour
         * @constructor
         * @param {IPB_SCZeroHour=} [properties] Properties to set
         */
        function PB_SCZeroHour(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCZeroHour reserve.
         * @member {number} reserve
         * @memberof PB_SCZeroHour
         * @instance
         */
        PB_SCZeroHour.prototype.reserve = 0;
    
        /**
         * Creates a new PB_SCZeroHour instance using the specified properties.
         * @function create
         * @memberof PB_SCZeroHour
         * @static
         * @param {IPB_SCZeroHour=} [properties] Properties to set
         * @returns {PB_SCZeroHour} PB_SCZeroHour instance
         */
        PB_SCZeroHour.create = function create(properties) {
            return new PB_SCZeroHour(properties);
        };
    
        /**
         * Encodes the specified PB_SCZeroHour message. Does not implicitly {@link PB_SCZeroHour.verify|verify} messages.
         * @function encode
         * @memberof PB_SCZeroHour
         * @static
         * @param {IPB_SCZeroHour} message PB_SCZeroHour message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCZeroHour.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reserve != null && Object.hasOwnProperty.call(message, "reserve"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reserve);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCZeroHour message, length delimited. Does not implicitly {@link PB_SCZeroHour.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCZeroHour
         * @static
         * @param {IPB_SCZeroHour} message PB_SCZeroHour message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCZeroHour.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCZeroHour message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCZeroHour
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCZeroHour} PB_SCZeroHour
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCZeroHour.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCZeroHour();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reserve = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCZeroHour message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCZeroHour
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCZeroHour} PB_SCZeroHour
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCZeroHour.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCZeroHour message.
         * @function verify
         * @memberof PB_SCZeroHour
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCZeroHour.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                if (!$util.isInteger(message.reserve))
                    return "reserve: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCZeroHour message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCZeroHour
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCZeroHour} PB_SCZeroHour
         */
        PB_SCZeroHour.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCZeroHour)
                return object;
            var message = new $root.PB_SCZeroHour();
            if (object.reserve != null)
                message.reserve = object.reserve | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCZeroHour message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCZeroHour
         * @static
         * @param {PB_SCZeroHour} message PB_SCZeroHour
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCZeroHour.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reserve = 0;
            if (message.reserve != null && message.hasOwnProperty("reserve"))
                object.reserve = message.reserve;
            return object;
        };
    
        /**
         * Converts this PB_SCZeroHour to JSON.
         * @function toJSON
         * @memberof PB_SCZeroHour
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCZeroHour.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCZeroHour;
    })();
    
    $root.PB_SCCMDChongZhiRetInfo = (function() {
    
        /**
         * Properties of a PB_SCCMDChongZhiRetInfo.
         * @exports IPB_SCCMDChongZhiRetInfo
         * @interface IPB_SCCMDChongZhiRetInfo
         * @property {number|null} [roleId] PB_SCCMDChongZhiRetInfo roleId
         * @property {number|null} [addGold] PB_SCCMDChongZhiRetInfo addGold
         * @property {Uint8Array|null} [orderId] PB_SCCMDChongZhiRetInfo orderId
         * @property {number|null} [money] PB_SCCMDChongZhiRetInfo money
         * @property {Uint8Array|null} [moneyType] PB_SCCMDChongZhiRetInfo moneyType
         */
    
        /**
         * Constructs a new PB_SCCMDChongZhiRetInfo.
         * @exports PB_SCCMDChongZhiRetInfo
         * @classdesc Represents a PB_SCCMDChongZhiRetInfo.
         * @implements IPB_SCCMDChongZhiRetInfo
         * @constructor
         * @param {IPB_SCCMDChongZhiRetInfo=} [properties] Properties to set
         */
        function PB_SCCMDChongZhiRetInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCCMDChongZhiRetInfo roleId.
         * @member {number} roleId
         * @memberof PB_SCCMDChongZhiRetInfo
         * @instance
         */
        PB_SCCMDChongZhiRetInfo.prototype.roleId = 0;
    
        /**
         * PB_SCCMDChongZhiRetInfo addGold.
         * @member {number} addGold
         * @memberof PB_SCCMDChongZhiRetInfo
         * @instance
         */
        PB_SCCMDChongZhiRetInfo.prototype.addGold = 0;
    
        /**
         * PB_SCCMDChongZhiRetInfo orderId.
         * @member {Uint8Array} orderId
         * @memberof PB_SCCMDChongZhiRetInfo
         * @instance
         */
        PB_SCCMDChongZhiRetInfo.prototype.orderId = $util.newBuffer([]);
    
        /**
         * PB_SCCMDChongZhiRetInfo money.
         * @member {number} money
         * @memberof PB_SCCMDChongZhiRetInfo
         * @instance
         */
        PB_SCCMDChongZhiRetInfo.prototype.money = 0;
    
        /**
         * PB_SCCMDChongZhiRetInfo moneyType.
         * @member {Uint8Array} moneyType
         * @memberof PB_SCCMDChongZhiRetInfo
         * @instance
         */
        PB_SCCMDChongZhiRetInfo.prototype.moneyType = $util.newBuffer([]);
    
        /**
         * Creates a new PB_SCCMDChongZhiRetInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCCMDChongZhiRetInfo
         * @static
         * @param {IPB_SCCMDChongZhiRetInfo=} [properties] Properties to set
         * @returns {PB_SCCMDChongZhiRetInfo} PB_SCCMDChongZhiRetInfo instance
         */
        PB_SCCMDChongZhiRetInfo.create = function create(properties) {
            return new PB_SCCMDChongZhiRetInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCCMDChongZhiRetInfo message. Does not implicitly {@link PB_SCCMDChongZhiRetInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCCMDChongZhiRetInfo
         * @static
         * @param {IPB_SCCMDChongZhiRetInfo} message PB_SCCMDChongZhiRetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCCMDChongZhiRetInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roleId);
            if (message.addGold != null && Object.hasOwnProperty.call(message, "addGold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.addGold);
            if (message.orderId != null && Object.hasOwnProperty.call(message, "orderId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.orderId);
            if (message.money != null && Object.hasOwnProperty.call(message, "money"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.money);
            if (message.moneyType != null && Object.hasOwnProperty.call(message, "moneyType"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.moneyType);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCCMDChongZhiRetInfo message, length delimited. Does not implicitly {@link PB_SCCMDChongZhiRetInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCCMDChongZhiRetInfo
         * @static
         * @param {IPB_SCCMDChongZhiRetInfo} message PB_SCCMDChongZhiRetInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCCMDChongZhiRetInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCCMDChongZhiRetInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCCMDChongZhiRetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCCMDChongZhiRetInfo} PB_SCCMDChongZhiRetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCCMDChongZhiRetInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCCMDChongZhiRetInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int32();
                    break;
                case 2:
                    message.addGold = reader.int32();
                    break;
                case 3:
                    message.orderId = reader.bytes();
                    break;
                case 4:
                    message.money = reader.int32();
                    break;
                case 5:
                    message.moneyType = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCCMDChongZhiRetInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCCMDChongZhiRetInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCCMDChongZhiRetInfo} PB_SCCMDChongZhiRetInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCCMDChongZhiRetInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCCMDChongZhiRetInfo message.
         * @function verify
         * @memberof PB_SCCMDChongZhiRetInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCCMDChongZhiRetInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId))
                    return "roleId: integer expected";
            if (message.addGold != null && message.hasOwnProperty("addGold"))
                if (!$util.isInteger(message.addGold))
                    return "addGold: integer expected";
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                if (!(message.orderId && typeof message.orderId.length === "number" || $util.isString(message.orderId)))
                    return "orderId: buffer expected";
            if (message.money != null && message.hasOwnProperty("money"))
                if (!$util.isInteger(message.money))
                    return "money: integer expected";
            if (message.moneyType != null && message.hasOwnProperty("moneyType"))
                if (!(message.moneyType && typeof message.moneyType.length === "number" || $util.isString(message.moneyType)))
                    return "moneyType: buffer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCCMDChongZhiRetInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCCMDChongZhiRetInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCCMDChongZhiRetInfo} PB_SCCMDChongZhiRetInfo
         */
        PB_SCCMDChongZhiRetInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCCMDChongZhiRetInfo)
                return object;
            var message = new $root.PB_SCCMDChongZhiRetInfo();
            if (object.roleId != null)
                message.roleId = object.roleId | 0;
            if (object.addGold != null)
                message.addGold = object.addGold | 0;
            if (object.orderId != null)
                if (typeof object.orderId === "string")
                    $util.base64.decode(object.orderId, message.orderId = $util.newBuffer($util.base64.length(object.orderId)), 0);
                else if (object.orderId.length)
                    message.orderId = object.orderId;
            if (object.money != null)
                message.money = object.money | 0;
            if (object.moneyType != null)
                if (typeof object.moneyType === "string")
                    $util.base64.decode(object.moneyType, message.moneyType = $util.newBuffer($util.base64.length(object.moneyType)), 0);
                else if (object.moneyType.length)
                    message.moneyType = object.moneyType;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCCMDChongZhiRetInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCCMDChongZhiRetInfo
         * @static
         * @param {PB_SCCMDChongZhiRetInfo} message PB_SCCMDChongZhiRetInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCCMDChongZhiRetInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roleId = 0;
                object.addGold = 0;
                if (options.bytes === String)
                    object.orderId = "";
                else {
                    object.orderId = [];
                    if (options.bytes !== Array)
                        object.orderId = $util.newBuffer(object.orderId);
                }
                object.money = 0;
                if (options.bytes === String)
                    object.moneyType = "";
                else {
                    object.moneyType = [];
                    if (options.bytes !== Array)
                        object.moneyType = $util.newBuffer(object.moneyType);
                }
            }
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                object.roleId = message.roleId;
            if (message.addGold != null && message.hasOwnProperty("addGold"))
                object.addGold = message.addGold;
            if (message.orderId != null && message.hasOwnProperty("orderId"))
                object.orderId = options.bytes === String ? $util.base64.encode(message.orderId, 0, message.orderId.length) : options.bytes === Array ? Array.prototype.slice.call(message.orderId) : message.orderId;
            if (message.money != null && message.hasOwnProperty("money"))
                object.money = message.money;
            if (message.moneyType != null && message.hasOwnProperty("moneyType"))
                object.moneyType = options.bytes === String ? $util.base64.encode(message.moneyType, 0, message.moneyType.length) : options.bytes === Array ? Array.prototype.slice.call(message.moneyType) : message.moneyType;
            return object;
        };
    
        /**
         * Converts this PB_SCCMDChongZhiRetInfo to JSON.
         * @function toJSON
         * @memberof PB_SCCMDChongZhiRetInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCCMDChongZhiRetInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCCMDChongZhiRetInfo;
    })();
    
    $root.PB_CSTerritoryReq = (function() {
    
        /**
         * Properties of a PB_CSTerritoryReq.
         * @exports IPB_CSTerritoryReq
         * @interface IPB_CSTerritoryReq
         * @property {number|null} [type] PB_CSTerritoryReq type
         * @property {Array.<number>|null} [param] PB_CSTerritoryReq param
         */
    
        /**
         * Constructs a new PB_CSTerritoryReq.
         * @exports PB_CSTerritoryReq
         * @classdesc Represents a PB_CSTerritoryReq.
         * @implements IPB_CSTerritoryReq
         * @constructor
         * @param {IPB_CSTerritoryReq=} [properties] Properties to set
         */
        function PB_CSTerritoryReq(properties) {
            this.param = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_CSTerritoryReq type.
         * @member {number} type
         * @memberof PB_CSTerritoryReq
         * @instance
         */
        PB_CSTerritoryReq.prototype.type = 0;
    
        /**
         * PB_CSTerritoryReq param.
         * @member {Array.<number>} param
         * @memberof PB_CSTerritoryReq
         * @instance
         */
        PB_CSTerritoryReq.prototype.param = $util.emptyArray;
    
        /**
         * Creates a new PB_CSTerritoryReq instance using the specified properties.
         * @function create
         * @memberof PB_CSTerritoryReq
         * @static
         * @param {IPB_CSTerritoryReq=} [properties] Properties to set
         * @returns {PB_CSTerritoryReq} PB_CSTerritoryReq instance
         */
        PB_CSTerritoryReq.create = function create(properties) {
            return new PB_CSTerritoryReq(properties);
        };
    
        /**
         * Encodes the specified PB_CSTerritoryReq message. Does not implicitly {@link PB_CSTerritoryReq.verify|verify} messages.
         * @function encode
         * @memberof PB_CSTerritoryReq
         * @static
         * @param {IPB_CSTerritoryReq} message PB_CSTerritoryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSTerritoryReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.param != null && message.param.length)
                for (var i = 0; i < message.param.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.param[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_CSTerritoryReq message, length delimited. Does not implicitly {@link PB_CSTerritoryReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_CSTerritoryReq
         * @static
         * @param {IPB_CSTerritoryReq} message PB_CSTerritoryReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_CSTerritoryReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_CSTerritoryReq message from the specified reader or buffer.
         * @function decode
         * @memberof PB_CSTerritoryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_CSTerritoryReq} PB_CSTerritoryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSTerritoryReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_CSTerritoryReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.param && message.param.length))
                        message.param = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.param.push(reader.int32());
                    } else
                        message.param.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_CSTerritoryReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_CSTerritoryReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_CSTerritoryReq} PB_CSTerritoryReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_CSTerritoryReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_CSTerritoryReq message.
         * @function verify
         * @memberof PB_CSTerritoryReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_CSTerritoryReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.param != null && message.hasOwnProperty("param")) {
                if (!Array.isArray(message.param))
                    return "param: array expected";
                for (var i = 0; i < message.param.length; ++i)
                    if (!$util.isInteger(message.param[i]))
                        return "param: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_CSTerritoryReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_CSTerritoryReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_CSTerritoryReq} PB_CSTerritoryReq
         */
        PB_CSTerritoryReq.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_CSTerritoryReq)
                return object;
            var message = new $root.PB_CSTerritoryReq();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.param) {
                if (!Array.isArray(object.param))
                    throw TypeError(".PB_CSTerritoryReq.param: array expected");
                message.param = [];
                for (var i = 0; i < object.param.length; ++i)
                    message.param[i] = object.param[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_CSTerritoryReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_CSTerritoryReq
         * @static
         * @param {PB_CSTerritoryReq} message PB_CSTerritoryReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_CSTerritoryReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.param = [];
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.param && message.param.length) {
                object.param = [];
                for (var j = 0; j < message.param.length; ++j)
                    object.param[j] = message.param[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_CSTerritoryReq to JSON.
         * @function toJSON
         * @memberof PB_CSTerritoryReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_CSTerritoryReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_CSTerritoryReq;
    })();
    
    $root.PB_SCTerritoryItemNode = (function() {
    
        /**
         * Properties of a PB_SCTerritoryItemNode.
         * @exports IPB_SCTerritoryItemNode
         * @interface IPB_SCTerritoryItemNode
         * @property {number|null} [seq] PB_SCTerritoryItemNode seq
         * @property {number|null} [index] PB_SCTerritoryItemNode index
         * @property {number|null} [attackerNum] PB_SCTerritoryItemNode attackerNum
         * @property {number|null} [attackerEfficiency] PB_SCTerritoryItemNode attackerEfficiency
         * @property {IPB_RoleInfo|null} [attackerInfo] PB_SCTerritoryItemNode attackerInfo
         * @property {number|null} [defenderNum] PB_SCTerritoryItemNode defenderNum
         * @property {number|null} [defenderEfficiency] PB_SCTerritoryItemNode defenderEfficiency
         * @property {number|null} [refreshTime] PB_SCTerritoryItemNode refreshTime
         * @property {number|null} [pos] PB_SCTerritoryItemNode pos
         * @property {number|null} [endTime] PB_SCTerritoryItemNode endTime
         */
    
        /**
         * Constructs a new PB_SCTerritoryItemNode.
         * @exports PB_SCTerritoryItemNode
         * @classdesc Represents a PB_SCTerritoryItemNode.
         * @implements IPB_SCTerritoryItemNode
         * @constructor
         * @param {IPB_SCTerritoryItemNode=} [properties] Properties to set
         */
        function PB_SCTerritoryItemNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTerritoryItemNode seq.
         * @member {number} seq
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.seq = 0;
    
        /**
         * PB_SCTerritoryItemNode index.
         * @member {number} index
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.index = 0;
    
        /**
         * PB_SCTerritoryItemNode attackerNum.
         * @member {number} attackerNum
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.attackerNum = 0;
    
        /**
         * PB_SCTerritoryItemNode attackerEfficiency.
         * @member {number} attackerEfficiency
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.attackerEfficiency = 0;
    
        /**
         * PB_SCTerritoryItemNode attackerInfo.
         * @member {IPB_RoleInfo|null|undefined} attackerInfo
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.attackerInfo = null;
    
        /**
         * PB_SCTerritoryItemNode defenderNum.
         * @member {number} defenderNum
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.defenderNum = 0;
    
        /**
         * PB_SCTerritoryItemNode defenderEfficiency.
         * @member {number} defenderEfficiency
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.defenderEfficiency = 0;
    
        /**
         * PB_SCTerritoryItemNode refreshTime.
         * @member {number} refreshTime
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.refreshTime = 0;
    
        /**
         * PB_SCTerritoryItemNode pos.
         * @member {number} pos
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.pos = 0;
    
        /**
         * PB_SCTerritoryItemNode endTime.
         * @member {number} endTime
         * @memberof PB_SCTerritoryItemNode
         * @instance
         */
        PB_SCTerritoryItemNode.prototype.endTime = 0;
    
        /**
         * Creates a new PB_SCTerritoryItemNode instance using the specified properties.
         * @function create
         * @memberof PB_SCTerritoryItemNode
         * @static
         * @param {IPB_SCTerritoryItemNode=} [properties] Properties to set
         * @returns {PB_SCTerritoryItemNode} PB_SCTerritoryItemNode instance
         */
        PB_SCTerritoryItemNode.create = function create(properties) {
            return new PB_SCTerritoryItemNode(properties);
        };
    
        /**
         * Encodes the specified PB_SCTerritoryItemNode message. Does not implicitly {@link PB_SCTerritoryItemNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTerritoryItemNode
         * @static
         * @param {IPB_SCTerritoryItemNode} message PB_SCTerritoryItemNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryItemNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.seq);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            if (message.attackerNum != null && Object.hasOwnProperty.call(message, "attackerNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.attackerNum);
            if (message.attackerEfficiency != null && Object.hasOwnProperty.call(message, "attackerEfficiency"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.attackerEfficiency);
            if (message.attackerInfo != null && Object.hasOwnProperty.call(message, "attackerInfo"))
                $root.PB_RoleInfo.encode(message.attackerInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.defenderNum != null && Object.hasOwnProperty.call(message, "defenderNum"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.defenderNum);
            if (message.defenderEfficiency != null && Object.hasOwnProperty.call(message, "defenderEfficiency"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.defenderEfficiency);
            if (message.refreshTime != null && Object.hasOwnProperty.call(message, "refreshTime"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.refreshTime);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.pos);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.endTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTerritoryItemNode message, length delimited. Does not implicitly {@link PB_SCTerritoryItemNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTerritoryItemNode
         * @static
         * @param {IPB_SCTerritoryItemNode} message PB_SCTerritoryItemNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryItemNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTerritoryItemNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTerritoryItemNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTerritoryItemNode} PB_SCTerritoryItemNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryItemNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTerritoryItemNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.seq = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                case 3:
                    message.attackerNum = reader.int32();
                    break;
                case 4:
                    message.attackerEfficiency = reader.int32();
                    break;
                case 5:
                    message.attackerInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.defenderNum = reader.int32();
                    break;
                case 7:
                    message.defenderEfficiency = reader.int32();
                    break;
                case 8:
                    message.refreshTime = reader.uint32();
                    break;
                case 9:
                    message.pos = reader.double();
                    break;
                case 10:
                    message.endTime = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTerritoryItemNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTerritoryItemNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTerritoryItemNode} PB_SCTerritoryItemNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryItemNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTerritoryItemNode message.
         * @function verify
         * @memberof PB_SCTerritoryItemNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTerritoryItemNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seq != null && message.hasOwnProperty("seq"))
                if (!$util.isInteger(message.seq))
                    return "seq: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.attackerNum != null && message.hasOwnProperty("attackerNum"))
                if (!$util.isInteger(message.attackerNum))
                    return "attackerNum: integer expected";
            if (message.attackerEfficiency != null && message.hasOwnProperty("attackerEfficiency"))
                if (!$util.isInteger(message.attackerEfficiency))
                    return "attackerEfficiency: integer expected";
            if (message.attackerInfo != null && message.hasOwnProperty("attackerInfo")) {
                var error = $root.PB_RoleInfo.verify(message.attackerInfo);
                if (error)
                    return "attackerInfo." + error;
            }
            if (message.defenderNum != null && message.hasOwnProperty("defenderNum"))
                if (!$util.isInteger(message.defenderNum))
                    return "defenderNum: integer expected";
            if (message.defenderEfficiency != null && message.hasOwnProperty("defenderEfficiency"))
                if (!$util.isInteger(message.defenderEfficiency))
                    return "defenderEfficiency: integer expected";
            if (message.refreshTime != null && message.hasOwnProperty("refreshTime"))
                if (!$util.isInteger(message.refreshTime))
                    return "refreshTime: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (typeof message.pos !== "number")
                    return "pos: number expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime))
                    return "endTime: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCTerritoryItemNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTerritoryItemNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTerritoryItemNode} PB_SCTerritoryItemNode
         */
        PB_SCTerritoryItemNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTerritoryItemNode)
                return object;
            var message = new $root.PB_SCTerritoryItemNode();
            if (object.seq != null)
                message.seq = object.seq | 0;
            if (object.index != null)
                message.index = object.index | 0;
            if (object.attackerNum != null)
                message.attackerNum = object.attackerNum | 0;
            if (object.attackerEfficiency != null)
                message.attackerEfficiency = object.attackerEfficiency | 0;
            if (object.attackerInfo != null) {
                if (typeof object.attackerInfo !== "object")
                    throw TypeError(".PB_SCTerritoryItemNode.attackerInfo: object expected");
                message.attackerInfo = $root.PB_RoleInfo.fromObject(object.attackerInfo);
            }
            if (object.defenderNum != null)
                message.defenderNum = object.defenderNum | 0;
            if (object.defenderEfficiency != null)
                message.defenderEfficiency = object.defenderEfficiency | 0;
            if (object.refreshTime != null)
                message.refreshTime = object.refreshTime >>> 0;
            if (object.pos != null)
                message.pos = Number(object.pos);
            if (object.endTime != null)
                message.endTime = object.endTime >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTerritoryItemNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTerritoryItemNode
         * @static
         * @param {PB_SCTerritoryItemNode} message PB_SCTerritoryItemNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTerritoryItemNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.seq = 0;
                object.index = 0;
                object.attackerNum = 0;
                object.attackerEfficiency = 0;
                object.attackerInfo = null;
                object.defenderNum = 0;
                object.defenderEfficiency = 0;
                object.refreshTime = 0;
                object.pos = 0;
                object.endTime = 0;
            }
            if (message.seq != null && message.hasOwnProperty("seq"))
                object.seq = message.seq;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.attackerNum != null && message.hasOwnProperty("attackerNum"))
                object.attackerNum = message.attackerNum;
            if (message.attackerEfficiency != null && message.hasOwnProperty("attackerEfficiency"))
                object.attackerEfficiency = message.attackerEfficiency;
            if (message.attackerInfo != null && message.hasOwnProperty("attackerInfo"))
                object.attackerInfo = $root.PB_RoleInfo.toObject(message.attackerInfo, options);
            if (message.defenderNum != null && message.hasOwnProperty("defenderNum"))
                object.defenderNum = message.defenderNum;
            if (message.defenderEfficiency != null && message.hasOwnProperty("defenderEfficiency"))
                object.defenderEfficiency = message.defenderEfficiency;
            if (message.refreshTime != null && message.hasOwnProperty("refreshTime"))
                object.refreshTime = message.refreshTime;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = options.json && !isFinite(message.pos) ? String(message.pos) : message.pos;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            return object;
        };
    
        /**
         * Converts this PB_SCTerritoryItemNode to JSON.
         * @function toJSON
         * @memberof PB_SCTerritoryItemNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTerritoryItemNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTerritoryItemNode;
    })();
    
    $root.PB_SCTerritoryInfo = (function() {
    
        /**
         * Properties of a PB_SCTerritoryInfo.
         * @exports IPB_SCTerritoryInfo
         * @interface IPB_SCTerritoryInfo
         * @property {IPB_RoleInfo|null} [roleInfo] PB_SCTerritoryInfo roleInfo
         * @property {number|null} [territoryLevel] PB_SCTerritoryInfo territoryLevel
         * @property {number|null} [botNum] PB_SCTerritoryInfo botNum
         * @property {number|null} [botRunNum] PB_SCTerritoryInfo botRunNum
         * @property {number|null} [botBuyCount] PB_SCTerritoryInfo botBuyCount
         * @property {number|null} [rewardCount] PB_SCTerritoryInfo rewardCount
         * @property {Array.<IPB_SCTerritoryItemNode>|null} [itemList] PB_SCTerritoryInfo itemList
         * @property {number|null} [reason] PB_SCTerritoryInfo reason
         */
    
        /**
         * Constructs a new PB_SCTerritoryInfo.
         * @exports PB_SCTerritoryInfo
         * @classdesc Represents a PB_SCTerritoryInfo.
         * @implements IPB_SCTerritoryInfo
         * @constructor
         * @param {IPB_SCTerritoryInfo=} [properties] Properties to set
         */
        function PB_SCTerritoryInfo(properties) {
            this.itemList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTerritoryInfo roleInfo.
         * @member {IPB_RoleInfo|null|undefined} roleInfo
         * @memberof PB_SCTerritoryInfo
         * @instance
         */
        PB_SCTerritoryInfo.prototype.roleInfo = null;
    
        /**
         * PB_SCTerritoryInfo territoryLevel.
         * @member {number} territoryLevel
         * @memberof PB_SCTerritoryInfo
         * @instance
         */
        PB_SCTerritoryInfo.prototype.territoryLevel = 0;
    
        /**
         * PB_SCTerritoryInfo botNum.
         * @member {number} botNum
         * @memberof PB_SCTerritoryInfo
         * @instance
         */
        PB_SCTerritoryInfo.prototype.botNum = 0;
    
        /**
         * PB_SCTerritoryInfo botRunNum.
         * @member {number} botRunNum
         * @memberof PB_SCTerritoryInfo
         * @instance
         */
        PB_SCTerritoryInfo.prototype.botRunNum = 0;
    
        /**
         * PB_SCTerritoryInfo botBuyCount.
         * @member {number} botBuyCount
         * @memberof PB_SCTerritoryInfo
         * @instance
         */
        PB_SCTerritoryInfo.prototype.botBuyCount = 0;
    
        /**
         * PB_SCTerritoryInfo rewardCount.
         * @member {number} rewardCount
         * @memberof PB_SCTerritoryInfo
         * @instance
         */
        PB_SCTerritoryInfo.prototype.rewardCount = 0;
    
        /**
         * PB_SCTerritoryInfo itemList.
         * @member {Array.<IPB_SCTerritoryItemNode>} itemList
         * @memberof PB_SCTerritoryInfo
         * @instance
         */
        PB_SCTerritoryInfo.prototype.itemList = $util.emptyArray;
    
        /**
         * PB_SCTerritoryInfo reason.
         * @member {number} reason
         * @memberof PB_SCTerritoryInfo
         * @instance
         */
        PB_SCTerritoryInfo.prototype.reason = 0;
    
        /**
         * Creates a new PB_SCTerritoryInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCTerritoryInfo
         * @static
         * @param {IPB_SCTerritoryInfo=} [properties] Properties to set
         * @returns {PB_SCTerritoryInfo} PB_SCTerritoryInfo instance
         */
        PB_SCTerritoryInfo.create = function create(properties) {
            return new PB_SCTerritoryInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCTerritoryInfo message. Does not implicitly {@link PB_SCTerritoryInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTerritoryInfo
         * @static
         * @param {IPB_SCTerritoryInfo} message PB_SCTerritoryInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleInfo != null && Object.hasOwnProperty.call(message, "roleInfo"))
                $root.PB_RoleInfo.encode(message.roleInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.territoryLevel != null && Object.hasOwnProperty.call(message, "territoryLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.territoryLevel);
            if (message.botNum != null && Object.hasOwnProperty.call(message, "botNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.botNum);
            if (message.botRunNum != null && Object.hasOwnProperty.call(message, "botRunNum"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.botRunNum);
            if (message.botBuyCount != null && Object.hasOwnProperty.call(message, "botBuyCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.botBuyCount);
            if (message.rewardCount != null && Object.hasOwnProperty.call(message, "rewardCount"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.rewardCount);
            if (message.itemList != null && message.itemList.length)
                for (var i = 0; i < message.itemList.length; ++i)
                    $root.PB_SCTerritoryItemNode.encode(message.itemList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.reason);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTerritoryInfo message, length delimited. Does not implicitly {@link PB_SCTerritoryInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTerritoryInfo
         * @static
         * @param {IPB_SCTerritoryInfo} message PB_SCTerritoryInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTerritoryInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTerritoryInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTerritoryInfo} PB_SCTerritoryInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTerritoryInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.territoryLevel = reader.int32();
                    break;
                case 3:
                    message.botNum = reader.int32();
                    break;
                case 4:
                    message.botRunNum = reader.int32();
                    break;
                case 5:
                    message.botBuyCount = reader.int32();
                    break;
                case 6:
                    message.rewardCount = reader.int32();
                    break;
                case 7:
                    if (!(message.itemList && message.itemList.length))
                        message.itemList = [];
                    message.itemList.push($root.PB_SCTerritoryItemNode.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTerritoryInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTerritoryInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTerritoryInfo} PB_SCTerritoryInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTerritoryInfo message.
         * @function verify
         * @memberof PB_SCTerritoryInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTerritoryInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleInfo);
                if (error)
                    return "roleInfo." + error;
            }
            if (message.territoryLevel != null && message.hasOwnProperty("territoryLevel"))
                if (!$util.isInteger(message.territoryLevel))
                    return "territoryLevel: integer expected";
            if (message.botNum != null && message.hasOwnProperty("botNum"))
                if (!$util.isInteger(message.botNum))
                    return "botNum: integer expected";
            if (message.botRunNum != null && message.hasOwnProperty("botRunNum"))
                if (!$util.isInteger(message.botRunNum))
                    return "botRunNum: integer expected";
            if (message.botBuyCount != null && message.hasOwnProperty("botBuyCount"))
                if (!$util.isInteger(message.botBuyCount))
                    return "botBuyCount: integer expected";
            if (message.rewardCount != null && message.hasOwnProperty("rewardCount"))
                if (!$util.isInteger(message.rewardCount))
                    return "rewardCount: integer expected";
            if (message.itemList != null && message.hasOwnProperty("itemList")) {
                if (!Array.isArray(message.itemList))
                    return "itemList: array expected";
                for (var i = 0; i < message.itemList.length; ++i) {
                    var error = $root.PB_SCTerritoryItemNode.verify(message.itemList[i]);
                    if (error)
                        return "itemList." + error;
                }
            }
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isInteger(message.reason))
                    return "reason: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCTerritoryInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTerritoryInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTerritoryInfo} PB_SCTerritoryInfo
         */
        PB_SCTerritoryInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTerritoryInfo)
                return object;
            var message = new $root.PB_SCTerritoryInfo();
            if (object.roleInfo != null) {
                if (typeof object.roleInfo !== "object")
                    throw TypeError(".PB_SCTerritoryInfo.roleInfo: object expected");
                message.roleInfo = $root.PB_RoleInfo.fromObject(object.roleInfo);
            }
            if (object.territoryLevel != null)
                message.territoryLevel = object.territoryLevel | 0;
            if (object.botNum != null)
                message.botNum = object.botNum | 0;
            if (object.botRunNum != null)
                message.botRunNum = object.botRunNum | 0;
            if (object.botBuyCount != null)
                message.botBuyCount = object.botBuyCount | 0;
            if (object.rewardCount != null)
                message.rewardCount = object.rewardCount | 0;
            if (object.itemList) {
                if (!Array.isArray(object.itemList))
                    throw TypeError(".PB_SCTerritoryInfo.itemList: array expected");
                message.itemList = [];
                for (var i = 0; i < object.itemList.length; ++i) {
                    if (typeof object.itemList[i] !== "object")
                        throw TypeError(".PB_SCTerritoryInfo.itemList: object expected");
                    message.itemList[i] = $root.PB_SCTerritoryItemNode.fromObject(object.itemList[i]);
                }
            }
            if (object.reason != null)
                message.reason = object.reason | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTerritoryInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTerritoryInfo
         * @static
         * @param {PB_SCTerritoryInfo} message PB_SCTerritoryInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTerritoryInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemList = [];
            if (options.defaults) {
                object.roleInfo = null;
                object.territoryLevel = 0;
                object.botNum = 0;
                object.botRunNum = 0;
                object.botBuyCount = 0;
                object.rewardCount = 0;
                object.reason = 0;
            }
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo"))
                object.roleInfo = $root.PB_RoleInfo.toObject(message.roleInfo, options);
            if (message.territoryLevel != null && message.hasOwnProperty("territoryLevel"))
                object.territoryLevel = message.territoryLevel;
            if (message.botNum != null && message.hasOwnProperty("botNum"))
                object.botNum = message.botNum;
            if (message.botRunNum != null && message.hasOwnProperty("botRunNum"))
                object.botRunNum = message.botRunNum;
            if (message.botBuyCount != null && message.hasOwnProperty("botBuyCount"))
                object.botBuyCount = message.botBuyCount;
            if (message.rewardCount != null && message.hasOwnProperty("rewardCount"))
                object.rewardCount = message.rewardCount;
            if (message.itemList && message.itemList.length) {
                object.itemList = [];
                for (var j = 0; j < message.itemList.length; ++j)
                    object.itemList[j] = $root.PB_SCTerritoryItemNode.toObject(message.itemList[j], options);
            }
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };
    
        /**
         * Converts this PB_SCTerritoryInfo to JSON.
         * @function toJSON
         * @memberof PB_SCTerritoryInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTerritoryInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTerritoryInfo;
    })();
    
    $root.PB_SCTerritoryNeighbourRole = (function() {
    
        /**
         * Properties of a PB_SCTerritoryNeighbourRole.
         * @exports IPB_SCTerritoryNeighbourRole
         * @interface IPB_SCTerritoryNeighbourRole
         * @property {IPB_RoleInfo|null} [roleInfo] PB_SCTerritoryNeighbourRole roleInfo
         * @property {Array.<number>|null} [itemSeq] PB_SCTerritoryNeighbourRole itemSeq
         */
    
        /**
         * Constructs a new PB_SCTerritoryNeighbourRole.
         * @exports PB_SCTerritoryNeighbourRole
         * @classdesc Represents a PB_SCTerritoryNeighbourRole.
         * @implements IPB_SCTerritoryNeighbourRole
         * @constructor
         * @param {IPB_SCTerritoryNeighbourRole=} [properties] Properties to set
         */
        function PB_SCTerritoryNeighbourRole(properties) {
            this.itemSeq = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTerritoryNeighbourRole roleInfo.
         * @member {IPB_RoleInfo|null|undefined} roleInfo
         * @memberof PB_SCTerritoryNeighbourRole
         * @instance
         */
        PB_SCTerritoryNeighbourRole.prototype.roleInfo = null;
    
        /**
         * PB_SCTerritoryNeighbourRole itemSeq.
         * @member {Array.<number>} itemSeq
         * @memberof PB_SCTerritoryNeighbourRole
         * @instance
         */
        PB_SCTerritoryNeighbourRole.prototype.itemSeq = $util.emptyArray;
    
        /**
         * Creates a new PB_SCTerritoryNeighbourRole instance using the specified properties.
         * @function create
         * @memberof PB_SCTerritoryNeighbourRole
         * @static
         * @param {IPB_SCTerritoryNeighbourRole=} [properties] Properties to set
         * @returns {PB_SCTerritoryNeighbourRole} PB_SCTerritoryNeighbourRole instance
         */
        PB_SCTerritoryNeighbourRole.create = function create(properties) {
            return new PB_SCTerritoryNeighbourRole(properties);
        };
    
        /**
         * Encodes the specified PB_SCTerritoryNeighbourRole message. Does not implicitly {@link PB_SCTerritoryNeighbourRole.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTerritoryNeighbourRole
         * @static
         * @param {IPB_SCTerritoryNeighbourRole} message PB_SCTerritoryNeighbourRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryNeighbourRole.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleInfo != null && Object.hasOwnProperty.call(message, "roleInfo"))
                $root.PB_RoleInfo.encode(message.roleInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.itemSeq != null && message.itemSeq.length)
                for (var i = 0; i < message.itemSeq.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.itemSeq[i]);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTerritoryNeighbourRole message, length delimited. Does not implicitly {@link PB_SCTerritoryNeighbourRole.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTerritoryNeighbourRole
         * @static
         * @param {IPB_SCTerritoryNeighbourRole} message PB_SCTerritoryNeighbourRole message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryNeighbourRole.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTerritoryNeighbourRole message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTerritoryNeighbourRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTerritoryNeighbourRole} PB_SCTerritoryNeighbourRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryNeighbourRole.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTerritoryNeighbourRole();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.itemSeq && message.itemSeq.length))
                        message.itemSeq = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.itemSeq.push(reader.int32());
                    } else
                        message.itemSeq.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTerritoryNeighbourRole message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTerritoryNeighbourRole
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTerritoryNeighbourRole} PB_SCTerritoryNeighbourRole
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryNeighbourRole.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTerritoryNeighbourRole message.
         * @function verify
         * @memberof PB_SCTerritoryNeighbourRole
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTerritoryNeighbourRole.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleInfo);
                if (error)
                    return "roleInfo." + error;
            }
            if (message.itemSeq != null && message.hasOwnProperty("itemSeq")) {
                if (!Array.isArray(message.itemSeq))
                    return "itemSeq: array expected";
                for (var i = 0; i < message.itemSeq.length; ++i)
                    if (!$util.isInteger(message.itemSeq[i]))
                        return "itemSeq: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a PB_SCTerritoryNeighbourRole message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTerritoryNeighbourRole
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTerritoryNeighbourRole} PB_SCTerritoryNeighbourRole
         */
        PB_SCTerritoryNeighbourRole.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTerritoryNeighbourRole)
                return object;
            var message = new $root.PB_SCTerritoryNeighbourRole();
            if (object.roleInfo != null) {
                if (typeof object.roleInfo !== "object")
                    throw TypeError(".PB_SCTerritoryNeighbourRole.roleInfo: object expected");
                message.roleInfo = $root.PB_RoleInfo.fromObject(object.roleInfo);
            }
            if (object.itemSeq) {
                if (!Array.isArray(object.itemSeq))
                    throw TypeError(".PB_SCTerritoryNeighbourRole.itemSeq: array expected");
                message.itemSeq = [];
                for (var i = 0; i < object.itemSeq.length; ++i)
                    message.itemSeq[i] = object.itemSeq[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTerritoryNeighbourRole message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTerritoryNeighbourRole
         * @static
         * @param {PB_SCTerritoryNeighbourRole} message PB_SCTerritoryNeighbourRole
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTerritoryNeighbourRole.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemSeq = [];
            if (options.defaults)
                object.roleInfo = null;
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo"))
                object.roleInfo = $root.PB_RoleInfo.toObject(message.roleInfo, options);
            if (message.itemSeq && message.itemSeq.length) {
                object.itemSeq = [];
                for (var j = 0; j < message.itemSeq.length; ++j)
                    object.itemSeq[j] = message.itemSeq[j];
            }
            return object;
        };
    
        /**
         * Converts this PB_SCTerritoryNeighbourRole to JSON.
         * @function toJSON
         * @memberof PB_SCTerritoryNeighbourRole
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTerritoryNeighbourRole.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTerritoryNeighbourRole;
    })();
    
    $root.PB_SCTerritoryNeighbourInfo = (function() {
    
        /**
         * Properties of a PB_SCTerritoryNeighbourInfo.
         * @exports IPB_SCTerritoryNeighbourInfo
         * @interface IPB_SCTerritoryNeighbourInfo
         * @property {number|null} [neighbourTime] PB_SCTerritoryNeighbourInfo neighbourTime
         * @property {Array.<IPB_SCTerritoryNeighbourRole>|null} [neighbourList] PB_SCTerritoryNeighbourInfo neighbourList
         * @property {Array.<IPB_SCTerritoryNeighbourRole>|null} [enemyList] PB_SCTerritoryNeighbourInfo enemyList
         */
    
        /**
         * Constructs a new PB_SCTerritoryNeighbourInfo.
         * @exports PB_SCTerritoryNeighbourInfo
         * @classdesc Represents a PB_SCTerritoryNeighbourInfo.
         * @implements IPB_SCTerritoryNeighbourInfo
         * @constructor
         * @param {IPB_SCTerritoryNeighbourInfo=} [properties] Properties to set
         */
        function PB_SCTerritoryNeighbourInfo(properties) {
            this.neighbourList = [];
            this.enemyList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTerritoryNeighbourInfo neighbourTime.
         * @member {number} neighbourTime
         * @memberof PB_SCTerritoryNeighbourInfo
         * @instance
         */
        PB_SCTerritoryNeighbourInfo.prototype.neighbourTime = 0;
    
        /**
         * PB_SCTerritoryNeighbourInfo neighbourList.
         * @member {Array.<IPB_SCTerritoryNeighbourRole>} neighbourList
         * @memberof PB_SCTerritoryNeighbourInfo
         * @instance
         */
        PB_SCTerritoryNeighbourInfo.prototype.neighbourList = $util.emptyArray;
    
        /**
         * PB_SCTerritoryNeighbourInfo enemyList.
         * @member {Array.<IPB_SCTerritoryNeighbourRole>} enemyList
         * @memberof PB_SCTerritoryNeighbourInfo
         * @instance
         */
        PB_SCTerritoryNeighbourInfo.prototype.enemyList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCTerritoryNeighbourInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCTerritoryNeighbourInfo
         * @static
         * @param {IPB_SCTerritoryNeighbourInfo=} [properties] Properties to set
         * @returns {PB_SCTerritoryNeighbourInfo} PB_SCTerritoryNeighbourInfo instance
         */
        PB_SCTerritoryNeighbourInfo.create = function create(properties) {
            return new PB_SCTerritoryNeighbourInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCTerritoryNeighbourInfo message. Does not implicitly {@link PB_SCTerritoryNeighbourInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTerritoryNeighbourInfo
         * @static
         * @param {IPB_SCTerritoryNeighbourInfo} message PB_SCTerritoryNeighbourInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryNeighbourInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.neighbourTime != null && Object.hasOwnProperty.call(message, "neighbourTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.neighbourTime);
            if (message.neighbourList != null && message.neighbourList.length)
                for (var i = 0; i < message.neighbourList.length; ++i)
                    $root.PB_SCTerritoryNeighbourRole.encode(message.neighbourList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.enemyList != null && message.enemyList.length)
                for (var i = 0; i < message.enemyList.length; ++i)
                    $root.PB_SCTerritoryNeighbourRole.encode(message.enemyList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTerritoryNeighbourInfo message, length delimited. Does not implicitly {@link PB_SCTerritoryNeighbourInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTerritoryNeighbourInfo
         * @static
         * @param {IPB_SCTerritoryNeighbourInfo} message PB_SCTerritoryNeighbourInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryNeighbourInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTerritoryNeighbourInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTerritoryNeighbourInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTerritoryNeighbourInfo} PB_SCTerritoryNeighbourInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryNeighbourInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTerritoryNeighbourInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.neighbourTime = reader.int32();
                    break;
                case 2:
                    if (!(message.neighbourList && message.neighbourList.length))
                        message.neighbourList = [];
                    message.neighbourList.push($root.PB_SCTerritoryNeighbourRole.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.enemyList && message.enemyList.length))
                        message.enemyList = [];
                    message.enemyList.push($root.PB_SCTerritoryNeighbourRole.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTerritoryNeighbourInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTerritoryNeighbourInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTerritoryNeighbourInfo} PB_SCTerritoryNeighbourInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryNeighbourInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTerritoryNeighbourInfo message.
         * @function verify
         * @memberof PB_SCTerritoryNeighbourInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTerritoryNeighbourInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.neighbourTime != null && message.hasOwnProperty("neighbourTime"))
                if (!$util.isInteger(message.neighbourTime))
                    return "neighbourTime: integer expected";
            if (message.neighbourList != null && message.hasOwnProperty("neighbourList")) {
                if (!Array.isArray(message.neighbourList))
                    return "neighbourList: array expected";
                for (var i = 0; i < message.neighbourList.length; ++i) {
                    var error = $root.PB_SCTerritoryNeighbourRole.verify(message.neighbourList[i]);
                    if (error)
                        return "neighbourList." + error;
                }
            }
            if (message.enemyList != null && message.hasOwnProperty("enemyList")) {
                if (!Array.isArray(message.enemyList))
                    return "enemyList: array expected";
                for (var i = 0; i < message.enemyList.length; ++i) {
                    var error = $root.PB_SCTerritoryNeighbourRole.verify(message.enemyList[i]);
                    if (error)
                        return "enemyList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCTerritoryNeighbourInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTerritoryNeighbourInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTerritoryNeighbourInfo} PB_SCTerritoryNeighbourInfo
         */
        PB_SCTerritoryNeighbourInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTerritoryNeighbourInfo)
                return object;
            var message = new $root.PB_SCTerritoryNeighbourInfo();
            if (object.neighbourTime != null)
                message.neighbourTime = object.neighbourTime | 0;
            if (object.neighbourList) {
                if (!Array.isArray(object.neighbourList))
                    throw TypeError(".PB_SCTerritoryNeighbourInfo.neighbourList: array expected");
                message.neighbourList = [];
                for (var i = 0; i < object.neighbourList.length; ++i) {
                    if (typeof object.neighbourList[i] !== "object")
                        throw TypeError(".PB_SCTerritoryNeighbourInfo.neighbourList: object expected");
                    message.neighbourList[i] = $root.PB_SCTerritoryNeighbourRole.fromObject(object.neighbourList[i]);
                }
            }
            if (object.enemyList) {
                if (!Array.isArray(object.enemyList))
                    throw TypeError(".PB_SCTerritoryNeighbourInfo.enemyList: array expected");
                message.enemyList = [];
                for (var i = 0; i < object.enemyList.length; ++i) {
                    if (typeof object.enemyList[i] !== "object")
                        throw TypeError(".PB_SCTerritoryNeighbourInfo.enemyList: object expected");
                    message.enemyList[i] = $root.PB_SCTerritoryNeighbourRole.fromObject(object.enemyList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTerritoryNeighbourInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTerritoryNeighbourInfo
         * @static
         * @param {PB_SCTerritoryNeighbourInfo} message PB_SCTerritoryNeighbourInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTerritoryNeighbourInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.neighbourList = [];
                object.enemyList = [];
            }
            if (options.defaults)
                object.neighbourTime = 0;
            if (message.neighbourTime != null && message.hasOwnProperty("neighbourTime"))
                object.neighbourTime = message.neighbourTime;
            if (message.neighbourList && message.neighbourList.length) {
                object.neighbourList = [];
                for (var j = 0; j < message.neighbourList.length; ++j)
                    object.neighbourList[j] = $root.PB_SCTerritoryNeighbourRole.toObject(message.neighbourList[j], options);
            }
            if (message.enemyList && message.enemyList.length) {
                object.enemyList = [];
                for (var j = 0; j < message.enemyList.length; ++j)
                    object.enemyList[j] = $root.PB_SCTerritoryNeighbourRole.toObject(message.enemyList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCTerritoryNeighbourInfo to JSON.
         * @function toJSON
         * @memberof PB_SCTerritoryNeighbourInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTerritoryNeighbourInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTerritoryNeighbourInfo;
    })();
    
    $root.PB_SCTerritoryBotNode = (function() {
    
        /**
         * Properties of a PB_SCTerritoryBotNode.
         * @exports IPB_SCTerritoryBotNode
         * @interface IPB_SCTerritoryBotNode
         * @property {IPB_RoleInfo|null} [attackerInfo] PB_SCTerritoryBotNode attackerInfo
         * @property {number|null} [attackerNum] PB_SCTerritoryBotNode attackerNum
         * @property {IPB_RoleInfo|null} [defenderInfo] PB_SCTerritoryBotNode defenderInfo
         * @property {number|null} [defenderNum] PB_SCTerritoryBotNode defenderNum
         * @property {number|null} [endTime] PB_SCTerritoryBotNode endTime
         * @property {number|null} [itemSeq] PB_SCTerritoryBotNode itemSeq
         * @property {number|null} [itemIndex] PB_SCTerritoryBotNode itemIndex
         * @property {boolean|null} [isAttack] PB_SCTerritoryBotNode isAttack
         */
    
        /**
         * Constructs a new PB_SCTerritoryBotNode.
         * @exports PB_SCTerritoryBotNode
         * @classdesc Represents a PB_SCTerritoryBotNode.
         * @implements IPB_SCTerritoryBotNode
         * @constructor
         * @param {IPB_SCTerritoryBotNode=} [properties] Properties to set
         */
        function PB_SCTerritoryBotNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTerritoryBotNode attackerInfo.
         * @member {IPB_RoleInfo|null|undefined} attackerInfo
         * @memberof PB_SCTerritoryBotNode
         * @instance
         */
        PB_SCTerritoryBotNode.prototype.attackerInfo = null;
    
        /**
         * PB_SCTerritoryBotNode attackerNum.
         * @member {number} attackerNum
         * @memberof PB_SCTerritoryBotNode
         * @instance
         */
        PB_SCTerritoryBotNode.prototype.attackerNum = 0;
    
        /**
         * PB_SCTerritoryBotNode defenderInfo.
         * @member {IPB_RoleInfo|null|undefined} defenderInfo
         * @memberof PB_SCTerritoryBotNode
         * @instance
         */
        PB_SCTerritoryBotNode.prototype.defenderInfo = null;
    
        /**
         * PB_SCTerritoryBotNode defenderNum.
         * @member {number} defenderNum
         * @memberof PB_SCTerritoryBotNode
         * @instance
         */
        PB_SCTerritoryBotNode.prototype.defenderNum = 0;
    
        /**
         * PB_SCTerritoryBotNode endTime.
         * @member {number} endTime
         * @memberof PB_SCTerritoryBotNode
         * @instance
         */
        PB_SCTerritoryBotNode.prototype.endTime = 0;
    
        /**
         * PB_SCTerritoryBotNode itemSeq.
         * @member {number} itemSeq
         * @memberof PB_SCTerritoryBotNode
         * @instance
         */
        PB_SCTerritoryBotNode.prototype.itemSeq = 0;
    
        /**
         * PB_SCTerritoryBotNode itemIndex.
         * @member {number} itemIndex
         * @memberof PB_SCTerritoryBotNode
         * @instance
         */
        PB_SCTerritoryBotNode.prototype.itemIndex = 0;
    
        /**
         * PB_SCTerritoryBotNode isAttack.
         * @member {boolean} isAttack
         * @memberof PB_SCTerritoryBotNode
         * @instance
         */
        PB_SCTerritoryBotNode.prototype.isAttack = false;
    
        /**
         * Creates a new PB_SCTerritoryBotNode instance using the specified properties.
         * @function create
         * @memberof PB_SCTerritoryBotNode
         * @static
         * @param {IPB_SCTerritoryBotNode=} [properties] Properties to set
         * @returns {PB_SCTerritoryBotNode} PB_SCTerritoryBotNode instance
         */
        PB_SCTerritoryBotNode.create = function create(properties) {
            return new PB_SCTerritoryBotNode(properties);
        };
    
        /**
         * Encodes the specified PB_SCTerritoryBotNode message. Does not implicitly {@link PB_SCTerritoryBotNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTerritoryBotNode
         * @static
         * @param {IPB_SCTerritoryBotNode} message PB_SCTerritoryBotNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryBotNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.attackerInfo != null && Object.hasOwnProperty.call(message, "attackerInfo"))
                $root.PB_RoleInfo.encode(message.attackerInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.attackerNum != null && Object.hasOwnProperty.call(message, "attackerNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.attackerNum);
            if (message.defenderInfo != null && Object.hasOwnProperty.call(message, "defenderInfo"))
                $root.PB_RoleInfo.encode(message.defenderInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.defenderNum != null && Object.hasOwnProperty.call(message, "defenderNum"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.defenderNum);
            if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.endTime);
            if (message.itemSeq != null && Object.hasOwnProperty.call(message, "itemSeq"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.itemSeq);
            if (message.itemIndex != null && Object.hasOwnProperty.call(message, "itemIndex"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.itemIndex);
            if (message.isAttack != null && Object.hasOwnProperty.call(message, "isAttack"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.isAttack);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTerritoryBotNode message, length delimited. Does not implicitly {@link PB_SCTerritoryBotNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTerritoryBotNode
         * @static
         * @param {IPB_SCTerritoryBotNode} message PB_SCTerritoryBotNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryBotNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTerritoryBotNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTerritoryBotNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTerritoryBotNode} PB_SCTerritoryBotNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryBotNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTerritoryBotNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.attackerInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.attackerNum = reader.int32();
                    break;
                case 3:
                    message.defenderInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.defenderNum = reader.int32();
                    break;
                case 5:
                    message.endTime = reader.uint32();
                    break;
                case 6:
                    message.itemSeq = reader.int32();
                    break;
                case 7:
                    message.itemIndex = reader.int32();
                    break;
                case 8:
                    message.isAttack = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTerritoryBotNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTerritoryBotNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTerritoryBotNode} PB_SCTerritoryBotNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryBotNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTerritoryBotNode message.
         * @function verify
         * @memberof PB_SCTerritoryBotNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTerritoryBotNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.attackerInfo != null && message.hasOwnProperty("attackerInfo")) {
                var error = $root.PB_RoleInfo.verify(message.attackerInfo);
                if (error)
                    return "attackerInfo." + error;
            }
            if (message.attackerNum != null && message.hasOwnProperty("attackerNum"))
                if (!$util.isInteger(message.attackerNum))
                    return "attackerNum: integer expected";
            if (message.defenderInfo != null && message.hasOwnProperty("defenderInfo")) {
                var error = $root.PB_RoleInfo.verify(message.defenderInfo);
                if (error)
                    return "defenderInfo." + error;
            }
            if (message.defenderNum != null && message.hasOwnProperty("defenderNum"))
                if (!$util.isInteger(message.defenderNum))
                    return "defenderNum: integer expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime))
                    return "endTime: integer expected";
            if (message.itemSeq != null && message.hasOwnProperty("itemSeq"))
                if (!$util.isInteger(message.itemSeq))
                    return "itemSeq: integer expected";
            if (message.itemIndex != null && message.hasOwnProperty("itemIndex"))
                if (!$util.isInteger(message.itemIndex))
                    return "itemIndex: integer expected";
            if (message.isAttack != null && message.hasOwnProperty("isAttack"))
                if (typeof message.isAttack !== "boolean")
                    return "isAttack: boolean expected";
            return null;
        };
    
        /**
         * Creates a PB_SCTerritoryBotNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTerritoryBotNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTerritoryBotNode} PB_SCTerritoryBotNode
         */
        PB_SCTerritoryBotNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTerritoryBotNode)
                return object;
            var message = new $root.PB_SCTerritoryBotNode();
            if (object.attackerInfo != null) {
                if (typeof object.attackerInfo !== "object")
                    throw TypeError(".PB_SCTerritoryBotNode.attackerInfo: object expected");
                message.attackerInfo = $root.PB_RoleInfo.fromObject(object.attackerInfo);
            }
            if (object.attackerNum != null)
                message.attackerNum = object.attackerNum | 0;
            if (object.defenderInfo != null) {
                if (typeof object.defenderInfo !== "object")
                    throw TypeError(".PB_SCTerritoryBotNode.defenderInfo: object expected");
                message.defenderInfo = $root.PB_RoleInfo.fromObject(object.defenderInfo);
            }
            if (object.defenderNum != null)
                message.defenderNum = object.defenderNum | 0;
            if (object.endTime != null)
                message.endTime = object.endTime >>> 0;
            if (object.itemSeq != null)
                message.itemSeq = object.itemSeq | 0;
            if (object.itemIndex != null)
                message.itemIndex = object.itemIndex | 0;
            if (object.isAttack != null)
                message.isAttack = Boolean(object.isAttack);
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTerritoryBotNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTerritoryBotNode
         * @static
         * @param {PB_SCTerritoryBotNode} message PB_SCTerritoryBotNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTerritoryBotNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.attackerInfo = null;
                object.attackerNum = 0;
                object.defenderInfo = null;
                object.defenderNum = 0;
                object.endTime = 0;
                object.itemSeq = 0;
                object.itemIndex = 0;
                object.isAttack = false;
            }
            if (message.attackerInfo != null && message.hasOwnProperty("attackerInfo"))
                object.attackerInfo = $root.PB_RoleInfo.toObject(message.attackerInfo, options);
            if (message.attackerNum != null && message.hasOwnProperty("attackerNum"))
                object.attackerNum = message.attackerNum;
            if (message.defenderInfo != null && message.hasOwnProperty("defenderInfo"))
                object.defenderInfo = $root.PB_RoleInfo.toObject(message.defenderInfo, options);
            if (message.defenderNum != null && message.hasOwnProperty("defenderNum"))
                object.defenderNum = message.defenderNum;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime = message.endTime;
            if (message.itemSeq != null && message.hasOwnProperty("itemSeq"))
                object.itemSeq = message.itemSeq;
            if (message.itemIndex != null && message.hasOwnProperty("itemIndex"))
                object.itemIndex = message.itemIndex;
            if (message.isAttack != null && message.hasOwnProperty("isAttack"))
                object.isAttack = message.isAttack;
            return object;
        };
    
        /**
         * Converts this PB_SCTerritoryBotNode to JSON.
         * @function toJSON
         * @memberof PB_SCTerritoryBotNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTerritoryBotNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTerritoryBotNode;
    })();
    
    $root.PB_SCTerritoryBotInfo = (function() {
    
        /**
         * Properties of a PB_SCTerritoryBotInfo.
         * @exports IPB_SCTerritoryBotInfo
         * @interface IPB_SCTerritoryBotInfo
         * @property {Array.<IPB_SCTerritoryBotNode>|null} [botList] PB_SCTerritoryBotInfo botList
         */
    
        /**
         * Constructs a new PB_SCTerritoryBotInfo.
         * @exports PB_SCTerritoryBotInfo
         * @classdesc Represents a PB_SCTerritoryBotInfo.
         * @implements IPB_SCTerritoryBotInfo
         * @constructor
         * @param {IPB_SCTerritoryBotInfo=} [properties] Properties to set
         */
        function PB_SCTerritoryBotInfo(properties) {
            this.botList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTerritoryBotInfo botList.
         * @member {Array.<IPB_SCTerritoryBotNode>} botList
         * @memberof PB_SCTerritoryBotInfo
         * @instance
         */
        PB_SCTerritoryBotInfo.prototype.botList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCTerritoryBotInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCTerritoryBotInfo
         * @static
         * @param {IPB_SCTerritoryBotInfo=} [properties] Properties to set
         * @returns {PB_SCTerritoryBotInfo} PB_SCTerritoryBotInfo instance
         */
        PB_SCTerritoryBotInfo.create = function create(properties) {
            return new PB_SCTerritoryBotInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCTerritoryBotInfo message. Does not implicitly {@link PB_SCTerritoryBotInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTerritoryBotInfo
         * @static
         * @param {IPB_SCTerritoryBotInfo} message PB_SCTerritoryBotInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryBotInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.botList != null && message.botList.length)
                for (var i = 0; i < message.botList.length; ++i)
                    $root.PB_SCTerritoryBotNode.encode(message.botList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTerritoryBotInfo message, length delimited. Does not implicitly {@link PB_SCTerritoryBotInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTerritoryBotInfo
         * @static
         * @param {IPB_SCTerritoryBotInfo} message PB_SCTerritoryBotInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryBotInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTerritoryBotInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTerritoryBotInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTerritoryBotInfo} PB_SCTerritoryBotInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryBotInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTerritoryBotInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.botList && message.botList.length))
                        message.botList = [];
                    message.botList.push($root.PB_SCTerritoryBotNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTerritoryBotInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTerritoryBotInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTerritoryBotInfo} PB_SCTerritoryBotInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryBotInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTerritoryBotInfo message.
         * @function verify
         * @memberof PB_SCTerritoryBotInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTerritoryBotInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.botList != null && message.hasOwnProperty("botList")) {
                if (!Array.isArray(message.botList))
                    return "botList: array expected";
                for (var i = 0; i < message.botList.length; ++i) {
                    var error = $root.PB_SCTerritoryBotNode.verify(message.botList[i]);
                    if (error)
                        return "botList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCTerritoryBotInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTerritoryBotInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTerritoryBotInfo} PB_SCTerritoryBotInfo
         */
        PB_SCTerritoryBotInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTerritoryBotInfo)
                return object;
            var message = new $root.PB_SCTerritoryBotInfo();
            if (object.botList) {
                if (!Array.isArray(object.botList))
                    throw TypeError(".PB_SCTerritoryBotInfo.botList: array expected");
                message.botList = [];
                for (var i = 0; i < object.botList.length; ++i) {
                    if (typeof object.botList[i] !== "object")
                        throw TypeError(".PB_SCTerritoryBotInfo.botList: object expected");
                    message.botList[i] = $root.PB_SCTerritoryBotNode.fromObject(object.botList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTerritoryBotInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTerritoryBotInfo
         * @static
         * @param {PB_SCTerritoryBotInfo} message PB_SCTerritoryBotInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTerritoryBotInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.botList = [];
            if (message.botList && message.botList.length) {
                object.botList = [];
                for (var j = 0; j < message.botList.length; ++j)
                    object.botList[j] = $root.PB_SCTerritoryBotNode.toObject(message.botList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCTerritoryBotInfo to JSON.
         * @function toJSON
         * @memberof PB_SCTerritoryBotInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTerritoryBotInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTerritoryBotInfo;
    })();
    
    $root.PB_SCTerritoryReportNode = (function() {
    
        /**
         * Properties of a PB_SCTerritoryReportNode.
         * @exports IPB_SCTerritoryReportNode
         * @interface IPB_SCTerritoryReportNode
         * @property {IPB_RoleInfo|null} [roleInfo] PB_SCTerritoryReportNode roleInfo
         * @property {Uint8Array|null} [reportSub] PB_SCTerritoryReportNode reportSub
         * @property {Uint8Array|null} [reportText] PB_SCTerritoryReportNode reportText
         * @property {number|null} [reportTime] PB_SCTerritoryReportNode reportTime
         */
    
        /**
         * Constructs a new PB_SCTerritoryReportNode.
         * @exports PB_SCTerritoryReportNode
         * @classdesc Represents a PB_SCTerritoryReportNode.
         * @implements IPB_SCTerritoryReportNode
         * @constructor
         * @param {IPB_SCTerritoryReportNode=} [properties] Properties to set
         */
        function PB_SCTerritoryReportNode(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTerritoryReportNode roleInfo.
         * @member {IPB_RoleInfo|null|undefined} roleInfo
         * @memberof PB_SCTerritoryReportNode
         * @instance
         */
        PB_SCTerritoryReportNode.prototype.roleInfo = null;
    
        /**
         * PB_SCTerritoryReportNode reportSub.
         * @member {Uint8Array} reportSub
         * @memberof PB_SCTerritoryReportNode
         * @instance
         */
        PB_SCTerritoryReportNode.prototype.reportSub = $util.newBuffer([]);
    
        /**
         * PB_SCTerritoryReportNode reportText.
         * @member {Uint8Array} reportText
         * @memberof PB_SCTerritoryReportNode
         * @instance
         */
        PB_SCTerritoryReportNode.prototype.reportText = $util.newBuffer([]);
    
        /**
         * PB_SCTerritoryReportNode reportTime.
         * @member {number} reportTime
         * @memberof PB_SCTerritoryReportNode
         * @instance
         */
        PB_SCTerritoryReportNode.prototype.reportTime = 0;
    
        /**
         * Creates a new PB_SCTerritoryReportNode instance using the specified properties.
         * @function create
         * @memberof PB_SCTerritoryReportNode
         * @static
         * @param {IPB_SCTerritoryReportNode=} [properties] Properties to set
         * @returns {PB_SCTerritoryReportNode} PB_SCTerritoryReportNode instance
         */
        PB_SCTerritoryReportNode.create = function create(properties) {
            return new PB_SCTerritoryReportNode(properties);
        };
    
        /**
         * Encodes the specified PB_SCTerritoryReportNode message. Does not implicitly {@link PB_SCTerritoryReportNode.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTerritoryReportNode
         * @static
         * @param {IPB_SCTerritoryReportNode} message PB_SCTerritoryReportNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryReportNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleInfo != null && Object.hasOwnProperty.call(message, "roleInfo"))
                $root.PB_RoleInfo.encode(message.roleInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.reportSub != null && Object.hasOwnProperty.call(message, "reportSub"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.reportSub);
            if (message.reportText != null && Object.hasOwnProperty.call(message, "reportText"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.reportText);
            if (message.reportTime != null && Object.hasOwnProperty.call(message, "reportTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.reportTime);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTerritoryReportNode message, length delimited. Does not implicitly {@link PB_SCTerritoryReportNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTerritoryReportNode
         * @static
         * @param {IPB_SCTerritoryReportNode} message PB_SCTerritoryReportNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryReportNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTerritoryReportNode message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTerritoryReportNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTerritoryReportNode} PB_SCTerritoryReportNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryReportNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTerritoryReportNode();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleInfo = $root.PB_RoleInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.reportSub = reader.bytes();
                    break;
                case 3:
                    message.reportText = reader.bytes();
                    break;
                case 4:
                    message.reportTime = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTerritoryReportNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTerritoryReportNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTerritoryReportNode} PB_SCTerritoryReportNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryReportNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTerritoryReportNode message.
         * @function verify
         * @memberof PB_SCTerritoryReportNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTerritoryReportNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo")) {
                var error = $root.PB_RoleInfo.verify(message.roleInfo);
                if (error)
                    return "roleInfo." + error;
            }
            if (message.reportSub != null && message.hasOwnProperty("reportSub"))
                if (!(message.reportSub && typeof message.reportSub.length === "number" || $util.isString(message.reportSub)))
                    return "reportSub: buffer expected";
            if (message.reportText != null && message.hasOwnProperty("reportText"))
                if (!(message.reportText && typeof message.reportText.length === "number" || $util.isString(message.reportText)))
                    return "reportText: buffer expected";
            if (message.reportTime != null && message.hasOwnProperty("reportTime"))
                if (!$util.isInteger(message.reportTime))
                    return "reportTime: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCTerritoryReportNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTerritoryReportNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTerritoryReportNode} PB_SCTerritoryReportNode
         */
        PB_SCTerritoryReportNode.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTerritoryReportNode)
                return object;
            var message = new $root.PB_SCTerritoryReportNode();
            if (object.roleInfo != null) {
                if (typeof object.roleInfo !== "object")
                    throw TypeError(".PB_SCTerritoryReportNode.roleInfo: object expected");
                message.roleInfo = $root.PB_RoleInfo.fromObject(object.roleInfo);
            }
            if (object.reportSub != null)
                if (typeof object.reportSub === "string")
                    $util.base64.decode(object.reportSub, message.reportSub = $util.newBuffer($util.base64.length(object.reportSub)), 0);
                else if (object.reportSub.length)
                    message.reportSub = object.reportSub;
            if (object.reportText != null)
                if (typeof object.reportText === "string")
                    $util.base64.decode(object.reportText, message.reportText = $util.newBuffer($util.base64.length(object.reportText)), 0);
                else if (object.reportText.length)
                    message.reportText = object.reportText;
            if (object.reportTime != null)
                message.reportTime = object.reportTime >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTerritoryReportNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTerritoryReportNode
         * @static
         * @param {PB_SCTerritoryReportNode} message PB_SCTerritoryReportNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTerritoryReportNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roleInfo = null;
                if (options.bytes === String)
                    object.reportSub = "";
                else {
                    object.reportSub = [];
                    if (options.bytes !== Array)
                        object.reportSub = $util.newBuffer(object.reportSub);
                }
                if (options.bytes === String)
                    object.reportText = "";
                else {
                    object.reportText = [];
                    if (options.bytes !== Array)
                        object.reportText = $util.newBuffer(object.reportText);
                }
                object.reportTime = 0;
            }
            if (message.roleInfo != null && message.hasOwnProperty("roleInfo"))
                object.roleInfo = $root.PB_RoleInfo.toObject(message.roleInfo, options);
            if (message.reportSub != null && message.hasOwnProperty("reportSub"))
                object.reportSub = options.bytes === String ? $util.base64.encode(message.reportSub, 0, message.reportSub.length) : options.bytes === Array ? Array.prototype.slice.call(message.reportSub) : message.reportSub;
            if (message.reportText != null && message.hasOwnProperty("reportText"))
                object.reportText = options.bytes === String ? $util.base64.encode(message.reportText, 0, message.reportText.length) : options.bytes === Array ? Array.prototype.slice.call(message.reportText) : message.reportText;
            if (message.reportTime != null && message.hasOwnProperty("reportTime"))
                object.reportTime = message.reportTime;
            return object;
        };
    
        /**
         * Converts this PB_SCTerritoryReportNode to JSON.
         * @function toJSON
         * @memberof PB_SCTerritoryReportNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTerritoryReportNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTerritoryReportNode;
    })();
    
    $root.PB_SCTerritoryReportInfo = (function() {
    
        /**
         * Properties of a PB_SCTerritoryReportInfo.
         * @exports IPB_SCTerritoryReportInfo
         * @interface IPB_SCTerritoryReportInfo
         * @property {Array.<IPB_SCTerritoryReportNode>|null} [reportList] PB_SCTerritoryReportInfo reportList
         */
    
        /**
         * Constructs a new PB_SCTerritoryReportInfo.
         * @exports PB_SCTerritoryReportInfo
         * @classdesc Represents a PB_SCTerritoryReportInfo.
         * @implements IPB_SCTerritoryReportInfo
         * @constructor
         * @param {IPB_SCTerritoryReportInfo=} [properties] Properties to set
         */
        function PB_SCTerritoryReportInfo(properties) {
            this.reportList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTerritoryReportInfo reportList.
         * @member {Array.<IPB_SCTerritoryReportNode>} reportList
         * @memberof PB_SCTerritoryReportInfo
         * @instance
         */
        PB_SCTerritoryReportInfo.prototype.reportList = $util.emptyArray;
    
        /**
         * Creates a new PB_SCTerritoryReportInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCTerritoryReportInfo
         * @static
         * @param {IPB_SCTerritoryReportInfo=} [properties] Properties to set
         * @returns {PB_SCTerritoryReportInfo} PB_SCTerritoryReportInfo instance
         */
        PB_SCTerritoryReportInfo.create = function create(properties) {
            return new PB_SCTerritoryReportInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCTerritoryReportInfo message. Does not implicitly {@link PB_SCTerritoryReportInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTerritoryReportInfo
         * @static
         * @param {IPB_SCTerritoryReportInfo} message PB_SCTerritoryReportInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryReportInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reportList != null && message.reportList.length)
                for (var i = 0; i < message.reportList.length; ++i)
                    $root.PB_SCTerritoryReportNode.encode(message.reportList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTerritoryReportInfo message, length delimited. Does not implicitly {@link PB_SCTerritoryReportInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTerritoryReportInfo
         * @static
         * @param {IPB_SCTerritoryReportInfo} message PB_SCTerritoryReportInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryReportInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTerritoryReportInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTerritoryReportInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTerritoryReportInfo} PB_SCTerritoryReportInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryReportInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTerritoryReportInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.reportList && message.reportList.length))
                        message.reportList = [];
                    message.reportList.push($root.PB_SCTerritoryReportNode.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTerritoryReportInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTerritoryReportInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTerritoryReportInfo} PB_SCTerritoryReportInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryReportInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTerritoryReportInfo message.
         * @function verify
         * @memberof PB_SCTerritoryReportInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTerritoryReportInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reportList != null && message.hasOwnProperty("reportList")) {
                if (!Array.isArray(message.reportList))
                    return "reportList: array expected";
                for (var i = 0; i < message.reportList.length; ++i) {
                    var error = $root.PB_SCTerritoryReportNode.verify(message.reportList[i]);
                    if (error)
                        return "reportList." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a PB_SCTerritoryReportInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTerritoryReportInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTerritoryReportInfo} PB_SCTerritoryReportInfo
         */
        PB_SCTerritoryReportInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTerritoryReportInfo)
                return object;
            var message = new $root.PB_SCTerritoryReportInfo();
            if (object.reportList) {
                if (!Array.isArray(object.reportList))
                    throw TypeError(".PB_SCTerritoryReportInfo.reportList: array expected");
                message.reportList = [];
                for (var i = 0; i < object.reportList.length; ++i) {
                    if (typeof object.reportList[i] !== "object")
                        throw TypeError(".PB_SCTerritoryReportInfo.reportList: object expected");
                    message.reportList[i] = $root.PB_SCTerritoryReportNode.fromObject(object.reportList[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTerritoryReportInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTerritoryReportInfo
         * @static
         * @param {PB_SCTerritoryReportInfo} message PB_SCTerritoryReportInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTerritoryReportInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reportList = [];
            if (message.reportList && message.reportList.length) {
                object.reportList = [];
                for (var j = 0; j < message.reportList.length; ++j)
                    object.reportList[j] = $root.PB_SCTerritoryReportNode.toObject(message.reportList[j], options);
            }
            return object;
        };
    
        /**
         * Converts this PB_SCTerritoryReportInfo to JSON.
         * @function toJSON
         * @memberof PB_SCTerritoryReportInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTerritoryReportInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTerritoryReportInfo;
    })();
    
    $root.PB_SCTerritoryRedInfo = (function() {
    
        /**
         * Properties of a PB_SCTerritoryRedInfo.
         * @exports IPB_SCTerritoryRedInfo
         * @interface IPB_SCTerritoryRedInfo
         * @property {number|null} [rewardFlag] PB_SCTerritoryRedInfo rewardFlag
         */
    
        /**
         * Constructs a new PB_SCTerritoryRedInfo.
         * @exports PB_SCTerritoryRedInfo
         * @classdesc Represents a PB_SCTerritoryRedInfo.
         * @implements IPB_SCTerritoryRedInfo
         * @constructor
         * @param {IPB_SCTerritoryRedInfo=} [properties] Properties to set
         */
        function PB_SCTerritoryRedInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * PB_SCTerritoryRedInfo rewardFlag.
         * @member {number} rewardFlag
         * @memberof PB_SCTerritoryRedInfo
         * @instance
         */
        PB_SCTerritoryRedInfo.prototype.rewardFlag = 0;
    
        /**
         * Creates a new PB_SCTerritoryRedInfo instance using the specified properties.
         * @function create
         * @memberof PB_SCTerritoryRedInfo
         * @static
         * @param {IPB_SCTerritoryRedInfo=} [properties] Properties to set
         * @returns {PB_SCTerritoryRedInfo} PB_SCTerritoryRedInfo instance
         */
        PB_SCTerritoryRedInfo.create = function create(properties) {
            return new PB_SCTerritoryRedInfo(properties);
        };
    
        /**
         * Encodes the specified PB_SCTerritoryRedInfo message. Does not implicitly {@link PB_SCTerritoryRedInfo.verify|verify} messages.
         * @function encode
         * @memberof PB_SCTerritoryRedInfo
         * @static
         * @param {IPB_SCTerritoryRedInfo} message PB_SCTerritoryRedInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryRedInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rewardFlag != null && Object.hasOwnProperty.call(message, "rewardFlag"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rewardFlag);
            return writer;
        };
    
        /**
         * Encodes the specified PB_SCTerritoryRedInfo message, length delimited. Does not implicitly {@link PB_SCTerritoryRedInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PB_SCTerritoryRedInfo
         * @static
         * @param {IPB_SCTerritoryRedInfo} message PB_SCTerritoryRedInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PB_SCTerritoryRedInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PB_SCTerritoryRedInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PB_SCTerritoryRedInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PB_SCTerritoryRedInfo} PB_SCTerritoryRedInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryRedInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB_SCTerritoryRedInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rewardFlag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PB_SCTerritoryRedInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PB_SCTerritoryRedInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PB_SCTerritoryRedInfo} PB_SCTerritoryRedInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PB_SCTerritoryRedInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PB_SCTerritoryRedInfo message.
         * @function verify
         * @memberof PB_SCTerritoryRedInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PB_SCTerritoryRedInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rewardFlag != null && message.hasOwnProperty("rewardFlag"))
                if (!$util.isInteger(message.rewardFlag))
                    return "rewardFlag: integer expected";
            return null;
        };
    
        /**
         * Creates a PB_SCTerritoryRedInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PB_SCTerritoryRedInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PB_SCTerritoryRedInfo} PB_SCTerritoryRedInfo
         */
        PB_SCTerritoryRedInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PB_SCTerritoryRedInfo)
                return object;
            var message = new $root.PB_SCTerritoryRedInfo();
            if (object.rewardFlag != null)
                message.rewardFlag = object.rewardFlag | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a PB_SCTerritoryRedInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PB_SCTerritoryRedInfo
         * @static
         * @param {PB_SCTerritoryRedInfo} message PB_SCTerritoryRedInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PB_SCTerritoryRedInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.rewardFlag = 0;
            if (message.rewardFlag != null && message.hasOwnProperty("rewardFlag"))
                object.rewardFlag = message.rewardFlag;
            return object;
        };
    
        /**
         * Converts this PB_SCTerritoryRedInfo to JSON.
         * @function toJSON
         * @memberof PB_SCTerritoryRedInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PB_SCTerritoryRedInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return PB_SCTerritoryRedInfo;
    })();

    return $root;
})(protobuf)//.PB;


for (var key in pRoot)
{
    (window || global)[key] = pRoot[key];
}